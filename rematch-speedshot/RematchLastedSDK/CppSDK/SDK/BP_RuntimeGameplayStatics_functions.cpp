#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_RuntimeGameplayStatics

#include "Basic.hpp"

#include "BP_RuntimeGameplayStatics_classes.hpp"
#include "BP_RuntimeGameplayStatics_parameters.hpp"


namespace SDK
{

// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.AppendHitPrediction
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayAbilityTargetDataHandle&InTargetData                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// double                                  InPredictionMaxDuration                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm)

struct FGameplayAbilityTargetDataHandle UBP_RuntimeGameplayStatics_C::AppendHitPrediction(class AActor* InActor, const struct FGameplayAbilityTargetDataHandle& InTargetData, double InPredictionMaxDuration, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "AppendHitPrediction");

	Params::BP_RuntimeGameplayStatics_C_AppendHitPrediction Parms{};

	Parms.InActor = InActor;
	Parms.InTargetData = std::move(InTargetData);
	Parms.InPredictionMaxDuration = InPredictionMaxDuration;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.ApplyTeamMPCColors
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeGameplayStatics_C::ApplyTeamMPCColors(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "ApplyTeamMPCColors");

	Params::BP_RuntimeGameplayStatics_C_ApplyTeamMPCColors Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.AreCharactersInSameTeam
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APawn*                            A                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APawn*                            B                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_RuntimeGameplayStatics_C::AreCharactersInSameTeam(class APawn* A, class APawn* B, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "AreCharactersInSameTeam");

	Params::BP_RuntimeGameplayStatics_C_AreCharactersInSameTeam Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.AreCharactersInSameTeam_FromPlayerState
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APlayerState*                     PalyerStateA                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APlayerState*                     PlayerStateB                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_RuntimeGameplayStatics_C::AreCharactersInSameTeam_FromPlayerState(class APlayerState* PalyerStateA, class APlayerState* PlayerStateB, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "AreCharactersInSameTeam_FromPlayerState");

	Params::BP_RuntimeGameplayStatics_C_AreCharactersInSameTeam_FromPlayerState Parms{};

	Parms.PalyerStateA = PalyerStateA;
	Parms.PlayerStateB = PlayerStateB;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.CheckIfTheShootIsAimed
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UBoxComponent*>&           GoalCollisions                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class ABall*                            Ball                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    IsAimed                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_RuntimeGameplayStatics_C::CheckIfTheShootIsAimed(TArray<class UBoxComponent*>& GoalCollisions, class ABall* Ball, bool IsAimed, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "CheckIfTheShootIsAimed");

	Params::BP_RuntimeGameplayStatics_C_CheckIfTheShootIsAimed Parms{};

	Parms.GoalCollisions = std::move(GoalCollisions);
	Parms.Ball = Ball;
	Parms.IsAimed = IsAimed;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	GoalCollisions = std::move(Parms.GoalCollisions);

	return Parms.ReturnValue;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.Compute Prediction Marker Location
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTagContainer&     ShootTypeTagContainer                                  (BlueprintVisible, BlueprintReadOnly, Parm)
// const struct FBallTrajectoryResult&     ShootTrajectory                                        (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)
// bool                                    StopAtFirstBounce                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FPredictionMarkerData>&   PredictionMarkerData                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Succeeded                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeGameplayStatics_C::Compute_Prediction_Marker_Location(const struct FGameplayTagContainer& ShootTypeTagContainer, const struct FBallTrajectoryResult& ShootTrajectory, bool StopAtFirstBounce, TArray<struct FPredictionMarkerData>& PredictionMarkerData, class UObject* __WorldContext, bool* Succeeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "Compute Prediction Marker Location");

	Params::BP_RuntimeGameplayStatics_C_Compute_Prediction_Marker_Location Parms{};

	Parms.ShootTypeTagContainer = std::move(ShootTypeTagContainer);
	Parms.ShootTrajectory = std::move(ShootTrajectory);
	Parms.StopAtFirstBounce = StopAtFirstBounce;
	Parms.PredictionMarkerData = std::move(PredictionMarkerData);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	PredictionMarkerData = std::move(Parms.PredictionMarkerData);

	if (Succeeded != nullptr)
		*Succeeded = Parms.Succeeded;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.GetAllActorsOfClassWithContext
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InContextActor                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TSubclassOf<class AActor>               InActorClass                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm)

void UBP_RuntimeGameplayStatics_C::GetAllActorsOfClassWithContext(class AActor* InContextActor, TSubclassOf<class AActor> InActorClass, class UObject* __WorldContext, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "GetAllActorsOfClassWithContext");

	Params::BP_RuntimeGameplayStatics_C_GetAllActorsOfClassWithContext Parms{};

	Parms.InContextActor = InContextActor;
	Parms.InActorClass = InActorClass;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.GetCurrentOvertimeTime
// (Exec, Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ARuntimeMatchGameState*           InGameState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double UBP_RuntimeGameplayStatics_C::GetCurrentOvertimeTime(class ARuntimeMatchGameState* InGameState, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "GetCurrentOvertimeTime");

	Params::BP_RuntimeGameplayStatics_C_GetCurrentOvertimeTime Parms{};

	Parms.InGameState = InGameState;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.GetNearestBall
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           InRefActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bShouldBeOnScreen                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABall*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)
// EnumPredictionMarkerType*               MarkerType                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class ABall* UBP_RuntimeGameplayStatics_C::GetNearestBall(class AActor* InRefActor, bool bShouldBeOnScreen, class UObject* __WorldContext, EnumPredictionMarkerType* MarkerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "GetNearestBall");

	Params::BP_RuntimeGameplayStatics_C_GetNearestBall Parms{};

	Parms.InRefActor = InRefActor;
	Parms.bShouldBeOnScreen = bShouldBeOnScreen;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (MarkerType != nullptr)
		*MarkerType = Parms.MarkerType;

	return Parms.ReturnValue;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.GetVFXColorsFromTeamColorList
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FLinearColor&              Color                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor*                    VFXColorDark                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor*                    VFXColorBright                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor*                    VisualRemap                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeGameplayStatics_C::GetVFXColorsFromTeamColorList(const struct FLinearColor& Color, class UObject* __WorldContext, struct FLinearColor* VFXColorDark, struct FLinearColor* VFXColorBright, struct FLinearColor* VisualRemap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "GetVFXColorsFromTeamColorList");

	Params::BP_RuntimeGameplayStatics_C_GetVFXColorsFromTeamColorList Parms{};

	Parms.Color = std::move(Color);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (VFXColorDark != nullptr)
		*VFXColorDark = std::move(Parms.VFXColorDark);

	if (VFXColorBright != nullptr)
		*VFXColorBright = std::move(Parms.VFXColorBright);

	if (VisualRemap != nullptr)
		*VisualRemap = std::move(Parms.VisualRemap);
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.HasAnyEmptyTeam
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_RuntimeGameplayStatics_C::HasAnyEmptyTeam(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "HasAnyEmptyTeam");

	Params::BP_RuntimeGameplayStatics_C_HasAnyEmptyTeam Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.IsBallCall
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UPingDataAsset*                   InPingDataAsset                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   OutReturnValue                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeGameplayStatics_C::IsBallCall(class UPingDataAsset* InPingDataAsset, class UObject* __WorldContext, bool* OutReturnValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "IsBallCall");

	Params::BP_RuntimeGameplayStatics_C_IsBallCall Parms{};

	Parms.InPingDataAsset = InPingDataAsset;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutReturnValue != nullptr)
		*OutReturnValue = Parms.OutReturnValue;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.PlayDynamicForceFeedback
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           My_target                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  FeedbackIntensity                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  FeedbackDuration                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeGameplayStatics_C::PlayDynamicForceFeedback(class AActor* My_target, double FeedbackIntensity, double FeedbackDuration, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "PlayDynamicForceFeedback");

	Params::BP_RuntimeGameplayStatics_C_PlayDynamicForceFeedback Parms{};

	Parms.My_target = My_target;
	Parms.FeedbackIntensity = FeedbackIntensity;
	Parms.FeedbackDuration = FeedbackDuration;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.SnapBallToPlayerFeet
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARuntimeCharacter*                Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// class ABall*                            Ball                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeGameplayStatics_C::SnapBallToPlayerFeet(class ARuntimeCharacter* Character, class ABall* Ball, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeGameplayStatics_C", "SnapBallToPlayerFeet");

	Params::BP_RuntimeGameplayStatics_C_SnapBallToPlayerFeet Parms{};

	Parms.Character = Character;
	Parms.Ball = Ball;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.IsActorMoving
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  MinSpeedThresholdToBeMoving                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    CheckOnlyHorizontally                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_RuntimeGameplayStatics_C::IsActorMoving(double MinSpeedThresholdToBeMoving, class AActor* Actor, bool CheckOnlyHorizontally, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_RuntimeGameplayStatics_C", "IsActorMoving");

	Params::BP_RuntimeGameplayStatics_C_IsActorMoving Parms{};

	Parms.MinSpeedThresholdToBeMoving = MinSpeedThresholdToBeMoving;
	Parms.Actor = Actor;
	Parms.CheckOnlyHorizontally = CheckOnlyHorizontally;
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.SmoothStep
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  A                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  B                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  X                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double UBP_RuntimeGameplayStatics_C::SmoothStep(double A, double B, double X, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_RuntimeGameplayStatics_C", "SmoothStep");

	Params::BP_RuntimeGameplayStatics_C_SmoothStep Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.X = X;
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.CheckPlayersRelationType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARuntimePlayerState*              _player1                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ARuntimePlayerState*              _player2                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// ERelationshipType                       _eRelationType                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   isCandidate                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeGameplayStatics_C::CheckPlayersRelationType(class ARuntimePlayerState* _player1, class ARuntimePlayerState* _player2, ERelationshipType _eRelationType, class UObject* __WorldContext, bool* isCandidate) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_RuntimeGameplayStatics_C", "CheckPlayersRelationType");

	Params::BP_RuntimeGameplayStatics_C_CheckPlayersRelationType Parms{};

	Parms._player1 = _player1;
	Parms._player2 = _player2;
	Parms._eRelationType = _eRelationType;
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	if (isCandidate != nullptr)
		*isCandidate = Parms.isCandidate;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.GetOtherTeamIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ARuntimeGameState*                _gameState                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// uint8                                   _uiTeam                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

uint8 UBP_RuntimeGameplayStatics_C::GetOtherTeamIndex(class ARuntimeGameState* _gameState, uint8 _uiTeam, class UObject* __WorldContext) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_RuntimeGameplayStatics_C", "GetOtherTeamIndex");

	Params::BP_RuntimeGameplayStatics_C_GetOtherTeamIndex Parms{};

	Parms._gameState = _gameState;
	Parms._uiTeam = _uiTeam;
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.Is Ball Aimed In Goal Collision
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class ABall*                            Ball                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class UBoxComponent*              GoalCollision                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    CheckAllTrajectoryPoints                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   bIsAimed                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FPredictProjectilePathPointData* PointDetectedInGoalCollision                           (Parm, OutParm, NoDestructor)

void UBP_RuntimeGameplayStatics_C::Is_Ball_Aimed_In_Goal_Collision(class ABall* Ball, const class UBoxComponent* GoalCollision, bool CheckAllTrajectoryPoints, class UObject* __WorldContext, bool* bIsAimed, struct FPredictProjectilePathPointData* PointDetectedInGoalCollision) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_RuntimeGameplayStatics_C", "Is Ball Aimed In Goal Collision");

	Params::BP_RuntimeGameplayStatics_C_Is_Ball_Aimed_In_Goal_Collision Parms{};

	Parms.Ball = Ball;
	Parms.GoalCollision = GoalCollision;
	Parms.CheckAllTrajectoryPoints = CheckAllTrajectoryPoints;
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	if (bIsAimed != nullptr)
		*bIsAimed = Parms.bIsAimed;

	if (PointDetectedInGoalCollision != nullptr)
		*PointDetectedInGoalCollision = std::move(Parms.PointDetectedInGoalCollision);
}


// Function BP_RuntimeGameplayStatics.BP_RuntimeGameplayStatics_C.IsShootBlind
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const struct FShootParams&              ShootParams                                            (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsShootBlind_0                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeGameplayStatics_C::IsShootBlind(const struct FShootParams& ShootParams, class UObject* __WorldContext, bool* IsShootBlind_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_RuntimeGameplayStatics_C", "IsShootBlind");

	Params::BP_RuntimeGameplayStatics_C_IsShootBlind Parms{};

	Parms.ShootParams = std::move(ShootParams);
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	if (IsShootBlind_0 != nullptr)
		*IsShootBlind_0 = Parms.IsShootBlind_0;
}

}

