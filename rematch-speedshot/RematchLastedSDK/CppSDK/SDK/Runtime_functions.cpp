#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Runtime

#include "Basic.hpp"

#include "Runtime_classes.hpp"
#include "Runtime_parameters.hpp"


namespace SDK
{

// Function Runtime.ExperienceComponentBase.BPE_ComputeComponentData
// (Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const class UObject*                    _worldContext                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _iOldTotalExperience                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      _playerId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FExperienceComponentData>&_outComponentsData                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UExperienceComponentBase::BPE_ComputeComponentData(const class UObject* _worldContext, int32 _iOldTotalExperience, const class FName& _playerId, TArray<struct FExperienceComponentData>& _outComponentsData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExperienceComponentBase", "BPE_ComputeComponentData");

	Params::ExperienceComponentBase_BPE_ComputeComponentData Parms{};

	Parms._worldContext = _worldContext;
	Parms._iOldTotalExperience = _iOldTotalExperience;
	Parms._playerId = _playerId;
	Parms._outComponentsData = std::move(_outComponentsData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	_outComponentsData = std::move(Parms._outComponentsData);
}


// Function Runtime.AbilityOwnerSelector.OnOverlapBegin
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              _overlappedComp                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           _otherActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              _otherComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _otherBodyIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bFromSweep                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                _sweepResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbilityOwnerSelector::OnOverlapBegin(class UPrimitiveComponent* _overlappedComp, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _otherBodyIndex, bool _bFromSweep, const struct FHitResult& _sweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOwnerSelector", "OnOverlapBegin");

	Params::AbilityOwnerSelector_OnOverlapBegin Parms{};

	Parms._overlappedComp = _overlappedComp;
	Parms._otherActor = _otherActor;
	Parms._otherComp = _otherComp;
	Parms._otherBodyIndex = _otherBodyIndex;
	Parms._bFromSweep = _bFromSweep;
	Parms._sweepResult = std::move(_sweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityOwnerSelector.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              _overlappedComp                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           _otherActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              _otherComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _otherBodyIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOwnerSelector::OnOverlapEnd(class UPrimitiveComponent* _overlappedComp, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _otherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOwnerSelector", "OnOverlapEnd");

	Params::AbilityOwnerSelector_OnOverlapEnd Parms{};

	Parms._overlappedComp = _overlappedComp;
	Parms._otherActor = _otherActor;
	Parms._otherComp = _otherComp;
	Parms._otherBodyIndex = _otherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_ApplyAbilityCostOverTime.BPF_ApplyAbilityCostOverTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USCGameplayAbility*               _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      _effect                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fPeriodInSeconds                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_ApplyAbilityCostOverTime*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_ApplyAbilityCostOverTime* UAbilityTask_ApplyAbilityCostOverTime::BPF_ApplyAbilityCostOverTime(class USCGameplayAbility* _owningAbility, TSubclassOf<class UGameplayEffect> _effect, float _fPeriodInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_ApplyAbilityCostOverTime", "BPF_ApplyAbilityCostOverTime");

	Params::AbilityTask_ApplyAbilityCostOverTime_BPF_ApplyAbilityCostOverTime Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._effect = _effect;
	Parms._fPeriodInSeconds = _fPeriodInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_ApplyAbilityCostOverTime.BPF_SetCheckCommitAbilityCostConditionDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       _delegate                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_ApplyAbilityCostOverTime::BPF_SetCheckCommitAbilityCostConditionDelegate(TDelegate<void()> _delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_ApplyAbilityCostOverTime", "BPF_SetCheckCommitAbilityCostConditionDelegate");

	Params::AbilityTask_ApplyAbilityCostOverTime_BPF_SetCheckCommitAbilityCostConditionDelegate Parms{};

	Parms._delegate = _delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Goal.BPE_GetCollision
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class USceneComponent**                 _outCollision                                          (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGoal::BPE_GetCollision(class USceneComponent** _outCollision) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Goal", "BPE_GetCollision");

	Params::Goal_BPE_GetCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (_outCollision != nullptr)
		*_outCollision = Parms._outCollision;
}


// Function Runtime.Goal.BPF_IsPointInGoal
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   _vPoint                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bUseGoalExtraSize                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGoal::BPF_IsPointInGoal(const struct FVector& _vPoint, bool _bUseGoalExtraSize) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Goal", "BPF_IsPointInGoal");

	Params::Goal_BPF_IsPointInGoal Parms{};

	Parms._vPoint = std::move(_vPoint);
	Parms._bUseGoalExtraSize = _bUseGoalExtraSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_ApplyShoot.BPF_ApplyShootTask
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FShootParams&              _shootParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 _instigatorAbility                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bAttachedToPlayer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_ApplyShoot*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_ApplyShoot* UAbilityTask_ApplyShoot::BPF_ApplyShootTask(const struct FShootParams& _shootParams, class UGameplayAbility* _instigatorAbility, class ABall* _ball, bool _bAttachedToPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_ApplyShoot", "BPF_ApplyShootTask");

	Params::AbilityTask_ApplyShoot_BPF_ApplyShootTask Parms{};

	Parms._shootParams = std::move(_shootParams);
	Parms._instigatorAbility = _instigatorAbility;
	Parms._ball = _ball;
	Parms._bAttachedToPlayer = _bAttachedToPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_ApplyShoot.OnShoot
// (Final, Native, Protected)
// Parameters:
// const class ABall*                      _ball                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootParams&              _shootParams                                           (Parm, NativeAccessSpecifierPublic)

void UAbilityTask_ApplyShoot::OnShoot(const class ABall* _ball, const struct FShootParams& _shootParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_ApplyShoot", "OnShoot");

	Params::AbilityTask_ApplyShoot_OnShoot Parms{};

	Parms._ball = _ball;
	Parms._shootParams = std::move(_shootParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_ApplyShoot.OnTrajectoryCleared
// (Final, Native, Protected)

void UAbilityTask_ApplyShoot::OnTrajectoryCleared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_ApplyShoot", "OnTrajectoryCleared");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_ApplyShoot.OnTrajectoryUpdated
// (Final, Native, Protected)
// Parameters:
// const class ABall*                      _ball                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootParams&              _shootParams                                           (Parm, NativeAccessSpecifierPublic)

void UAbilityTask_ApplyShoot::OnTrajectoryUpdated(const class ABall* _ball, const struct FShootParams& _shootParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_ApplyShoot", "OnTrajectoryUpdated");

	Params::AbilityTask_ApplyShoot_OnTrajectoryUpdated Parms{};

	Parms._ball = _ball;
	Parms._shootParams = std::move(_shootParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_ApplyVolleyShoot.BPF_ApplyVolleyShootTask
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FShootParams&              _shootParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 _instigatorAbility                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_BallInteractionRequest*_ballInteractionRequestTask                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bAttachedToPlayer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_ApplyVolleyShoot*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_ApplyVolleyShoot* UAbilityTask_ApplyVolleyShoot::BPF_ApplyVolleyShootTask(const struct FShootParams& _shootParams, class UGameplayAbility* _instigatorAbility, class ABall* _ball, class UAbilityTask_BallInteractionRequest* _ballInteractionRequestTask, bool _bAttachedToPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_ApplyVolleyShoot", "BPF_ApplyVolleyShootTask");

	Params::AbilityTask_ApplyVolleyShoot_BPF_ApplyVolleyShootTask Parms{};

	Parms._shootParams = std::move(_shootParams);
	Parms._instigatorAbility = _instigatorAbility;
	Parms._ball = _ball;
	Parms._ballInteractionRequestTask = _ballInteractionRequestTask;
	Parms._bAttachedToPlayer = _bAttachedToPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallStealBinder.OnBallStolen
// (Final, Native, Protected)
// Parameters:
// class ARuntimePlayerState*              _playerStateThief                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimePlayerState*              _playerStateStolen                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallStealBinder::OnBallStolen(class ARuntimePlayerState* _playerStateThief, class ARuntimePlayerState* _playerStateStolen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallStealBinder", "OnBallStolen");

	Params::BallStealBinder_OnBallStolen Parms{};

	Parms._playerStateThief = _playerStateThief;
	Parms._playerStateStolen = _playerStateStolen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_BallInteractionRequest.BPF_BallInteractionRequest
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBallInteractionRequestType             _eType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_context                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _gameplayTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_BallInteractionRequest*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_BallInteractionRequest* UAbilityTask_BallInteractionRequest::BPF_BallInteractionRequest(class UGameplayAbility* _owningAbility, EBallInteractionRequestType _eType, const struct FGameplayAbilityTargetDataHandle& _context, const struct FGameplayTag& _gameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_BallInteractionRequest", "BPF_BallInteractionRequest");

	Params::AbilityTask_BallInteractionRequest_BPF_BallInteractionRequest Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._eType = _eType;
	Parms._context = std::move(_context);
	Parms._gameplayTag = std::move(_gameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_BallInteractionRequest.ServerReceiveRequest
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_data                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _activationTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_BallInteractionRequest::ServerReceiveRequest(const struct FGameplayAbilityTargetDataHandle& _data, const struct FGameplayTag& _activationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_BallInteractionRequest", "ServerReceiveRequest");

	Params::AbilityTask_BallInteractionRequest_ServerReceiveRequest Parms{};

	Parms._data = std::move(_data);
	Parms._activationTag = std::move(_activationTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_BallInteractionRequest.ClearRequest
// (Final, Native, Public, BlueprintCallable, Const)

void UAbilityTask_BallInteractionRequest::ClearRequest() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_BallInteractionRequest", "ClearRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_BallInteractionRequest.HasRequestBeenGranted
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityTask_BallInteractionRequest::HasRequestBeenGranted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_BallInteractionRequest", "HasRequestBeenGranted");

	Params::AbilityTask_BallInteractionRequest_HasRequestBeenGranted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_BallInteractionRequest.HasRequestBeenProcessed
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityTask_BallInteractionRequest::HasRequestBeenProcessed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_BallInteractionRequest", "HasRequestBeenProcessed");

	Params::AbilityTask_BallInteractionRequest_HasRequestBeenProcessed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_HandleHindering.BPF_HandleHindering
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     _instigator                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCharacterHinderingConfig*  _config                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERootMotionFinishVelocityMode           _eVelocityOnFinishMode                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   _vSetVelocityOnFinish                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fClampVelocityOnFinish                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_HandleHindering*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_HandleHindering* UAbilityTask_HandleHindering::BPF_HandleHindering(class UGameplayAbility* _owningAbility, const class AActor* _instigator, const class UCharacterHinderingConfig* _config, ERootMotionFinishVelocityMode _eVelocityOnFinishMode, const struct FVector& _vSetVelocityOnFinish, float _fClampVelocityOnFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_HandleHindering", "BPF_HandleHindering");

	Params::AbilityTask_HandleHindering_BPF_HandleHindering Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._instigator = _instigator;
	Parms._config = _config;
	Parms._eVelocityOnFinishMode = _eVelocityOnFinishMode;
	Parms._vSetVelocityOnFinish = std::move(_vSetVelocityOnFinish);
	Parms._fClampVelocityOnFinish = _fClampVelocityOnFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_HandleSteeringLocomotion.BPF_HandleSteeringLocomotion
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             _taskInstanceName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCInputAction*                   _action                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      _speedCurve                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fTrackingSpeed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      _trackingCurve                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fInputDelay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fUpdateInputFrequency                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_HandleSteeringLocomotion*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_HandleSteeringLocomotion* UAbilityTask_HandleSteeringLocomotion::BPF_HandleSteeringLocomotion(class UGameplayAbility* _owningAbility, class FName _taskInstanceName, class USCInputAction* _action, float _fSpeed, class UCurveFloat* _speedCurve, float _fTrackingSpeed, class UCurveFloat* _trackingCurve, float _fInputDelay, float _fUpdateInputFrequency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_HandleSteeringLocomotion", "BPF_HandleSteeringLocomotion");

	Params::AbilityTask_HandleSteeringLocomotion_BPF_HandleSteeringLocomotion Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._taskInstanceName = _taskInstanceName;
	Parms._action = _action;
	Parms._fSpeed = _fSpeed;
	Parms._speedCurve = _speedCurve;
	Parms._fTrackingSpeed = _fTrackingSpeed;
	Parms._trackingCurve = _trackingCurve;
	Parms._fInputDelay = _fInputDelay;
	Parms._fUpdateInputFrequency = _fUpdateInputFrequency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_MoveToCollision.BPF_MoveToCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fMaxDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fMinDistanceToRun                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       _eCollisionChannel                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_MoveToCollision*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_MoveToCollision* UAbilityTask_MoveToCollision::BPF_MoveToCollision(class UGameplayAbility* _owningAbility, float _fMaxDuration, float _fMinDistanceToRun, ECollisionChannel _eCollisionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_MoveToCollision", "BPF_MoveToCollision");

	Params::AbilityTask_MoveToCollision_BPF_MoveToCollision Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._fMaxDuration = _fMaxDuration;
	Parms._fMinDistanceToRun = _fMinDistanceToRun;
	Parms._eCollisionChannel = _eCollisionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_MoveToCollision.OnTimedOutAndDestinationReachedCallBack
// (Final, Native, Private)

void UAbilityTask_MoveToCollision::OnTimedOutAndDestinationReachedCallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_MoveToCollision", "OnTimedOutAndDestinationReachedCallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_MoveToCollision.OnTimedOutCallBack
// (Final, Native, Private)

void UAbilityTask_MoveToCollision::OnTimedOutCallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_MoveToCollision", "OnTimedOutCallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkFindBallTarget.BPF_NetworkFindBallTarget
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FOnDemandTargetProvider&   _targetProvider                                        (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FOnDemandTargetProvider&   _targetValidationProvider                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _gameplayTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bDoOnce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_NetworkFindBallTarget*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_NetworkFindBallTarget* UAbilityTask_NetworkFindBallTarget::BPF_NetworkFindBallTarget(class UGameplayAbility* _owningAbility, const struct FOnDemandTargetProvider& _targetProvider, const struct FOnDemandTargetProvider& _targetValidationProvider, const struct FGameplayTag& _gameplayTag, bool _bDoOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_NetworkFindBallTarget", "BPF_NetworkFindBallTarget");

	Params::AbilityTask_NetworkFindBallTarget_BPF_NetworkFindBallTarget Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._targetProvider = std::move(_targetProvider);
	Parms._targetValidationProvider = std::move(_targetValidationProvider);
	Parms._gameplayTag = std::move(_gameplayTag);
	Parms._bDoOnce = _bDoOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_NetworkFindBallTarget.BPF_NetworkFindBallTargetWithCancelInput
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FOnDemandTargetProvider&   _targetProvider                                        (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FOnDemandTargetProvider&   _targetValidationProvider                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _gameplayTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCInputAction*                   _inAction                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputWatchTrigger                      _eWatchTrigger                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bDoOnce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_NetworkFindBallTarget*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_NetworkFindBallTarget* UAbilityTask_NetworkFindBallTarget::BPF_NetworkFindBallTargetWithCancelInput(class UGameplayAbility* _owningAbility, const struct FOnDemandTargetProvider& _targetProvider, const struct FOnDemandTargetProvider& _targetValidationProvider, const struct FGameplayTag& _gameplayTag, class USCInputAction* _inAction, EInputWatchTrigger _eWatchTrigger, bool _bDoOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_NetworkFindBallTarget", "BPF_NetworkFindBallTargetWithCancelInput");

	Params::AbilityTask_NetworkFindBallTarget_BPF_NetworkFindBallTargetWithCancelInput Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._targetProvider = std::move(_targetProvider);
	Parms._targetValidationProvider = std::move(_targetValidationProvider);
	Parms._gameplayTag = std::move(_gameplayTag);
	Parms._inAction = _inAction;
	Parms._eWatchTrigger = _eWatchTrigger;
	Parms._bDoOnce = _bDoOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_NetworkFindBallTarget.InitCancel
// (Final, Native, Private)
// Parameters:
// class USCInputAction*                   _inAction                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputWatchTrigger                      _eWatchTrigger                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_NetworkFindBallTarget::InitCancel(class USCInputAction* _inAction, EInputWatchTrigger _eWatchTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkFindBallTarget", "InitCancel");

	Params::AbilityTask_NetworkFindBallTarget_InitCancel Parms{};

	Parms._inAction = _inAction;
	Parms._eWatchTrigger = _eWatchTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkFindBallTarget.OnAbilityTaskCancel
// (Final, Native, Private)

void UAbilityTask_NetworkFindBallTarget::OnAbilityTaskCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkFindBallTarget", "OnAbilityTaskCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkFindBallTarget.OnCancelInput
// (Final, Native, Private, HasOutParams)
// Parameters:
// const class USCInputAction*             _action                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionState&         _listenerState                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAbilityTask_NetworkFindBallTarget::OnCancelInput(const class USCInputAction* _action, const struct FInputActionState& _listenerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkFindBallTarget", "OnCancelInput");

	Params::AbilityTask_NetworkFindBallTarget_OnCancelInput Parms{};

	Parms._action = _action;
	Parms._listenerState = std::move(_listenerState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkFindBallTarget.OnServerReady
// (Final, Native, Private)

void UAbilityTask_NetworkFindBallTarget::OnServerReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkFindBallTarget", "OnServerReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkFindBallTarget.SearchTarget
// (Final, Native, Private)

void UAbilityTask_NetworkFindBallTarget::SearchTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkFindBallTarget", "SearchTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkFindBallTarget.ServerReceiveTargetData
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_data                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _activationTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_NetworkFindBallTarget::ServerReceiveTargetData(const struct FGameplayAbilityTargetDataHandle& _data, const struct FGameplayTag& _activationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkFindBallTarget", "ServerReceiveTargetData");

	Params::AbilityTask_NetworkFindBallTarget_ServerReceiveTargetData Parms{};

	Parms._data = std::move(_data);
	Parms._activationTag = std::move(_activationTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkHitProjection.BPF_NetworkHitProjection
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_context                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UTargetDatasource>    _datasource                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTargetPicker>        _picker                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _gameplayTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_HandleHitboxBase*    _handleHitboxTaskPtr                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_NetworkHitProjection*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_NetworkHitProjection* UAbilityTask_NetworkHitProjection::BPF_NetworkHitProjection(class UGameplayAbility* _owningAbility, const struct FGameplayAbilityTargetDataHandle& _context, TSubclassOf<class UTargetDatasource> _datasource, TSubclassOf<class UTargetPicker> _picker, const struct FGameplayTag& _gameplayTag, class UAbilityTask_HandleHitboxBase* _handleHitboxTaskPtr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_NetworkHitProjection", "BPF_NetworkHitProjection");

	Params::AbilityTask_NetworkHitProjection_BPF_NetworkHitProjection Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._context = std::move(_context);
	Parms._datasource = _datasource;
	Parms._picker = _picker;
	Parms._gameplayTag = std::move(_gameplayTag);
	Parms._handleHitboxTaskPtr = _handleHitboxTaskPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_NetworkHitProjection.ServerReceiveTargetData
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_data                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _activationTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_NetworkHitProjection::ServerReceiveTargetData(const struct FGameplayAbilityTargetDataHandle& _data, const struct FGameplayTag& _activationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkHitProjection", "ServerReceiveTargetData");

	Params::AbilityTask_NetworkHitProjection_ServerReceiveTargetData Parms{};

	Parms._data = std::move(_data);
	Parms._activationTag = std::move(_activationTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkHitValidation.BPF_NetworkHitValidation
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_context                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UTargetDatasource>    _datasource                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTargetPicker>        _picker                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _gameplayTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_HandleHitboxBase*    _handleHitboxTaskPtr                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_NetworkHitValidation*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_NetworkHitValidation* UAbilityTask_NetworkHitValidation::BPF_NetworkHitValidation(class UGameplayAbility* _owningAbility, const struct FGameplayAbilityTargetDataHandle& _context, TSubclassOf<class UTargetDatasource> _datasource, TSubclassOf<class UTargetPicker> _picker, const struct FGameplayTag& _gameplayTag, class UAbilityTask_HandleHitboxBase* _handleHitboxTaskPtr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_NetworkHitValidation", "BPF_NetworkHitValidation");

	Params::AbilityTask_NetworkHitValidation_BPF_NetworkHitValidation Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._context = std::move(_context);
	Parms._datasource = _datasource;
	Parms._picker = _picker;
	Parms._gameplayTag = std::move(_gameplayTag);
	Parms._handleHitboxTaskPtr = _handleHitboxTaskPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_NetworkHitValidation.ServerReceiveTargetData
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_data                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _activationTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_NetworkHitValidation::ServerReceiveTargetData(const struct FGameplayAbilityTargetDataHandle& _data, const struct FGameplayTag& _activationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkHitValidation", "ServerReceiveTargetData");

	Params::AbilityTask_NetworkHitValidation_ServerReceiveTargetData Parms{};

	Parms._data = std::move(_data);
	Parms._activationTag = std::move(_activationTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkSyncShootData.BPF_NetworkSyncShootDataWithInputs
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class USCGameplayAbility*               _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRTInputActionsForNetworkSyncShoot&_inputAction                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FShootPrepTargetData&            _inOutShootPrep                                        (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_context                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<TSubclassOf<class UTrajectoryStatus>>&_trajectoryStatus                                      (ConstParm, Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// const struct FSCConditionsToSyncEarly&  _conditionsToSyncEarly                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FRTNetworkSyncShootTimeArg&_networkSyncTimeArg                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FSCNetworkSyncData&        _syncData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _shootTypeTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_NetworkSyncShootData*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_NetworkSyncShootData* UAbilityTask_NetworkSyncShootData::BPF_NetworkSyncShootDataWithInputs(class USCGameplayAbility* _owningAbility, const struct FRTInputActionsForNetworkSyncShoot& _inputAction, struct FShootPrepTargetData& _inOutShootPrep, const struct FGameplayAbilityTargetDataHandle& _context, const TArray<TSubclassOf<class UTrajectoryStatus>>& _trajectoryStatus, const struct FSCConditionsToSyncEarly& _conditionsToSyncEarly, const struct FRTNetworkSyncShootTimeArg& _networkSyncTimeArg, const struct FSCNetworkSyncData& _syncData, const struct FGameplayTag& _shootTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_NetworkSyncShootData", "BPF_NetworkSyncShootDataWithInputs");

	Params::AbilityTask_NetworkSyncShootData_BPF_NetworkSyncShootDataWithInputs Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._inputAction = std::move(_inputAction);
	Parms._inOutShootPrep = std::move(_inOutShootPrep);
	Parms._context = std::move(_context);
	Parms._trajectoryStatus = std::move(_trajectoryStatus);
	Parms._conditionsToSyncEarly = std::move(_conditionsToSyncEarly);
	Parms._networkSyncTimeArg = std::move(_networkSyncTimeArg);
	Parms._syncData = std::move(_syncData);
	Parms._shootTypeTag = std::move(_shootTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	_inOutShootPrep = std::move(Parms._inOutShootPrep);

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_NetworkSyncShootData.BPF_GetShootParams
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FShootParams*                    _outShootParams                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UAbilityTask_NetworkSyncShootData::BPF_GetShootParams(struct FShootParams* _outShootParams) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkSyncShootData", "BPF_GetShootParams");

	Params::AbilityTask_NetworkSyncShootData_BPF_GetShootParams Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outShootParams != nullptr)
		*_outShootParams = std::move(Parms._outShootParams);
}


// Function Runtime.GoalScopedBinder.OnGoalRegistered
// (Native, Protected)
// Parameters:
// class AGoal*                            _goal                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGoalScopedBinder::OnGoalRegistered(class AGoal* _goal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GoalScopedBinder", "OnGoalRegistered");

	Params::GoalScopedBinder_OnGoalRegistered Parms{};

	Parms._goal = _goal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.GoalCrossbarHitBinder.OnGoalCrossbarHit
// (Final, Native, Protected)
// Parameters:
// class AGoal*                            _goal                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   _uiTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGoalCrossbarHitBinder::OnGoalCrossbarHit(class AGoal* _goal, uint8 _uiTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GoalCrossbarHitBinder", "OnGoalCrossbarHit");

	Params::GoalCrossbarHitBinder_OnGoalCrossbarHit Parms{};

	Parms._goal = _goal;
	Parms._uiTeam = _uiTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkSyncTargetData.BPF_NetworkSyncTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_targetData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   _fSleepDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fListenDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fLagCompensation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_NetworkSyncTargetData*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_NetworkSyncTargetData* UAbilityTask_NetworkSyncTargetData::BPF_NetworkSyncTargetData(class UGameplayAbility* _owningAbility, const struct FGameplayAbilityTargetDataHandle& _targetData, float _fSleepDuration, float _fListenDuration, float _fLagCompensation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_NetworkSyncTargetData", "BPF_NetworkSyncTargetData");

	Params::AbilityTask_NetworkSyncTargetData_BPF_NetworkSyncTargetData Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._targetData = std::move(_targetData);
	Parms._fSleepDuration = _fSleepDuration;
	Parms._fListenDuration = _fListenDuration;
	Parms._fLagCompensation = _fLagCompensation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_NetworkSyncTargetData.OnCancelledCallback
// (Final, Native, Public)

void UAbilityTask_NetworkSyncTargetData::OnCancelledCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkSyncTargetData", "OnCancelledCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkSyncTargetData.OnReplicatedCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_data                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _activationTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_NetworkSyncTargetData::OnReplicatedCallback(const struct FGameplayAbilityTargetDataHandle& _data, const struct FGameplayTag& _activationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkSyncTargetData", "OnReplicatedCallback");

	Params::AbilityTask_NetworkSyncTargetData_OnReplicatedCallback Parms{};

	Parms._data = std::move(_data);
	Parms._activationTag = std::move(_activationTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkSyncTargetData.OnSignalCallback
// (Final, Native, Public)

void UAbilityTask_NetworkSyncTargetData::OnSignalCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkSyncTargetData", "OnSignalCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkSyncTargetData.SendSignalFromServer
// (Final, Native, Public)

void UAbilityTask_NetworkSyncTargetData::SendSignalFromServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkSyncTargetData", "SendSignalFromServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkWaitTargetData.BPF_NetworkWaitTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAbilityTaskNetWaitType                 _eType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_targetData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   _fSleepDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fListenDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_NetworkWaitTargetData*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_NetworkWaitTargetData* UAbilityTask_NetworkWaitTargetData::BPF_NetworkWaitTargetData(class UGameplayAbility* _owningAbility, EAbilityTaskNetWaitType _eType, const struct FGameplayAbilityTargetDataHandle& _targetData, float _fSleepDuration, float _fListenDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_NetworkWaitTargetData", "BPF_NetworkWaitTargetData");

	Params::AbilityTask_NetworkWaitTargetData_BPF_NetworkWaitTargetData Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._eType = _eType;
	Parms._targetData = std::move(_targetData);
	Parms._fSleepDuration = _fSleepDuration;
	Parms._fListenDuration = _fListenDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_NetworkWaitTargetData.OnCancelledCallback
// (Final, Native, Public)

void UAbilityTask_NetworkWaitTargetData::OnCancelledCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkWaitTargetData", "OnCancelledCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkWaitTargetData.OnReplicatedCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_data                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _activationTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_NetworkWaitTargetData::OnReplicatedCallback(const struct FGameplayAbilityTargetDataHandle& _data, const struct FGameplayTag& _activationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkWaitTargetData", "OnReplicatedCallback");

	Params::AbilityTask_NetworkWaitTargetData_OnReplicatedCallback Parms{};

	Parms._data = std::move(_data);
	Parms._activationTag = std::move(_activationTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_NetworkWaitTargetData.OnSignalCallback
// (Final, Native, Public)

void UAbilityTask_NetworkWaitTargetData::OnSignalCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_NetworkWaitTargetData", "OnSignalCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeGameFlowState.GetMatchStateArray
// (Final, Native, Static, Public)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> URuntimeGameFlowState::GetMatchStateArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeGameFlowState", "GetMatchStateArray");

	Params::RuntimeGameFlowState_GetMatchStateArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeGameFlowState.BPF_ResetBallsAndCharacters
// (Final, Native, Protected, BlueprintCallable)

void URuntimeGameFlowState::BPF_ResetBallsAndCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameFlowState", "BPF_ResetBallsAndCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.LevelSequenceFlowState.OnLevelSequenceFinished
// (Final, Native, Public)

void ULevelSequenceFlowState::OnLevelSequenceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelSequenceFlowState", "OnLevelSequenceFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.LevelSequenceFlowState.OnLevelSequencePlay
// (Native, Public)

void ULevelSequenceFlowState::OnLevelSequencePlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelSequenceFlowState", "OnLevelSequencePlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.LevelSequenceFlowState.PlayLevelSequenceOnClient
// (Final, Native, Private)

void ULevelSequenceFlowState::PlayLevelSequenceOnClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelSequenceFlowState", "PlayLevelSequenceOnClient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_PlayMontageFromAestheticMontage.BPF_PlayMontageFromAestheticMontage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USCGameplayAbility*               _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_PlaySimulatedAestheticMontage*_aestheticMontageTask                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAbilityExecOrigin                      _eIn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAbilityExecOutputWithValidation*       _eOut                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             _taskInstanceName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fFallbackStartTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimSequencePicker>  _fallbackPicker                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             _fallbackSlotName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBasicMontagePlayerConfiguration* _overrideConfiguration                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bLog                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bStopWhenAbilityEnds                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_playerContext                                         (Parm, NativeAccessSpecifierPublic)
// class FName                             _StartSection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_PlayMontageFromAestheticMontage*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_PlayMontageFromAestheticMontage* UAbilityTask_PlayMontageFromAestheticMontage::BPF_PlayMontageFromAestheticMontage(class USCGameplayAbility* _owningAbility, class UAbilityTask_PlaySimulatedAestheticMontage* _aestheticMontageTask, EAbilityExecOrigin _eIn, EAbilityExecOutputWithValidation* _eOut, class FName _taskInstanceName, float _fFallbackStartTime, TSubclassOf<class UAnimSequencePicker> _fallbackPicker, class FName _fallbackSlotName, class UBasicMontagePlayerConfiguration* _overrideConfiguration, bool _bLog, bool _bStopWhenAbilityEnds, const struct FGameplayAbilityTargetDataHandle& _playerContext, class FName _StartSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_PlayMontageFromAestheticMontage", "BPF_PlayMontageFromAestheticMontage");

	Params::AbilityTask_PlayMontageFromAestheticMontage_BPF_PlayMontageFromAestheticMontage Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._aestheticMontageTask = _aestheticMontageTask;
	Parms._eIn = _eIn;
	Parms._taskInstanceName = _taskInstanceName;
	Parms._fFallbackStartTime = _fFallbackStartTime;
	Parms._fallbackPicker = _fallbackPicker;
	Parms._fallbackSlotName = _fallbackSlotName;
	Parms._overrideConfiguration = _overrideConfiguration;
	Parms._bLog = _bLog;
	Parms._bStopWhenAbilityEnds = _bStopWhenAbilityEnds;
	Parms._playerContext = std::move(_playerContext);
	Parms._StartSection = _StartSection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_eOut != nullptr)
		*_eOut = Parms._eOut;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_PlaySimulatedAestheticMontage.BPF_PlaySimulatedAstheticMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     _montage                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bMirror                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             _newSlotTrack                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fBlendOutAnimTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_PlaySimulatedAestheticMontage*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_PlaySimulatedAestheticMontage* UAbilityTask_PlaySimulatedAestheticMontage::BPF_PlaySimulatedAstheticMontage(class UGameplayAbility* _owningAbility, class UAnimMontage* _montage, bool _bMirror, class FName _newSlotTrack, float _fPlayRate, float _fBlendOutAnimTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_PlaySimulatedAestheticMontage", "BPF_PlaySimulatedAstheticMontage");

	Params::AbilityTask_PlaySimulatedAestheticMontage_BPF_PlaySimulatedAstheticMontage Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._montage = _montage;
	Parms._bMirror = _bMirror;
	Parms._newSlotTrack = _newSlotTrack;
	Parms._fPlayRate = _fPlayRate;
	Parms._fBlendOutAnimTime = _fBlendOutAnimTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_PlaySimulatedAestheticMontage.BPF_PlaySimulatedTimedAstheticMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     _montage                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bMirror                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             _newSlotTrack                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fWorldSyncTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fAnimSyncTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fBlendOutAnimTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_PlaySimulatedAestheticMontage*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_PlaySimulatedAestheticMontage* UAbilityTask_PlaySimulatedAestheticMontage::BPF_PlaySimulatedTimedAstheticMontage(class UGameplayAbility* _owningAbility, class UAnimMontage* _montage, bool _bMirror, class FName _newSlotTrack, float _fWorldSyncTime, float _fAnimSyncTime, float _fBlendOutAnimTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_PlaySimulatedAestheticMontage", "BPF_PlaySimulatedTimedAstheticMontage");

	Params::AbilityTask_PlaySimulatedAestheticMontage_BPF_PlaySimulatedTimedAstheticMontage Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._montage = _montage;
	Parms._bMirror = _bMirror;
	Parms._newSlotTrack = _newSlotTrack;
	Parms._fWorldSyncTime = _fWorldSyncTime;
	Parms._fAnimSyncTime = _fAnimSyncTime;
	Parms._fBlendOutAnimTime = _fBlendOutAnimTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_PlaySimulatedAestheticMontage.OnAnyMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     _montage                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_PlaySimulatedAestheticMontage::OnAnyMontageBlendingOut(class UAnimMontage* _montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_PlaySimulatedAestheticMontage", "OnAnyMontageBlendingOut");

	Params::AbilityTask_PlaySimulatedAestheticMontage_OnAnyMontageBlendingOut Parms{};

	Parms._montage = _montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_PlaySimulatedAestheticMontage.OnAnyMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     _montage                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bInterrupted                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_PlaySimulatedAestheticMontage::OnAnyMontageEnded(class UAnimMontage* _montage, bool _bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_PlaySimulatedAestheticMontage", "OnAnyMontageEnded");

	Params::AbilityTask_PlaySimulatedAestheticMontage_OnAnyMontageEnded Parms{};

	Parms._montage = _montage;
	Parms._bInterrupted = _bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_PlaySimulatedAestheticMontage.GetMontageInstancePosition
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAbilityTask_PlaySimulatedAestheticMontage::GetMontageInstancePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_PlaySimulatedAestheticMontage", "GetMontageInstancePosition");

	Params::AbilityTask_PlaySimulatedAestheticMontage_GetMontageInstancePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_PlaySyncMontageBase.BPF_CancelBlendOutDuration
// (Final, Native, Public, BlueprintCallable)

void UAbilityTask_PlaySyncMontageBase::BPF_CancelBlendOutDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_PlaySyncMontageBase", "BPF_CancelBlendOutDuration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_PlaySyncMontageBase.OnAnyMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     _montage                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_PlaySyncMontageBase::OnAnyMontageBlendingOut(class UAnimMontage* _montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_PlaySyncMontageBase", "OnAnyMontageBlendingOut");

	Params::AbilityTask_PlaySyncMontageBase_OnAnyMontageBlendingOut Parms{};

	Parms._montage = _montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_PlaySyncMontageBase.OnAnyMontageStarting
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     _montage                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_PlaySyncMontageBase::OnAnyMontageStarting(class UAnimMontage* _montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_PlaySyncMontageBase", "OnAnyMontageStarting");

	Params::AbilityTask_PlaySyncMontageBase_OnAnyMontageStarting Parms{};

	Parms._montage = _montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_PlaySyncAestheticMontage.BPF_PlayAbilitySyncAestheticMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     _followerMontage                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bFollowerMirror                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fPlayMontageAtWorldTime                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fEndMontageAtWorldTime                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             _newSlotTrack                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fBlendInDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fLongBlendOutDuration                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_PlaySyncAestheticMontage*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_PlaySyncAestheticMontage* UAbilityTask_PlaySyncAestheticMontage::BPF_PlayAbilitySyncAestheticMontage(class UGameplayAbility* _owningAbility, class UAnimMontage* _followerMontage, bool _bFollowerMirror, float _fPlayMontageAtWorldTime, float _fEndMontageAtWorldTime, class FName _newSlotTrack, float _fBlendInDuration, float _fLongBlendOutDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_PlaySyncAestheticMontage", "BPF_PlayAbilitySyncAestheticMontage");

	Params::AbilityTask_PlaySyncAestheticMontage_BPF_PlayAbilitySyncAestheticMontage Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._followerMontage = _followerMontage;
	Parms._bFollowerMirror = _bFollowerMirror;
	Parms._fPlayMontageAtWorldTime = _fPlayMontageAtWorldTime;
	Parms._fEndMontageAtWorldTime = _fEndMontageAtWorldTime;
	Parms._newSlotTrack = _newSlotTrack;
	Parms._fBlendInDuration = _fBlendInDuration;
	Parms._fLongBlendOutDuration = _fLongBlendOutDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_PlaySyncAestheticMontage.BPF_PlaySyncAestheticMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     _masterMontage                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bMasterMirror                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     _followerMontage                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bFollowerMirror                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fPlayMontageAtWorldTime                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fEndMontageAtWorldTime                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             _newSlotTrack                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fBlendInDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fLongBlendOutDuration                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_PlaySyncAestheticMontage*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_PlaySyncAestheticMontage* UAbilityTask_PlaySyncAestheticMontage::BPF_PlaySyncAestheticMontage(class UGameplayAbility* _owningAbility, class UAnimMontage* _masterMontage, bool _bMasterMirror, class UAnimMontage* _followerMontage, bool _bFollowerMirror, float _fPlayMontageAtWorldTime, float _fEndMontageAtWorldTime, class FName _newSlotTrack, float _fBlendInDuration, float _fLongBlendOutDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_PlaySyncAestheticMontage", "BPF_PlaySyncAestheticMontage");

	Params::AbilityTask_PlaySyncAestheticMontage_BPF_PlaySyncAestheticMontage Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._masterMontage = _masterMontage;
	Parms._bMasterMirror = _bMasterMirror;
	Parms._followerMontage = _followerMontage;
	Parms._bFollowerMirror = _bFollowerMirror;
	Parms._fPlayMontageAtWorldTime = _fPlayMontageAtWorldTime;
	Parms._fEndMontageAtWorldTime = _fEndMontageAtWorldTime;
	Parms._newSlotTrack = _newSlotTrack;
	Parms._fBlendInDuration = _fBlendInDuration;
	Parms._fLongBlendOutDuration = _fLongBlendOutDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShopItemSorter.BPE_Compare
// (Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FShopItem&                 _first                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FShopItem&                 _second                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ESortResult                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESortResult UShopItemSorter::BPE_Compare(const struct FShopItem& _first, const struct FShopItem& _second) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopItemSorter", "BPE_Compare");

	Params::ShopItemSorter_BPE_Compare Parms{};

	Parms._first = std::move(_first);
	Parms._second = std::move(_second);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.HUD_NameTagManagerWidget.BPF_SortNameTagArrayByDistanceFromTarget
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           _target                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUD_NameTagManagerWidget::BPF_SortNameTagArrayByDistanceFromTarget(class AActor* _target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUD_NameTagManagerWidget", "BPF_SortNameTagArrayByDistanceFromTarget");

	Params::HUD_NameTagManagerWidget_BPF_SortNameTagArrayByDistanceFromTarget Parms{};

	Parms._target = _target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallCaptureCondition.BPF_PredictCapture
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ARuntimeCharacter*          _character                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle*_outResult                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallCaptureCondition::BPF_PredictCapture(const class ARuntimeCharacter* _character, class ABall* _ball, struct FGameplayAbilityTargetDataHandle* _outResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallCaptureCondition", "BPF_PredictCapture");

	Params::BallCaptureCondition_BPF_PredictCapture Parms{};

	Parms._character = _character;
	Parms._ball = _ball;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outResult != nullptr)
		*_outResult = std::move(Parms._outResult);

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_PredictBallCapture.BPF_PredictBallCapture
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagQuery&         _tagCondition                                          (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class UBallCaptureCondition>_condition                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_PredictBallCapture*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_PredictBallCapture* UAbilityTask_PredictBallCapture::BPF_PredictBallCapture(class UGameplayAbility* _owningAbility, const struct FGameplayTagQuery& _tagCondition, TSubclassOf<class UBallCaptureCondition> _condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_PredictBallCapture", "BPF_PredictBallCapture");

	Params::AbilityTask_PredictBallCapture_BPF_PredictBallCapture Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._tagCondition = std::move(_tagCondition);
	Parms._condition = _condition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_BallCapture.BPF_CaptureBall
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UBallCaptureCondition>_condition                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_BallCapture*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_BallCapture* UAbilityTask_BallCapture::BPF_CaptureBall(class UGameplayAbility* _owningAbility, TSubclassOf<class UBallCaptureCondition> _condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_BallCapture", "BPF_CaptureBall");

	Params::AbilityTask_BallCapture_BPF_CaptureBall Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._condition = _condition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_TagsPerMovementMode.BPF_TagsPerMovementMode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<EMovementMode, TSubclassOf<class UTagAvailabilityLayerContainer>>&_tagsPerMovementMode                                   (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// class UAbilityTask_TagsPerMovementMode* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_TagsPerMovementMode* UAbilityTask_TagsPerMovementMode::BPF_TagsPerMovementMode(class UGameplayAbility* _owningAbility, const TMap<EMovementMode, TSubclassOf<class UTagAvailabilityLayerContainer>>& _tagsPerMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_TagsPerMovementMode", "BPF_TagsPerMovementMode");

	Params::AbilityTask_TagsPerMovementMode_BPF_TagsPerMovementMode Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._tagsPerMovementMode = std::move(_tagsPerMovementMode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_TagsPerMovementMode.OnMovementModeChanged
// (Final, Native, Public)
// Parameters:
// class ACharacter*                       _inCharacter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           _ePrevMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   _uiPreviousCustomMode                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_TagsPerMovementMode::OnMovementModeChanged(class ACharacter* _inCharacter, EMovementMode _ePrevMovementMode, uint8 _uiPreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_TagsPerMovementMode", "OnMovementModeChanged");

	Params::AbilityTask_TagsPerMovementMode_OnMovementModeChanged Parms{};

	Parms._inCharacter = _inCharacter;
	Parms._ePrevMovementMode = _ePrevMovementMode;
	Parms._uiPreviousCustomMode = _uiPreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_WaitForBoolean.BPF_WaitForBoolean
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool&                                   _bConditionToCheck                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bExecuteImmediatlyIfTrue                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitForBoolean*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitForBoolean* UAbilityTask_WaitForBoolean::BPF_WaitForBoolean(class UGameplayAbility* _owningAbility, bool& _bConditionToCheck, bool _bExecuteImmediatlyIfTrue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitForBoolean", "BPF_WaitForBoolean");

	Params::AbilityTask_WaitForBoolean_BPF_WaitForBoolean Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._bConditionToCheck = _bConditionToCheck;
	Parms._bExecuteImmediatlyIfTrue = _bExecuteImmediatlyIfTrue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	_bConditionToCheck = Parms._bConditionToCheck;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_WaitForComponentOverlap.BPF_WaitForOverlapOnComponent
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              _component                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitForComponentOverlap*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitForComponentOverlap* UAbilityTask_WaitForComponentOverlap::BPF_WaitForOverlapOnComponent(class UGameplayAbility* _owningAbility, class UPrimitiveComponent* _component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitForComponentOverlap", "BPF_WaitForOverlapOnComponent");

	Params::AbilityTask_WaitForComponentOverlap_BPF_WaitForOverlapOnComponent Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._component = _component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_WaitForComponentOverlap.OnHitCallback
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              _overlappedComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           _otherActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              _otherComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _iOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bFromSweep                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                _sweepResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbilityTask_WaitForComponentOverlap::OnHitCallback(class UPrimitiveComponent* _overlappedComponent, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _iOtherBodyIndex, bool _bFromSweep, const struct FHitResult& _sweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_WaitForComponentOverlap", "OnHitCallback");

	Params::AbilityTask_WaitForComponentOverlap_OnHitCallback Parms{};

	Parms._overlappedComponent = _overlappedComponent;
	Parms._otherActor = _otherActor;
	Parms._otherComp = _otherComp;
	Parms._iOtherBodyIndex = _iOtherBodyIndex;
	Parms._bFromSweep = _bFromSweep;
	Parms._sweepResult = std::move(_sweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.AbilityTask_WaitForCondition.BPF_WaitForCondition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       _conditionToCheck                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bExecuteImmediatlyIfTrue                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitForCondition*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitForCondition* UAbilityTask_WaitForCondition::BPF_WaitForCondition(class UGameplayAbility* _owningAbility, TDelegate<void()> _conditionToCheck, bool _bExecuteImmediatlyIfTrue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitForCondition", "BPF_WaitForCondition");

	Params::AbilityTask_WaitForCondition_BPF_WaitForCondition Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._conditionToCheck = _conditionToCheck;
	Parms._bExecuteImmediatlyIfTrue = _bExecuteImmediatlyIfTrue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_WaitTagContainerAdded.BPF_GT_WaitGameplayTagContainerAdded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>_taskOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     _tagContainer                                          (Parm, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitTagContainerAdded*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitTagContainerAdded* UAbilityTask_WaitTagContainerAdded::BPF_GT_WaitGameplayTagContainerAdded(TScriptInterface<class IGameplayTaskOwnerInterface> _taskOwner, const struct FGameplayTagContainer& _tagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitTagContainerAdded", "BPF_GT_WaitGameplayTagContainerAdded");

	Params::AbilityTask_WaitTagContainerAdded_BPF_GT_WaitGameplayTagContainerAdded Parms{};

	Parms._taskOwner = _taskOwner;
	Parms._tagContainer = std::move(_tagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.AbilityTask_WaitTagContainerAdded.BPF_WaitGameplayTagContainerAdded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     _tagContainer                                          (Parm, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitTagContainerAdded*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitTagContainerAdded* UAbilityTask_WaitTagContainerAdded::BPF_WaitGameplayTagContainerAdded(class UGameplayAbility* _owningAbility, const struct FGameplayTagContainer& _tagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitTagContainerAdded", "BPF_WaitGameplayTagContainerAdded");

	Params::AbilityTask_WaitTagContainerAdded_BPF_WaitGameplayTagContainerAdded Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._tagContainer = std::move(_tagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchCountdownStartBinder.OnMatchCountdownStart
// (Final, Native, Protected)
// Parameters:
// class ARuntimeMatchGameState*           _matchGameState                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchCountdownStartBinder::OnMatchCountdownStart(class ARuntimeMatchGameState* _matchGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchCountdownStartBinder", "OnMatchCountdownStart");

	Params::MatchCountdownStartBinder_OnMatchCountdownStart Parms{};

	Parms._matchGameState = _matchGameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ActionCommandsManager.BPE_GetMoveToAction
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   _vector                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESCCharacterSpeedState                  _aiSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActionCommand*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActionCommand* AActionCommandsManager::BPE_GetMoveToAction(const struct FVector& _vector, ESCCharacterSpeedState _aiSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionCommandsManager", "BPE_GetMoveToAction");

	Params::ActionCommandsManager_BPE_GetMoveToAction Parms{};

	Parms._vector = std::move(_vector);
	Parms._aiSpeed = _aiSpeed;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Runtime.ActionCommandsManager.BPF_RestartBehavior
// (Final, Native, Public, BlueprintCallable)

void AActionCommandsManager::BPF_RestartBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionCommandsManager", "BPF_RestartBehavior");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ActionCommandsManager.BPF_StartBehavior
// (Final, Native, Public, BlueprintCallable)

void AActionCommandsManager::BPF_StartBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionCommandsManager", "BPF_StartBehavior");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ActionCommandsManager.OnActionSucceded
// (Final, Native, Public)

void AActionCommandsManager::OnActionSucceded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionCommandsManager", "OnActionSucceded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ActionCommandsManager.UpdateHelpers
// (Final, Native, Public)

void AActionCommandsManager::UpdateHelpers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionCommandsManager", "UpdateHelpers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ActionCommandsStep.BPE_UpdateStepHelpers
// (Event, Public, BlueprintEvent)

void AActionCommandsStep::BPE_UpdateStepHelpers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionCommandsStep", "BPE_UpdateStepHelpers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.ActionDirectionComputation.BPE_Deinitialize
// (Event, Protected, BlueprintEvent)

void UActionDirectionComputation::BPE_Deinitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionDirectionComputation", "BPE_Deinitialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.ActionDirectionComputation.BPE_Initialize
// (Event, Protected, BlueprintEvent)

void UActionDirectionComputation::BPE_Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionDirectionComputation", "BPE_Initialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.ActionDirectionComputation.BPE_OnPossessionChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_targetData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionDirectionComputation::BPE_OnPossessionChanged(const struct FGameplayAbilityTargetDataHandle& _targetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionDirectionComputation", "BPE_OnPossessionChanged");

	Params::ActionDirectionComputation_BPE_OnPossessionChanged Parms{};

	Parms._targetData = std::move(_targetData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.ActionDirectionComputation.BPE_OnSprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_targetData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionDirectionComputation::BPE_OnSprint(const struct FGameplayAbilityTargetDataHandle& _targetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionDirectionComputation", "BPE_OnSprint");

	Params::ActionDirectionComputation_BPE_OnSprint Parms{};

	Parms._targetData = std::move(_targetData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.ActionDirectionComputation.BPE_Tick
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   _fDt                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionDirectionComputation::BPE_Tick(float _fDt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionDirectionComputation", "BPE_Tick");

	Params::ActionDirectionComputation_BPE_Tick Parms{};

	Parms._fDt = _fDt;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.ActionDirectionComputation.BPF_GetValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionDirectionComputation::BPF_GetValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionDirectionComputation", "BPF_GetValue");

	Params::ActionDirectionComputation_BPF_GetValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.LockerRoomPrematchStateViewModel.BPF_GetSelectedPalette
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FColorPalette                    ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColorPalette ULockerRoomPrematchStateViewModel::BPF_GetSelectedPalette() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerRoomPrematchStateViewModel", "BPF_GetSelectedPalette");

	Params::LockerRoomPrematchStateViewModel_BPF_GetSelectedPalette Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchingBoneDiveAnimWeightEvaluation.IsMatchingSectionNotifyState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class USection_NotifyState*       _notifyState                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchingBoneDiveAnimWeightEvaluation::IsMatchingSectionNotifyState(const class USection_NotifyState* _notifyState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchingBoneDiveAnimWeightEvaluation", "IsMatchingSectionNotifyState");

	Params::MatchingBoneDiveAnimWeightEvaluation_IsMatchingSectionNotifyState Parms{};

	Parms._notifyState = _notifyState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchEffectAction.BPE_DoProcess
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const TArray<TSoftObjectPtr<class UMatchEffectEmitterComponent>>&_emitters                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void UMatchEffectAction::BPE_DoProcess(const TArray<TSoftObjectPtr<class UMatchEffectEmitterComponent>>& _emitters) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchEffectAction", "BPE_DoProcess");

	Params::MatchEffectAction_BPE_DoProcess Parms{};

	Parms._emitters = std::move(_emitters);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.Ball.BPF_ResetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    _bApplyPhysics                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABall::BPF_ResetState(bool _bApplyPhysics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ball", "BPF_ResetState");

	Params::Ball_BPF_ResetState Parms{};

	Parms._bApplyPhysics = _bApplyPhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Ball.BPF_ResetStateAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   _vLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bApplyPhysics                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABall::BPF_ResetStateAtLocation(const struct FVector& _vLocation, bool _bApplyPhysics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ball", "BPF_ResetStateAtLocation");

	Params::Ball_BPF_ResetStateAtLocation Parms{};

	Parms._vLocation = std::move(_vLocation);
	Parms._bApplyPhysics = _bApplyPhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Ball.OnResetPreviousOwner
// (Final, Native, Public)

void ABall::OnResetPreviousOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ball", "OnResetPreviousOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Ball.BPF_GetBallRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABall::BPF_GetBallRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Ball", "BPF_GetBallRadius");

	Params::Ball_BPF_GetBallRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeLevelSequenceActor.OnLocalCharacterCustomizationChange
// (Final, Native, Protected)
// Parameters:
// class UCharacterCustomizationComponent* _characterCustomizationComponent                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bWasCharacterGenerated                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeLevelSequenceActor::OnLocalCharacterCustomizationChange(class UCharacterCustomizationComponent* _characterCustomizationComponent, bool _bWasCharacterGenerated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeLevelSequenceActor", "OnLocalCharacterCustomizationChange");

	Params::RuntimeLevelSequenceActor_OnLocalCharacterCustomizationChange Parms{};

	Parms._characterCustomizationComponent = _characterCustomizationComponent;
	Parms._bWasCharacterGenerated = _bWasCharacterGenerated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallAttributeSet.OnRep_DragForce
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldDragForce                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBallAttributeSet::OnRep_DragForce(const struct FGameplayAttributeData& _oldDragForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallAttributeSet", "OnRep_DragForce");

	Params::BallAttributeSet_OnRep_DragForce Parms{};

	Parms._oldDragForce = std::move(_oldDragForce);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallAttributeSet.OnRep_Friction
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldFriction                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBallAttributeSet::OnRep_Friction(const struct FGameplayAttributeData& _oldFriction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallAttributeSet", "OnRep_Friction");

	Params::BallAttributeSet_OnRep_Friction Parms{};

	Parms._oldFriction = std::move(_oldFriction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallAttributeSet.OnRep_MagnusBounciness
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldMagnusBounciness                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBallAttributeSet::OnRep_MagnusBounciness(const struct FGameplayAttributeData& _oldMagnusBounciness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallAttributeSet", "OnRep_MagnusBounciness");

	Params::BallAttributeSet_OnRep_MagnusBounciness Parms{};

	Parms._oldMagnusBounciness = std::move(_oldMagnusBounciness);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallAttributeSet.OnRep_Mass
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldMass                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBallAttributeSet::OnRep_Mass(const struct FGameplayAttributeData& _oldMass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallAttributeSet", "OnRep_Mass");

	Params::BallAttributeSet_OnRep_Mass Parms{};

	Parms._oldMass = std::move(_oldMass);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallAttributeSet.OnRep_MaxSpeed
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldMaxSpeed                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBallAttributeSet::OnRep_MaxSpeed(const struct FGameplayAttributeData& _oldMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallAttributeSet", "OnRep_MaxSpeed");

	Params::BallAttributeSet_OnRep_MaxSpeed Parms{};

	Parms._oldMaxSpeed = std::move(_oldMaxSpeed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallAttributeSet.OnRep_ParallelBounciness
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldParallelBounciness                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBallAttributeSet::OnRep_ParallelBounciness(const struct FGameplayAttributeData& _oldParallelBounciness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallAttributeSet", "OnRep_ParallelBounciness");

	Params::BallAttributeSet_OnRep_ParallelBounciness Parms{};

	Parms._oldParallelBounciness = std::move(_oldParallelBounciness);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallAttributeSet.OnRep_PerpendicularBounciness
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldPerpendicularBounciness                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBallAttributeSet::OnRep_PerpendicularBounciness(const struct FGameplayAttributeData& _oldPerpendicularBounciness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallAttributeSet", "OnRep_PerpendicularBounciness");

	Params::BallAttributeSet_OnRep_PerpendicularBounciness Parms{};

	Parms._oldPerpendicularBounciness = std::move(_oldPerpendicularBounciness);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallScopedBinder.BPE_OnBallRegistered
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallScopedBinder::BPE_OnBallRegistered(class ABall* _ball)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallScopedBinder", "BPE_OnBallRegistered");

	Params::BallScopedBinder_BPE_OnBallRegistered Parms{};

	Parms._ball = _ball;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallScopedBinder.OnBallRegistered
// (Native, Protected)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallScopedBinder::OnBallRegistered(class ABall* _ball)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallScopedBinder", "OnBallRegistered");

	Params::BallScopedBinder_OnBallRegistered Parms{};

	Parms._ball = _ball;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallScopedBinder.BPF_GetBall
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   _iIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABall*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABall* UBallScopedBinder::BPF_GetBall(int32 _iIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallScopedBinder", "BPF_GetBall");

	Params::BallScopedBinder_BPF_GetBall Parms{};

	Parms._iIndex = _iIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchEffectEmitterComponent.BPF_GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchEffectEmitterComponent::BPF_GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchEffectEmitterComponent", "BPF_GetTeam");

	Params::MatchEffectEmitterComponent_BPF_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallEngagedBinder.OnBallEngaged
// (Final, Native, Protected)
// Parameters:
// class ARuntimePlayerState*              _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallEngagedBinder::OnBallEngaged(class ARuntimePlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallEngagedBinder", "OnBallEngaged");

	Params::BallEngagedBinder_OnBallEngaged Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MoveAlongSplineComponent.BPF_SetLocationOnPath
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   _fDistanceOnPath                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoveAlongSplineComponent::BPF_SetLocationOnPath(float _fDistanceOnPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveAlongSplineComponent", "BPF_SetLocationOnPath");

	Params::MoveAlongSplineComponent_BPF_SetLocationOnPath Parms{};

	Parms._fDistanceOnPath = _fDistanceOnPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MoveAlongSplineComponent.SetPath
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASplineActor*                     _newPath                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoveAlongSplineComponent::SetPath(class ASplineActor* _newPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveAlongSplineComponent", "SetPath");

	Params::MoveAlongSplineComponent_SetPath Parms{};

	Parms._newPath = _newPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallShootHitReaction.BPF_GenerateShootPrepTargetData
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class USCGameplayAbility*         _ability                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPendingHit&               _hit                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UBallPhysicComponent*             _ballPhysicComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShootPrepTargetData*            _result                                                (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBallShootHitReaction::BPF_GenerateShootPrepTargetData(const class USCGameplayAbility* _ability, const struct FPendingHit& _hit, class UBallPhysicComponent* _ballPhysicComponent, struct FShootPrepTargetData* _result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallShootHitReaction", "BPF_GenerateShootPrepTargetData");

	Params::BallShootHitReaction_BPF_GenerateShootPrepTargetData Parms{};

	Parms._ability = _ability;
	Parms._hit = std::move(_hit);
	Parms._ballPhysicComponent = _ballPhysicComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_result != nullptr)
		*_result = std::move(Parms._result);
}


// Function Runtime.BallInteractionBinder.BPE_OnBallInteraction
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayersInteraction                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBallInteractionType                    _eBallInteractionType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallInteractionBinder::BPE_OnBallInteraction(class UBallPlayersInteractionComponent* _ballPlayersInteraction, EBallInteractionType _eBallInteractionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallInteractionBinder", "BPE_OnBallInteraction");

	Params::BallInteractionBinder_BPE_OnBallInteraction Parms{};

	Parms._ballPlayersInteraction = _ballPlayersInteraction;
	Parms._eBallInteractionType = _eBallInteractionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallInteractionBinder.BPE_OnBallReset
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayersInteraction                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallInteractionBinder::BPE_OnBallReset(class UBallPlayersInteractionComponent* _ballPlayersInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallInteractionBinder", "BPE_OnBallReset");

	Params::BallInteractionBinder_BPE_OnBallReset Parms{};

	Parms._ballPlayersInteraction = _ballPlayersInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallInteractionBinder.OnBallReset
// (Final, Native, Protected)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayerInteraction                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallInteractionBinder::OnBallReset(class UBallPlayersInteractionComponent* _ballPlayerInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallInteractionBinder", "OnBallReset");

	Params::BallInteractionBinder_OnBallReset Parms{};

	Parms._ballPlayerInteraction = _ballPlayerInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallInteractionBinder.OnOwnershipChanged
// (Native, Protected)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayersInteraction                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallInteractionBinder::OnOwnershipChanged(class UBallPlayersInteractionComponent* _ballPlayersInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallInteractionBinder", "OnOwnershipChanged");

	Params::BallInteractionBinder_OnOwnershipChanged Parms{};

	Parms._ballPlayersInteraction = _ballPlayersInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallInteractionBinder.OnPreviousOwnerChanged
// (Native, Protected)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayersInteraction                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBallInteractionType                    _eInteractionType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallInteractionBinder::OnPreviousOwnerChanged(class UBallPlayersInteractionComponent* _ballPlayersInteraction, EBallInteractionType _eInteractionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallInteractionBinder", "OnPreviousOwnerChanged");

	Params::BallInteractionBinder_OnPreviousOwnerChanged Parms{};

	Parms._ballPlayersInteraction = _ballPlayersInteraction;
	Parms._eInteractionType = _eInteractionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallInteractionBinder.BPF_CanTrigger
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayersInteraction                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootParams&              _shootParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EBallInteractionType                    _eBallInteractionType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagQuery&         _newOwnerQuery                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTagQuery&         _shootTypeQuery                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    _bIngoreKickOffCpp                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bOnlyOnTeamChanged                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagQuery&         _PreviousOwnerQuery                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTagQuery&         _PreviousShootTypeQuery                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FShootParams&              _PreviousShootParams                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallInteractionBinder::BPF_CanTrigger(class UBallPlayersInteractionComponent* _ballPlayersInteraction, const struct FShootParams& _shootParams, EBallInteractionType _eBallInteractionType, const struct FGameplayTagQuery& _newOwnerQuery, const struct FGameplayTagQuery& _shootTypeQuery, bool _bIngoreKickOffCpp, bool _bOnlyOnTeamChanged, const struct FGameplayTagQuery& _PreviousOwnerQuery, const struct FGameplayTagQuery& _PreviousShootTypeQuery, const struct FShootParams& _PreviousShootParams) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallInteractionBinder", "BPF_CanTrigger");

	Params::BallInteractionBinder_BPF_CanTrigger Parms{};

	Parms._ballPlayersInteraction = _ballPlayersInteraction;
	Parms._shootParams = std::move(_shootParams);
	Parms._eBallInteractionType = _eBallInteractionType;
	Parms._newOwnerQuery = std::move(_newOwnerQuery);
	Parms._shootTypeQuery = std::move(_shootTypeQuery);
	Parms._bIngoreKickOffCpp = _bIngoreKickOffCpp;
	Parms._bOnlyOnTeamChanged = _bOnlyOnTeamChanged;
	Parms._PreviousOwnerQuery = std::move(_PreviousOwnerQuery);
	Parms._PreviousShootTypeQuery = std::move(_PreviousShootTypeQuery);
	Parms._PreviousShootParams = std::move(_PreviousShootParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallInteractionBinder.BPF_GetNewAndPreviousInteracters
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayersInteraction                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBallInteractionType                    _eBallInteractionType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimePlayerState**             _outNewInteracter                                      (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimePlayerState**             _outPreviousInteracter                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallInteractionBinder::BPF_GetNewAndPreviousInteracters(class UBallPlayersInteractionComponent* _ballPlayersInteraction, EBallInteractionType _eBallInteractionType, class ARuntimePlayerState** _outNewInteracter, class ARuntimePlayerState** _outPreviousInteracter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallInteractionBinder", "BPF_GetNewAndPreviousInteracters");

	Params::BallInteractionBinder_BPF_GetNewAndPreviousInteracters Parms{};

	Parms._ballPlayersInteraction = _ballPlayersInteraction;
	Parms._eBallInteractionType = _eBallInteractionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outNewInteracter != nullptr)
		*_outNewInteracter = Parms._outNewInteracter;

	if (_outPreviousInteracter != nullptr)
		*_outPreviousInteracter = Parms._outPreviousInteracter;
}


// Function Runtime.BallInteractionBinder.BPF_GetPreviousInteracter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayersInteraction                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBallInteractionType                    _eBallInteractionType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _iIndexInteraction                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimePlayerState*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARuntimePlayerState* UBallInteractionBinder::BPF_GetPreviousInteracter(class UBallPlayersInteractionComponent* _ballPlayersInteraction, EBallInteractionType _eBallInteractionType, int32 _iIndexInteraction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallInteractionBinder", "BPF_GetPreviousInteracter");

	Params::BallInteractionBinder_BPF_GetPreviousInteracter Parms{};

	Parms._ballPlayersInteraction = _ballPlayersInteraction;
	Parms._eBallInteractionType = _eBallInteractionType;
	Parms._iIndexInteraction = _iIndexInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallInteractionBinder.BPF_HasTeamChanged
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayersInteraction                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBallInteractionType                    _eBallInteractionType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallInteractionBinder::BPF_HasTeamChanged(class UBallPlayersInteractionComponent* _ballPlayersInteraction, EBallInteractionType _eBallInteractionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallInteractionBinder", "BPF_HasTeamChanged");

	Params::BallInteractionBinder_BPF_HasTeamChanged Parms{};

	Parms._ballPlayersInteraction = _ballPlayersInteraction;
	Parms._eBallInteractionType = _eBallInteractionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallInterceptionPointTargetDatasource.BPF_FindSingleTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_handle                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FBallInterceptionPointTargetData*_outData                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallInterceptionPointTargetDatasource::BPF_FindSingleTarget(const struct FGameplayAbilityTargetDataHandle& _handle, struct FBallInterceptionPointTargetData* _outData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BallInterceptionPointTargetDatasource", "BPF_FindSingleTarget");

	Params::BallInterceptionPointTargetDatasource_BPF_FindSingleTarget Parms{};

	Parms._handle = std::move(_handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outData != nullptr)
		*_outData = std::move(Parms._outData);

	return Parms.ReturnValue;
}


// Function Runtime.BallInterceptionPointTargetDatasource.BPF_GetBall
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FBallInterceptionPointTargetData&_targetData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ABall*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABall* UBallInterceptionPointTargetDatasource::BPF_GetBall(const struct FBallInterceptionPointTargetData& _targetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BallInterceptionPointTargetDatasource", "BPF_GetBall");

	Params::BallInterceptionPointTargetDatasource_BPF_GetBall Parms{};

	Parms._targetData = std::move(_targetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.GetOffsetedBallInterceptionPointDatasource.BPF_FindSingleTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_handle                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FBallInterceptionPointTargetData*_outData                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGetOffsetedBallInterceptionPointDatasource::BPF_FindSingleTarget(const struct FGameplayAbilityTargetDataHandle& _handle, struct FBallInterceptionPointTargetData* _outData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GetOffsetedBallInterceptionPointDatasource", "BPF_FindSingleTarget");

	Params::GetOffsetedBallInterceptionPointDatasource_BPF_FindSingleTarget Parms{};

	Parms._handle = std::move(_handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outData != nullptr)
		*_outData = std::move(Parms._outData);

	return Parms.ReturnValue;
}


// Function Runtime.MatchViewModel.OnCaptainsSet
// (Final, Native, Protected)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchViewModel::OnCaptainsSet(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "OnCaptainsSet");

	Params::MatchViewModel_OnCaptainsSet Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchViewModel.OnLocalCharacterGenerated
// (Final, Native, Protected)
// Parameters:
// class UCharacterCustomizationComponent* _characterCustomizationComponent                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bWasCharacterGenerated                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchViewModel::OnLocalCharacterGenerated(class UCharacterCustomizationComponent* _characterCustomizationComponent, bool _bWasCharacterGenerated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "OnLocalCharacterGenerated");

	Params::MatchViewModel_OnLocalCharacterGenerated Parms{};

	Parms._characterCustomizationComponent = _characterCustomizationComponent;
	Parms._bWasCharacterGenerated = _bWasCharacterGenerated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchViewModel.OnMVPSet
// (Final, Native, Protected)
// Parameters:
// class ARuntimePlayerState*              _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchViewModel::OnMVPSet(class ARuntimePlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "OnMVPSet");

	Params::MatchViewModel_OnMVPSet Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchViewModel.OnPlayerAdded
// (Final, Native, Protected)
// Parameters:
// class APlayerState*                     _player                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchViewModel::OnPlayerAdded(class APlayerState* _player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "OnPlayerAdded");

	Params::MatchViewModel_OnPlayerAdded Parms{};

	Parms._player = _player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchViewModel.OnPlayerInitialReplication
// (Final, Native, Protected)
// Parameters:
// class ASCPlayerState*                   _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchViewModel::OnPlayerInitialReplication(class ASCPlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "OnPlayerInitialReplication");

	Params::MatchViewModel_OnPlayerInitialReplication Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchViewModel.OnPlayerPawnSet
// (Final, Native, Protected)
// Parameters:
// class APlayerState*                     _player                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            _newPawn                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            _oldPawn                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchViewModel::OnPlayerPawnSet(class APlayerState* _player, class APawn* _newPawn, class APawn* _oldPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "OnPlayerPawnSet");

	Params::MatchViewModel_OnPlayerPawnSet Parms{};

	Parms._player = _player;
	Parms._newPawn = _newPawn;
	Parms._oldPawn = _oldPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchViewModel.OnPlayerProfileCustoSet
// (Final, Native, Protected)
// Parameters:
// class ARuntimePlayerState*              _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchViewModel::OnPlayerProfileCustoSet(class ARuntimePlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "OnPlayerProfileCustoSet");

	Params::MatchViewModel_OnPlayerProfileCustoSet Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchViewModel.OnPlayerRemoved
// (Final, Native, Protected)
// Parameters:
// class APlayerState*                     _player                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchViewModel::OnPlayerRemoved(class APlayerState* _player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "OnPlayerRemoved");

	Params::MatchViewModel_OnPlayerRemoved Parms{};

	Parms._player = _player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchViewModel.OnPlayerSanitizedNameChanged
// (Final, Native, Protected)
// Parameters:
// class ARuntimePlayerState*              _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchViewModel::OnPlayerSanitizedNameChanged(class ARuntimePlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "OnPlayerSanitizedNameChanged");

	Params::MatchViewModel_OnPlayerSanitizedNameChanged Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchViewModel.OnPlayerTeamChanged
// (Final, Native, Protected)
// Parameters:
// class ARuntimePlayerState*              _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   _uiNewTeam                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _iNumberInTeam                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchViewModel::OnPlayerTeamChanged(class ARuntimePlayerState* _playerState, uint8 _uiNewTeam, int32 _iNumberInTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "OnPlayerTeamChanged");

	Params::MatchViewModel_OnPlayerTeamChanged Parms{};

	Parms._playerState = _playerState;
	Parms._uiNewTeam = _uiNewTeam;
	Parms._iNumberInTeam = _iNumberInTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchViewModel.OnPlayerUniqueIdReplicated
// (Final, Native, Protected)
// Parameters:
// class ASCPlayerState*                   _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchViewModel::OnPlayerUniqueIdReplicated(class ASCPlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "OnPlayerUniqueIdReplicated");

	Params::MatchViewModel_OnPlayerUniqueIdReplicated Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchViewModel.BPF_GetAwayTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UMatchPlayerViewModel*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMatchPlayerViewModel*> UMatchViewModel::BPF_GetAwayTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "BPF_GetAwayTeam");

	Params::MatchViewModel_BPF_GetAwayTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchViewModel.BPF_GetHomeTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UMatchPlayerViewModel*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMatchPlayerViewModel*> UMatchViewModel::BPF_GetHomeTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "BPF_GetHomeTeam");

	Params::MatchViewModel_BPF_GetHomeTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchViewModel.BPF_GetLocalTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UMatchPlayerViewModel*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMatchPlayerViewModel*> UMatchViewModel::BPF_GetLocalTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "BPF_GetLocalTeam");

	Params::MatchViewModel_BPF_GetLocalTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchViewModel.BPF_GetOpponentTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UMatchPlayerViewModel*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMatchPlayerViewModel*> UMatchViewModel::BPF_GetOpponentTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "BPF_GetOpponentTeam");

	Params::MatchViewModel_BPF_GetOpponentTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchViewModel.BPF_GetPlayerViewModelFromPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ARuntimePlayerState*        _runtimePlayerState                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UMatchPlayerViewModel*      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMatchPlayerViewModel* UMatchViewModel::BPF_GetPlayerViewModelFromPlayerState(const class ARuntimePlayerState* _runtimePlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "BPF_GetPlayerViewModelFromPlayerState");

	Params::MatchViewModel_BPF_GetPlayerViewModelFromPlayerState Parms{};

	Parms._runtimePlayerState = _runtimePlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchViewModel.BPF_IsCaptain
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchViewModel::BPF_IsCaptain() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "BPF_IsCaptain");

	Params::MatchViewModel_BPF_IsCaptain Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchViewModel.BPF_IsInSquad
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchViewModel::BPF_IsInSquad() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "BPF_IsInSquad");

	Params::MatchViewModel_BPF_IsInSquad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchViewModel.BPF_IsLocalPlayerInHomeTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchViewModel::BPF_IsLocalPlayerInHomeTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "BPF_IsLocalPlayerInHomeTeam");

	Params::MatchViewModel_BPF_IsLocalPlayerInHomeTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchViewModel.BPF_IsSquadLeader
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatchViewModel::BPF_IsSquadLeader() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchViewModel", "BPF_IsSquadLeader");

	Params::MatchViewModel_BPF_IsSquadLeader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallInterceptionPointHelpers.BPF_GetStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBallInterceptionPointTargetData&_ballInterceptionPointTargetData                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UBallInterceptionPointHelpers::BPF_GetStatus(const class AActor* _actor, const struct FBallInterceptionPointTargetData& _ballInterceptionPointTargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BallInterceptionPointHelpers", "BPF_GetStatus");

	Params::BallInterceptionPointHelpers_BPF_GetStatus Parms{};

	Parms._actor = _actor;
	Parms._ballInterceptionPointTargetData = std::move(_ballInterceptionPointTargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallInterceptionPointHelpers.BPF_IsEmpty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FBallInterceptionPointTargetData&_ballInterceptionPointTargetData                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallInterceptionPointHelpers::BPF_IsEmpty(const struct FBallInterceptionPointTargetData& _ballInterceptionPointTargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BallInterceptionPointHelpers", "BPF_IsEmpty");

	Params::BallInterceptionPointHelpers_BPF_IsEmpty Parms{};

	Parms._ballInterceptionPointTargetData = std::move(_ballInterceptionPointTargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallInterceptionPointHelpers.BPF_IsImmobile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FBallInterceptionPointTargetData&_ballInterceptionPointTargetData                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallInterceptionPointHelpers::BPF_IsImmobile(const struct FBallInterceptionPointTargetData& _ballInterceptionPointTargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BallInterceptionPointHelpers", "BPF_IsImmobile");

	Params::BallInterceptionPointHelpers_BPF_IsImmobile Parms{};

	Parms._ballInterceptionPointTargetData = std::move(_ballInterceptionPointTargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallInterceptionPointHelpers.BPF_IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FBallInterceptionPointTargetData&_ballInterceptionPointTargetData                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallInterceptionPointHelpers::BPF_IsValid(const struct FBallInterceptionPointTargetData& _ballInterceptionPointTargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BallInterceptionPointHelpers", "BPF_IsValid");

	Params::BallInterceptionPointHelpers_BPF_IsValid Parms{};

	Parms._ballInterceptionPointTargetData = std::move(_ballInterceptionPointTargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.PlayerBallOwnership.BPF_GetBall
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ABall**                           _outBallRef                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecSuccessEnum*                       _OutExecBranches                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerBallOwnership::BPF_GetBall(class ABall** _outBallRef, EExecSuccessEnum* _OutExecBranches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBallOwnership", "BPF_GetBall");

	Params::PlayerBallOwnership_BPF_GetBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outBallRef != nullptr)
		*_outBallRef = Parms._outBallRef;

	if (_OutExecBranches != nullptr)
		*_OutExecBranches = Parms._OutExecBranches;
}


// Function Runtime.PlayerBallOwnership.BPF_SetBall
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bSteal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerBallOwnership::BPF_SetBall(class ABall* _ball, bool _bSteal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBallOwnership", "BPF_SetBall");

	Params::PlayerBallOwnership_BPF_SetBall Parms{};

	Parms._ball = _ball;
	Parms._bSteal = _bSteal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.PlayerBallOwnership.BPF_GetBallPure
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABall*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABall* UPlayerBallOwnership::BPF_GetBallPure() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBallOwnership", "BPF_GetBallPure");

	Params::PlayerBallOwnership_BPF_GetBallPure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.PlayerBallOwnership.BPF_GetPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARuntimePlayerState*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARuntimePlayerState* UPlayerBallOwnership::BPF_GetPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBallOwnership", "BPF_GetPlayerState");

	Params::PlayerBallOwnership_BPF_GetPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_ApplyShoot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FShootParams&              _shootParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UGameplayAbility*           _instigatorAbility                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bAttachedToPlayer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallPhysicComponent::BPF_ApplyShoot(const struct FShootParams& _shootParams, const class UGameplayAbility* _instigatorAbility, bool _bAttachedToPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_ApplyShoot");

	Params::BallPhysicComponent_BPF_ApplyShoot Parms{};

	Parms._shootParams = std::move(_shootParams);
	Parms._instigatorAbility = _instigatorAbility;
	Parms._bAttachedToPlayer = _bAttachedToPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallPhysicComponent.BPF_GetTimeToReachLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   _vLocationToReach                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBallPhysicComponent::BPF_GetTimeToReachLocation(const struct FVector& _vLocationToReach)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_GetTimeToReachLocation");

	Params::BallPhysicComponent_BPF_GetTimeToReachLocation Parms{};

	Parms._vLocationToReach = std::move(_vLocationToReach);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_IsLocationOnFutureTrajectory
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   _vLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fExcludePointBeforeTime                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fDistanceTolerance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallPhysicComponent::BPF_IsLocationOnFutureTrajectory(const struct FVector& _vLocation, float _fExcludePointBeforeTime, float _fDistanceTolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_IsLocationOnFutureTrajectory");

	Params::BallPhysicComponent_BPF_IsLocationOnFutureTrajectory Parms{};

	Parms._vLocation = std::move(_vLocation);
	Parms._fExcludePointBeforeTime = _fExcludePointBeforeTime;
	Parms._fDistanceTolerance = _fDistanceTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_IsPointOnFutureTrajectory
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FPredictProjectilePathPointData&keypoint                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   _fDistanceTolerance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallPhysicComponent::BPF_IsPointOnFutureTrajectory(const struct FPredictProjectilePathPointData& keypoint, float _fDistanceTolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_IsPointOnFutureTrajectory");

	Params::BallPhysicComponent_BPF_IsPointOnFutureTrajectory Parms{};

	Parms.keypoint = std::move(keypoint);
	Parms._fDistanceTolerance = _fDistanceTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_TryToBroadcastRejectedShootEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FShootParams&              _shootParamsOverride                                   (Parm, NativeAccessSpecifierPublic)

void UBallPhysicComponent::BPF_TryToBroadcastRejectedShootEvent(const struct FShootParams& _shootParamsOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_TryToBroadcastRejectedShootEvent");

	Params::BallPhysicComponent_BPF_TryToBroadcastRejectedShootEvent Parms{};

	Parms._shootParamsOverride = std::move(_shootParamsOverride);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallPhysicComponent.OnBallInteractionPrioUpdated
// (Final, Native, Private)

void UBallPhysicComponent::OnBallInteractionPrioUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "OnBallInteractionPrioUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallPhysicComponent.OnBallOwnerChanged
// (Final, Native, Private)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayerInteraction                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallPhysicComponent::OnBallOwnerChanged(class UBallPlayersInteractionComponent* _ballPlayerInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "OnBallOwnerChanged");

	Params::BallPhysicComponent_OnBallOwnerChanged Parms{};

	Parms._ballPlayerInteraction = _ballPlayerInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallPhysicComponent.OnRep_ServerTrajectoryStartingPoint
// (Final, Native, Private)

void UBallPhysicComponent::OnRep_ServerTrajectoryStartingPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "OnRep_ServerTrajectoryStartingPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallPhysicComponent.BPF_CurrentTrajectoryStartedFromSpecifiedBounce
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   _iSurfaces                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallPhysicComponent::BPF_CurrentTrajectoryStartedFromSpecifiedBounce(int32 _iSurfaces) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_CurrentTrajectoryStartedFromSpecifiedBounce");

	Params::BallPhysicComponent_BPF_CurrentTrajectoryStartedFromSpecifiedBounce Parms{};

	Parms._iSurfaces = _iSurfaces;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_GetAttachedBall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABall*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABall* UBallPhysicComponent::BPF_GetAttachedBall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_GetAttachedBall");

	Params::BallPhysicComponent_BPF_GetAttachedBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_GetCurrentShootParams
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FShootParams               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FShootParams UBallPhysicComponent::BPF_GetCurrentShootParams() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_GetCurrentShootParams");

	Params::BallPhysicComponent_BPF_GetCurrentShootParams Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_GetLastShootParamsFromHistory
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FShootParams*                    _shootParams                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallPhysicComponent::BPF_GetLastShootParamsFromHistory(struct FShootParams* _shootParams) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_GetLastShootParamsFromHistory");

	Params::BallPhysicComponent_BPF_GetLastShootParamsFromHistory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_shootParams != nullptr)
		*_shootParams = std::move(Parms._shootParams);

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_GetStatusTimeLimit
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              _tag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   _bSuccess                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bGetShootInstigatorTime                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBallPhysicComponent::BPF_GetStatusTimeLimit(const struct FGameplayTag& _tag, bool* _bSuccess, bool _bGetShootInstigatorTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_GetStatusTimeLimit");

	Params::BallPhysicComponent_BPF_GetStatusTimeLimit Parms{};

	Parms._tag = std::move(_tag);
	Parms._bGetShootInstigatorTime = _bGetShootInstigatorTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_bSuccess != nullptr)
		*_bSuccess = Parms._bSuccess;

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_GetTrajectory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBallTrajectoryResult            ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FBallTrajectoryResult UBallPhysicComponent::BPF_GetTrajectory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_GetTrajectory");

	Params::BallPhysicComponent_BPF_GetTrajectory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_GetVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBallPhysicComponent::BPF_GetVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_GetVelocity");

	Params::BallPhysicComponent_BPF_GetVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_HasBallStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              _tag                                                   (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              _bOnShootInstigator                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallPhysicComponent::BPF_HasBallStatus(const struct FGameplayTag& _tag, const bool _bOnShootInstigator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_HasBallStatus");

	Params::BallPhysicComponent_BPF_HasBallStatus Parms{};

	Parms._tag = std::move(_tag);
	Parms._bOnShootInstigator = _bOnShootInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPhysicComponent.BPF_MakeBallInterceptionPointTargetData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   _fTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBallInterceptionPointTargetData*_result                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UBallPhysicComponent::BPF_MakeBallInterceptionPointTargetData(float _fTime, struct FBallInterceptionPointTargetData* _result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_MakeBallInterceptionPointTargetData");

	Params::BallPhysicComponent_BPF_MakeBallInterceptionPointTargetData Parms{};

	Parms._fTime = _fTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_result != nullptr)
		*_result = std::move(Parms._result);
}


// Function Runtime.BallPhysicComponent.BPF_MakeBallInterceptionPointTargetDataFromCurrentState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   _fTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBallInterceptionPointTargetData*_result                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UBallPhysicComponent::BPF_MakeBallInterceptionPointTargetDataFromCurrentState(float _fTime, struct FBallInterceptionPointTargetData* _result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_MakeBallInterceptionPointTargetDataFromCurrentState");

	Params::BallPhysicComponent_BPF_MakeBallInterceptionPointTargetDataFromCurrentState Parms{};

	Parms._fTime = _fTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_result != nullptr)
		*_result = std::move(Parms._result);
}


// Function Runtime.BallPhysicComponent.BPF_MakeBallPathPointData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   _fTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPredictProjectilePathPointData  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPredictProjectilePathPointData UBallPhysicComponent::BPF_MakeBallPathPointData(float _fTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPhysicComponent", "BPF_MakeBallPathPointData");

	Params::BallPhysicComponent_BPF_MakeBallPathPointData Parms{};

	Parms._fTime = _fTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPlayersInteractionComponent.BPF_ClearBallOwnership
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USCAbilitySystemComponent*        _predictionOwner                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallPlayersInteractionComponent::BPF_ClearBallOwnership(class USCAbilitySystemComponent* _predictionOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_ClearBallOwnership");

	Params::BallPlayersInteractionComponent_BPF_ClearBallOwnership Parms{};

	Parms._predictionOwner = _predictionOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallPlayersInteractionComponent.BPF_GetBallOwnership
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPlayerBallOwnership**            _OutOwnerRef                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecSuccessEnum*                       _OutExecBranches                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallPlayersInteractionComponent::BPF_GetBallOwnership(class UPlayerBallOwnership** _OutOwnerRef, EExecSuccessEnum* _OutExecBranches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_GetBallOwnership");

	Params::BallPlayersInteractionComponent_BPF_GetBallOwnership Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_OutOwnerRef != nullptr)
		*_OutOwnerRef = Parms._OutOwnerRef;

	if (_OutExecBranches != nullptr)
		*_OutExecBranches = Parms._OutExecBranches;
}


// Function Runtime.BallPlayersInteractionComponent.MulticastOnBallKickedOff
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARuntimePlayerState*              _kickOffOwner                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallPlayersInteractionComponent::MulticastOnBallKickedOff(class ARuntimePlayerState* _kickOffOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "MulticastOnBallKickedOff");

	Params::BallPlayersInteractionComponent_MulticastOnBallKickedOff Parms{};

	Parms._kickOffOwner = _kickOffOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallPlayersInteractionComponent.OnRep_BallInteractionPrio
// (Final, Native, Public)

void UBallPlayersInteractionComponent::OnRep_BallInteractionPrio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "OnRep_BallInteractionPrio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallPlayersInteractionComponent.OnRep_ServerOwner
// (Final, Native, Public)

void UBallPlayersInteractionComponent::OnRep_ServerOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "OnRep_ServerOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallPlayersInteractionComponent.SwapInteractionRequestToFirst
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   _iIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBallPlayersInteractionComponent::SwapInteractionRequestToFirst(int32 _iIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "SwapInteractionRequestToFirst");

	Params::BallPlayersInteractionComponent_SwapInteractionRequestToFirst Parms{};

	Parms._iIndex = _iIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.BallPlayersInteractionComponent.BPF_GetBall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABall*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABall* UBallPlayersInteractionComponent::BPF_GetBall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_GetBall");

	Params::BallPlayersInteractionComponent_BPF_GetBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPlayersInteractionComponent.BPF_GetInteracter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   _iIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerBallOwnership*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerBallOwnership* UBallPlayersInteractionComponent::BPF_GetInteracter(int32 _iIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_GetInteracter");

	Params::BallPlayersInteractionComponent_BPF_GetInteracter Parms{};

	Parms._iIndex = _iIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPlayersInteractionComponent.BPF_GetInteracters
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UPlayerBallOwnership*>*    _outInteracters                                        (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBallPlayersInteractionComponent::BPF_GetInteracters(TArray<class UPlayerBallOwnership*>* _outInteracters) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_GetInteracters");

	Params::BallPlayersInteractionComponent_BPF_GetInteracters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outInteracters != nullptr)
		*_outInteracters = std::move(Parms._outInteracters);
}


// Function Runtime.BallPlayersInteractionComponent.BPF_GetLastOwnerByTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   _iTeam                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimePlayerState*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARuntimePlayerState* UBallPlayersInteractionComponent::BPF_GetLastOwnerByTeam(int32 _iTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_GetLastOwnerByTeam");

	Params::BallPlayersInteractionComponent_BPF_GetLastOwnerByTeam Parms{};

	Parms._iTeam = _iTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPlayersInteractionComponent.BPF_GetPlayerBallOwnership
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    _bIgnorePrediction                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerBallOwnership*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerBallOwnership* UBallPlayersInteractionComponent::BPF_GetPlayerBallOwnership(bool _bIgnorePrediction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_GetPlayerBallOwnership");

	Params::BallPlayersInteractionComponent_BPF_GetPlayerBallOwnership Parms{};

	Parms._bIgnorePrediction = _bIgnorePrediction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPlayersInteractionComponent.BPF_GetPreviousOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   _iIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimePlayerState*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARuntimePlayerState* UBallPlayersInteractionComponent::BPF_GetPreviousOwner(int32 _iIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_GetPreviousOwner");

	Params::BallPlayersInteractionComponent_BPF_GetPreviousOwner Parms{};

	Parms._iIndex = _iIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPlayersInteractionComponent.BPF_GetPreviousOwners
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARuntimePlayerState*>*     _outPlayerStates                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBallPlayersInteractionComponent::BPF_GetPreviousOwners(TArray<class ARuntimePlayerState*>* _outPlayerStates) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_GetPreviousOwners");

	Params::BallPlayersInteractionComponent_BPF_GetPreviousOwners Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outPlayerStates != nullptr)
		*_outPlayerStates = std::move(Parms._outPlayerStates);
}


// Function Runtime.BallPlayersInteractionComponent.BPF_HasOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    _bIgnorePrediction                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallPlayersInteractionComponent::BPF_HasOwner(bool _bIgnorePrediction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_HasOwner");

	Params::BallPlayersInteractionComponent_BPF_HasOwner Parms{};

	Parms._bIgnorePrediction = _bIgnorePrediction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPlayersInteractionComponent.BPF_IsFreeToTake
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallPlayersInteractionComponent::BPF_IsFreeToTake() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_IsFreeToTake");

	Params::BallPlayersInteractionComponent_BPF_IsFreeToTake Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BallPlayersInteractionComponent.BPF_TryGetBallOwningTeam
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8*                                  _uiOutOwningTeam                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBallPlayersInteractionComponent::BPF_TryGetBallOwningTeam(uint8* _uiOutOwningTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "BPF_TryGetBallOwningTeam");

	Params::BallPlayersInteractionComponent_BPF_TryGetBallOwningTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_uiOutOwningTeam != nullptr)
		*_uiOutOwningTeam = Parms._uiOutOwningTeam;

	return Parms.ReturnValue;
}


// Function Runtime.BallPlayersInteractionComponent.GetBallInteractionRequests
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FBallInteractionRequestData>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FBallInteractionRequestData> UBallPlayersInteractionComponent::GetBallInteractionRequests() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BallPlayersInteractionComponent", "GetBallInteractionRequests");

	Params::BallPlayersInteractionComponent_GetBallInteractionRequests Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CameraComponentThird.BPF_FreezeWithService
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    _bShutdownWhenStickReleased                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _FSCDeadZone                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCameraComponentThird::BPF_FreezeWithService(bool _bShutdownWhenStickReleased, float _FSCDeadZone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraComponentThird", "BPF_FreezeWithService");

	Params::CameraComponentThird_BPF_FreezeWithService Parms{};

	Parms._bShutdownWhenStickReleased = _bShutdownWhenStickReleased;
	Parms._FSCDeadZone = _FSCDeadZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CameraComponentThird.BPF_UnfreezeWithService
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCameraComponentThird::BPF_UnfreezeWithService()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraComponentThird", "BPF_UnfreezeWithService");

	Params::CameraComponentThird_BPF_UnfreezeWithService Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CameraLockBallService.BPF_OverrideLookAtBallPredictionDelay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   fNewDelay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraLockBallService::BPF_OverrideLookAtBallPredictionDelay(float fNewDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraLockBallService", "BPF_OverrideLookAtBallPredictionDelay");

	Params::CameraLockBallService_BPF_OverrideLookAtBallPredictionDelay Parms{};

	Parms.fNewDelay = fNewDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CameraLockBallService.BPF_StopLookAt
// (Final, Native, Public, BlueprintCallable)

void UCameraLockBallService::BPF_StopLookAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraLockBallService", "BPF_StopLookAt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CameraLockBallService.BPF_TryStartLookAt
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSCCameraLookAtServiceBehavior&_lookAtBehavior                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   _fBallPosPredictionDelay                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCameraLockBallService::BPF_TryStartLookAt(const struct FSCCameraLookAtServiceBehavior& _lookAtBehavior, float _fBallPosPredictionDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraLockBallService", "BPF_TryStartLookAt");

	Params::CameraLockBallService_BPF_TryStartLookAt Parms{};

	Parms._lookAtBehavior = std::move(_lookAtBehavior);
	Parms._fBallPosPredictionDelay = _fBallPosPredictionDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CameraLockBallService.BPF_GetLookAtHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCameraLockBallService::BPF_GetLookAtHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraLockBallService", "BPF_GetLookAtHandle");

	Params::CameraLockBallService_BPF_GetLookAtHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CameraLockBallService.BPF_GetLookAtScreenSpaceRedirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCameraLockBallService::BPF_GetLookAtScreenSpaceRedirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraLockBallService", "BPF_GetLookAtScreenSpaceRedirection");

	Params::CameraLockBallService_BPF_GetLookAtScreenSpaceRedirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CameraLockBallService.BPF_IsSleeping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCameraLockBallService::BPF_IsSleeping() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraLockBallService", "BPF_IsSleeping");

	Params::CameraLockBallService_BPF_IsSleeping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CameraNodeServiceRuntimeBase.BPF_GetBall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCameraNodeServiceRuntimeBase::BPF_GetBall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraNodeServiceRuntimeBase", "BPF_GetBall");

	Params::CameraNodeServiceRuntimeBase_BPF_GetBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CameraServiceGoalKeeper.BPF_GetASC
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USCAbilitySystemComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USCAbilitySystemComponent* UCameraServiceGoalKeeper::BPF_GetASC() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraServiceGoalKeeper", "BPF_GetASC");

	Params::CameraServiceGoalKeeper_BPF_GetASC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CameraServiceGoalKeeper.BPF_GetBall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCameraServiceGoalKeeper::BPF_GetBall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraServiceGoalKeeper", "BPF_GetBall");

	Params::CameraServiceGoalKeeper_BPF_GetBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CameraServiceGoalKeeper.BPF_GetDistanceBasedRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UCameraServiceGoalKeeper::BPF_GetDistanceBasedRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraServiceGoalKeeper", "BPF_GetDistanceBasedRatio");

	Params::CameraServiceGoalKeeper_BPF_GetDistanceBasedRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.BounceTrajectoryStatusDeactivateCondition.BPE_SetSurface
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FShootParams&              _shootParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool*                                   _bSpecificSurface                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  _iSurface                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBounceTrajectoryStatusDeactivateCondition::BPE_SetSurface(const struct FShootParams& _shootParams, bool* _bSpecificSurface, int32* _iSurface) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BounceTrajectoryStatusDeactivateCondition", "BPE_SetSurface");

	Params::BounceTrajectoryStatusDeactivateCondition_BPE_SetSurface Parms{};

	Parms._shootParams = std::move(_shootParams);

	UObject::ProcessEvent(Func, &Parms);

	if (_bSpecificSurface != nullptr)
		*_bSpecificSurface = Parms._bSpecificSurface;

	if (_iSurface != nullptr)
		*_iSurface = Parms._iSurface;
}


// Function Runtime.ColorPaletteHelpers.BPF_FindColorPaletteAssetIndexFromColors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    _context                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UColorPaletteDataAsset*>&_palettes                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FLinearColor>&      _paletteToFind                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UColorPaletteHelpers::BPF_FindColorPaletteAssetIndexFromColors(const class UObject* _context, const TArray<class UColorPaletteDataAsset*>& _palettes, const TArray<struct FLinearColor>& _paletteToFind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ColorPaletteHelpers", "BPF_FindColorPaletteAssetIndexFromColors");

	Params::ColorPaletteHelpers_BPF_FindColorPaletteAssetIndexFromColors Parms{};

	Parms._context = _context;
	Parms._palettes = std::move(_palettes);
	Parms._paletteToFind = std::move(_paletteToFind);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ColorPaletteHelpers.BPF_FindColorPaletteIndexFromColors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    _context                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FColorPalette>&     _palettes                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FLinearColor>&      _paletteToFind                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UColorPaletteHelpers::BPF_FindColorPaletteIndexFromColors(const class UObject* _context, const TArray<struct FColorPalette>& _palettes, const TArray<struct FLinearColor>& _paletteToFind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ColorPaletteHelpers", "BPF_FindColorPaletteIndexFromColors");

	Params::ColorPaletteHelpers_BPF_FindColorPaletteIndexFromColors Parms{};

	Parms._context = _context;
	Parms._palettes = std::move(_palettes);
	Parms._paletteToFind = std::move(_paletteToFind);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ColorPaletteHelpers.BPF_GetPaletteColorArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    _context                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColorPalette&             _palette                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLinearColor>*            _outColors                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UColorPaletteHelpers::BPF_GetPaletteColorArray(const class UObject* _context, const struct FColorPalette& _palette, TArray<struct FLinearColor>* _outColors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ColorPaletteHelpers", "BPF_GetPaletteColorArray");

	Params::ColorPaletteHelpers_BPF_GetPaletteColorArray Parms{};

	Parms._context = _context;
	Parms._palette = std::move(_palette);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outColors != nullptr)
		*_outColors = std::move(Parms._outColors);
}


// Function Runtime.ColorPaletteHelpers.BPF_GetPaletteColors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    _context                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColorPalette&             _palette                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    _primaryColor                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    _secondaryColor                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    _tertiaryColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorPaletteHelpers::BPF_GetPaletteColors(const class UObject* _context, const struct FColorPalette& _palette, struct FLinearColor* _primaryColor, struct FLinearColor* _secondaryColor, struct FLinearColor* _tertiaryColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ColorPaletteHelpers", "BPF_GetPaletteColors");

	Params::ColorPaletteHelpers_BPF_GetPaletteColors Parms{};

	Parms._context = _context;
	Parms._palette = std::move(_palette);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_primaryColor != nullptr)
		*_primaryColor = std::move(Parms._primaryColor);

	if (_secondaryColor != nullptr)
		*_secondaryColor = std::move(Parms._secondaryColor);

	if (_tertiaryColor != nullptr)
		*_tertiaryColor = std::move(Parms._tertiaryColor);
}


// Function Runtime.TutorialManager.BPE_OnStartCurrentStep
// (Event, Public, BlueprintEvent)

void ATutorialManager::BPE_OnStartCurrentStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "BPE_OnStartCurrentStep");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.TutorialManager.BPE_OnStartTutorial
// (Event, Public, BlueprintEvent)

void ATutorialManager::BPE_OnStartTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "BPE_OnStartTutorial");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.TutorialManager.BPE_OnTutorialComplete
// (Event, Protected, BlueprintEvent)

void ATutorialManager::BPE_OnTutorialComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "BPE_OnTutorialComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.TutorialManager.BPE_OnWaitingPlayerInputToStart
// (Event, Public, BlueprintEvent)

void ATutorialManager::BPE_OnWaitingPlayerInputToStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "BPE_OnWaitingPlayerInputToStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.TutorialManager.InitTutorial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCommonActivatableWidget*         _widgetToUse                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialManager::InitTutorial(class UCommonActivatableWidget* _widgetToUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "InitTutorial");

	Params::TutorialManager_InitTutorial Parms{};

	Parms._widgetToUse = _widgetToUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialManager.OnLevelSequencePlayedAtTheBeginningFinished
// (Final, Native, Protected)

void ATutorialManager::OnLevelSequencePlayedAtTheBeginningFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "OnLevelSequencePlayedAtTheBeginningFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialManager.OnLevelSequencePlayedAtTheEndFinished
// (Final, Native, Protected)

void ATutorialManager::OnLevelSequencePlayedAtTheEndFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "OnLevelSequencePlayedAtTheEndFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialManager.OnPossessedPawnChanged
// (Final, Native, Public)
// Parameters:
// class APawn*                            _oldPawn                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            _newPawn                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialManager::OnPossessedPawnChanged(class APawn* _oldPawn, class APawn* _newPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "OnPossessedPawnChanged");

	Params::TutorialManager_OnPossessedPawnChanged Parms{};

	Parms._oldPawn = _oldPawn;
	Parms._newPawn = _newPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialManager.OnSkipIntroductionInputPressed
// (Final, Native, Public, BlueprintCallable)

void ATutorialManager::OnSkipIntroductionInputPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "OnSkipIntroductionInputPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialManager.OnStepSucceeded
// (Final, Native, Public)

void ATutorialManager::OnStepSucceeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "OnStepSucceeded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialManager.BPF_FindTutorialActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              _tag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATutorialActor*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATutorialActor* ATutorialManager::BPF_FindTutorialActor(const struct FGameplayTag& _tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "BPF_FindTutorialActor");

	Params::TutorialManager_BPF_FindTutorialActor Parms{};

	Parms._tag = std::move(_tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialManager.BPF_GetCurrentStepNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATutorialManager::BPF_GetCurrentStepNumber() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "BPF_GetCurrentStepNumber");

	Params::TutorialManager_BPF_GetCurrentStepNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialManager.BPF_GetObjectiveCountInCurrentStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATutorialManager::BPF_GetObjectiveCountInCurrentStep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "BPF_GetObjectiveCountInCurrentStep");

	Params::TutorialManager_BPF_GetObjectiveCountInCurrentStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialManager.BPF_GetObjectiveCountInCurrentStepWithIteration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATutorialManager::BPF_GetObjectiveCountInCurrentStepWithIteration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "BPF_GetObjectiveCountInCurrentStepWithIteration");

	Params::TutorialManager_BPF_GetObjectiveCountInCurrentStepWithIteration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialManager.BPF_GetStepCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATutorialManager::BPF_GetStepCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "BPF_GetStepCount");

	Params::TutorialManager_BPF_GetStepCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialManager.BPF_MoveToNextLevel
// (Final, Native, Public, BlueprintCallable, Const)

void ATutorialManager::BPF_MoveToNextLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "BPF_MoveToNextLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialManager.CanStartTutorialFromInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATutorialManager::CanStartTutorialFromInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "CanStartTutorialFromInput");

	Params::TutorialManager_CanStartTutorialFromInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CrowdSoundState.BPE_CanEnterState
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   _fRawIntensity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrowdSoundState::BPE_CanEnterState(float _fRawIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrowdSoundState", "BPE_CanEnterState");

	Params::CrowdSoundState_BPE_CanEnterState Parms{};

	Parms._fRawIntensity = _fRawIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CrowdSoundState.BPE_CanLeaveState
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   _fRawIntensity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrowdSoundState::BPE_CanLeaveState(float _fRawIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrowdSoundState", "BPE_CanLeaveState");

	Params::CrowdSoundState_BPE_CanLeaveState Parms{};

	Parms._fRawIntensity = _fRawIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CrowdSoundState.BPE_ComputeIntensity
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   _fComputeRate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fRawIntensity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fOldMatchIntensity                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrowdSoundState::BPE_ComputeIntensity(float _fComputeRate, float _fRawIntensity, float _fOldMatchIntensity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrowdSoundState", "BPE_ComputeIntensity");

	Params::CrowdSoundState_BPE_ComputeIntensity Parms{};

	Parms._fComputeRate = _fComputeRate;
	Parms._fRawIntensity = _fRawIntensity;
	Parms._fOldMatchIntensity = _fOldMatchIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CrowdSoundState.BPE_GetComputeDebugDisplay
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrowdSoundState::BPE_GetComputeDebugDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrowdSoundState", "BPE_GetComputeDebugDisplay");

	Params::CrowdSoundState_BPE_GetComputeDebugDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CrowdSoundState.BPE_GetEnterDebugDisplay
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrowdSoundState::BPE_GetEnterDebugDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrowdSoundState", "BPE_GetEnterDebugDisplay");

	Params::CrowdSoundState_BPE_GetEnterDebugDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CrowdSoundState.BPE_GetLeaveDebugDisplay
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrowdSoundState::BPE_GetLeaveDebugDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrowdSoundState", "BPE_GetLeaveDebugDisplay");

	Params::CrowdSoundState_BPE_GetLeaveDebugDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationUICategoryViewModel.BPF_GetChildCategoryFromTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              _UITag                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCustomizationUICategoryViewModel*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCustomizationUICategoryViewModel* UCustomizationUICategoryViewModel::BPF_GetChildCategoryFromTag(const struct FGameplayTag& _UITag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationUICategoryViewModel", "BPF_GetChildCategoryFromTag");

	Params::CustomizationUICategoryViewModel_BPF_GetChildCategoryFromTag Parms{};

	Parms._UITag = std::move(_UITag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationUICategoryViewModel.BPF_GetCustoId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSCCustomizationId               ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSCCustomizationId UCustomizationUICategoryViewModel::BPF_GetCustoId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationUICategoryViewModel", "BPF_GetCustoId");

	Params::CustomizationUICategoryViewModel_BPF_GetCustoId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationUICategoryViewModel.GetTitles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UCustomizationUICategoryViewModel::GetTitles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationUICategoryViewModel", "GetTitles");

	Params::CustomizationUICategoryViewModel_GetTitles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShopItemViewModel.BPF_GetCustoId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSCCustomizationId               ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSCCustomizationId UShopItemViewModel::BPF_GetCustoId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopItemViewModel", "BPF_GetCustoId");

	Params::ShopItemViewModel_BPF_GetCustoId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShopItemViewModel.BPF_GetSOSItemViewModel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class USOSBindingsStoreItemViewModel*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USOSBindingsStoreItemViewModel* UShopItemViewModel::BPF_GetSOSItemViewModel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopItemViewModel", "BPF_GetSOSItemViewModel");

	Params::ShopItemViewModel_BPF_GetSOSItemViewModel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShopItemViewModel.BPF_GetUniqueID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UShopItemViewModel::BPF_GetUniqueID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopItemViewModel", "BPF_GetUniqueID");

	Params::ShopItemViewModel_BPF_GetUniqueID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShopItemViewModel.BPF_IsAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShopItemViewModel::BPF_IsAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopItemViewModel", "BPF_IsAvailable");

	Params::ShopItemViewModel_BPF_IsAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShopItemViewModel.BPF_IsOwned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShopItemViewModel::BPF_IsOwned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopItemViewModel", "BPF_IsOwned");

	Params::ShopItemViewModel_BPF_IsOwned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPE_OnGameFlowCustomizationStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    _bWasInMenu                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPE_OnGameFlowCustomizationStateChanged(bool _bWasInMenu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPE_OnGameFlowCustomizationStateChanged");

	Params::CustomizationSubsystem_BPE_OnGameFlowCustomizationStateChanged Parms{};

	Parms._bWasInMenu = _bWasInMenu;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.CustomizationSubsystem.BPE_SetCurrentCustomizationIDs
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FSCCustomizationId>&_ids                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FShopItem>&         _items                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPE_SetCurrentCustomizationIDs(const TArray<struct FSCCustomizationId>& _ids, const TArray<struct FShopItem>& _items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPE_SetCurrentCustomizationIDs");

	Params::CustomizationSubsystem_BPE_SetCurrentCustomizationIDs Parms{};

	Parms._ids = std::move(_ids);
	Parms._items = std::move(_items);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.CustomizationSubsystem.BPF_AddItemInCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UCustomizationUICategoryViewModel*_categoryViewModel                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomizationSubsystem::BPF_AddItemInCategory(const class UCustomizationUICategoryViewModel* _categoryViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_AddItemInCategory");

	Params::CustomizationSubsystem_BPF_AddItemInCategory Parms{};

	Parms._categoryViewModel = _categoryViewModel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_AddPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationSubsystem::BPF_AddPreset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_AddPreset");

	Params::CustomizationSubsystem_BPF_AddPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_CancelPreview
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    _bCancelPresetPreview                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_CancelPreview(bool _bCancelPresetPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_CancelPreview");

	Params::CustomizationSubsystem_BPF_CancelPreview Parms{};

	Parms._bCancelPresetPreview = _bCancelPresetPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_CopyPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   _iFromPreset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _iToPreset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_CopyPreset(int32 _iFromPreset, int32 _iToPreset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_CopyPreset");

	Params::CustomizationSubsystem_BPF_CopyPreset Parms{};

	Parms._iFromPreset = _iFromPreset;
	Parms._iToPreset = _iToPreset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_EditPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   _iPresetIndexToEdit                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_EditPreset(int32 _iPresetIndexToEdit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_EditPreset");

	Params::CustomizationSubsystem_BPF_EditPreset Parms{};

	Parms._iPresetIndexToEdit = _iPresetIndexToEdit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_PreviewFromSOSID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    _previewSOSID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    _cinematicSOSID                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_PreviewFromSOSID(const class FString& _previewSOSID, const class FString& _cinematicSOSID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_PreviewFromSOSID");

	Params::CustomizationSubsystem_BPF_PreviewFromSOSID Parms{};

	Parms._previewSOSID = std::move(_previewSOSID);
	Parms._cinematicSOSID = std::move(_cinematicSOSID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_RemoveItemFromCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UShopItemViewModel*         _itemViewModel                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationSubsystem::BPF_RemoveItemFromCategory(const class UShopItemViewModel* _itemViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_RemoveItemFromCategory");

	Params::CustomizationSubsystem_BPF_RemoveItemFromCategory Parms{};

	Parms._itemViewModel = _itemViewModel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_RemovePreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   _iPresetIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationSubsystem::BPF_RemovePreset(int32 _iPresetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_RemovePreset");

	Params::CustomizationSubsystem_BPF_RemovePreset Parms{};

	Parms._iPresetIndex = _iPresetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_RequestSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    _bLocalOnly                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bClearLocalSave                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_RequestSave(bool _bLocalOnly, bool _bClearLocalSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_RequestSave");

	Params::CustomizationSubsystem_BPF_RequestSave Parms{};

	Parms._bLocalOnly = _bLocalOnly;
	Parms._bClearLocalSave = _bClearLocalSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_ResetEditingPresetToDefault
// (Final, Native, Public, BlueprintCallable)

void UCustomizationSubsystem::BPF_ResetEditingPresetToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_ResetEditingPresetToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_SetColorPaletteToUse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    _bUseHome                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_SetColorPaletteToUse(bool _bUseHome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_SetColorPaletteToUse");

	Params::CustomizationSubsystem_BPF_SetColorPaletteToUse Parms{};

	Parms._bUseHome = _bUseHome;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_SetCurrentPresetIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   _iPresetIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bIsPreview                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_SetCurrentPresetIndex(int32 _iPresetIndex, bool _bIsPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_SetCurrentPresetIndex");

	Params::CustomizationSubsystem_BPF_SetCurrentPresetIndex Parms{};

	Parms._iPresetIndex = _iPresetIndex;
	Parms._bIsPreview = _bIsPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_SetDescription
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSCCharacterCustomizationDescription&_customizationDescription                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bIsPreview                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bForce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_SetDescription(const struct FSCCharacterCustomizationDescription& _customizationDescription, bool _bIsPreview, bool _bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_SetDescription");

	Params::CustomizationSubsystem_BPF_SetDescription Parms{};

	Parms._customizationDescription = std::move(_customizationDescription);
	Parms._bIsPreview = _bIsPreview;
	Parms._bForce = _bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_SetFilterActivated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TSubclassOf<class UShopItemFilter>_filterClass                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bIsActivated                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_SetFilterActivated(const TSubclassOf<class UShopItemFilter> _filterClass, bool _bIsActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_SetFilterActivated");

	Params::CustomizationSubsystem_BPF_SetFilterActivated Parms{};

	Parms._filterClass = _filterClass;
	Parms._bIsActivated = _bIsActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_SetValueFromCategoryViewModel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UCustomizationUICategoryViewModel*_categoryViewModel                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bIsPreview                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_SetValueFromCategoryViewModel(const class UCustomizationUICategoryViewModel* _categoryViewModel, float _fValue, bool _bIsPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_SetValueFromCategoryViewModel");

	Params::CustomizationSubsystem_BPF_SetValueFromCategoryViewModel Parms{};

	Parms._categoryViewModel = _categoryViewModel;
	Parms._fValue = _fValue;
	Parms._bIsPreview = _bIsPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_SetValueFromItemViewModel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UShopItemViewModel*         _shopItemViewModel                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bIsPreview                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bUpdateAchievement                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_SetValueFromItemViewModel(const class UShopItemViewModel* _shopItemViewModel, bool _bIsPreview, bool _bUpdateAchievement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_SetValueFromItemViewModel");

	Params::CustomizationSubsystem_BPF_SetValueFromItemViewModel Parms{};

	Parms._shopItemViewModel = _shopItemViewModel;
	Parms._bIsPreview = _bIsPreview;
	Parms._bUpdateAchievement = _bUpdateAchievement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.OnSOSConnected
// (Final, Native, Private)
// Parameters:
// bool                                    _bSuccessful                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::OnSOSConnected(bool _bSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "OnSOSConnected");

	Params::CustomizationSubsystem_OnSOSConnected Parms{};

	Parms._bSuccessful = _bSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.CustomizationSubsystem.BPF_GetCurrentCustomizationState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UCustomizationSubsystem::BPF_GetCurrentCustomizationState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetCurrentCustomizationState");

	Params::CustomizationSubsystem_BPF_GetCurrentCustomizationState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_GetEditingDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSCCharacterCustomizationDescriptionReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FSCCharacterCustomizationDescription UCustomizationSubsystem::BPF_GetEditingDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetEditingDescription");

	Params::CustomizationSubsystem_BPF_GetEditingDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_GetFirstColorDifferentFromPalette
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FColorPalette&             _excludingPalette                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USCColorListDataAsset*      _overridingColorList                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UCustomizationSubsystem::BPF_GetFirstColorDifferentFromPalette(const struct FColorPalette& _excludingPalette, const class USCColorListDataAsset* _overridingColorList) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetFirstColorDifferentFromPalette");

	Params::CustomizationSubsystem_BPF_GetFirstColorDifferentFromPalette Parms{};

	Parms._excludingPalette = std::move(_excludingPalette);
	Parms._overridingColorList = _overridingColorList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_GetFirstColorDifferentFromPaletteAsIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FColorPalette&             _excludingPalette                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomizationSubsystem::BPF_GetFirstColorDifferentFromPaletteAsIndex(const struct FColorPalette& _excludingPalette) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetFirstColorDifferentFromPaletteAsIndex");

	Params::CustomizationSubsystem_BPF_GetFirstColorDifferentFromPaletteAsIndex Parms{};

	Parms._excludingPalette = std::move(_excludingPalette);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_GetFirstPaletteAssetDifferentFromPalette
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FColorPalette&             _excludingPalette                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UColorPaletteDataAsset*>&_paletteList                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class UColorPaletteDataAsset*     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UColorPaletteDataAsset* UCustomizationSubsystem::BPF_GetFirstPaletteAssetDifferentFromPalette(const struct FColorPalette& _excludingPalette, const TArray<class UColorPaletteDataAsset*>& _paletteList) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetFirstPaletteAssetDifferentFromPalette");

	Params::CustomizationSubsystem_BPF_GetFirstPaletteAssetDifferentFromPalette Parms{};

	Parms._excludingPalette = std::move(_excludingPalette);
	Parms._paletteList = std::move(_paletteList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_GetFirstPaletteDifferentFromPalette
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FColorPalette&             _excludingPalette                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FColorPalette>&     _paletteList                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomizationSubsystem::BPF_GetFirstPaletteDifferentFromPalette(const struct FColorPalette& _excludingPalette, const TArray<struct FColorPalette>& _paletteList) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetFirstPaletteDifferentFromPalette");

	Params::CustomizationSubsystem_BPF_GetFirstPaletteDifferentFromPalette Parms{};

	Parms._excludingPalette = std::move(_excludingPalette);
	Parms._paletteList = std::move(_paletteList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_GetItemsFromSosId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    _sosId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FShopItem>*               _outItems                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_GetItemsFromSosId(const class FString& _sosId, TArray<struct FShopItem>* _outItems) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetItemsFromSosId");

	Params::CustomizationSubsystem_BPF_GetItemsFromSosId Parms{};

	Parms._sosId = std::move(_sosId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outItems != nullptr)
		*_outItems = std::move(Parms._outItems);
}


// Function Runtime.CustomizationSubsystem.BPF_GetMaxPresetCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomizationSubsystem::BPF_GetMaxPresetCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetMaxPresetCount");

	Params::CustomizationSubsystem_BPF_GetMaxPresetCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_GetMostDifferentColorFromColors
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FLinearColor>&      _excludingColors                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class USCColorListDataAsset*      _overridingColorList                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UCustomizationSubsystem::BPF_GetMostDifferentColorFromColors(const TArray<struct FLinearColor>& _excludingColors, const class USCColorListDataAsset* _overridingColorList) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetMostDifferentColorFromColors");

	Params::CustomizationSubsystem_BPF_GetMostDifferentColorFromColors Parms{};

	Parms._excludingColors = std::move(_excludingColors);
	Parms._overridingColorList = _overridingColorList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_GetParameterDisplaySettings
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCharacterPartEnumHandler& _eCharacterPart                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      _parameterName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomizationParameterDisplaySettings*_outParameterDisplaySettings                           (Parm, OutParm, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_GetParameterDisplaySettings(const struct FCharacterPartEnumHandler& _eCharacterPart, const class FName& _parameterName, struct FCustomizationParameterDisplaySettings* _outParameterDisplaySettings) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetParameterDisplaySettings");

	Params::CustomizationSubsystem_BPF_GetParameterDisplaySettings Parms{};

	Parms._eCharacterPart = std::move(_eCharacterPart);
	Parms._parameterName = _parameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outParameterDisplaySettings != nullptr)
		*_outParameterDisplaySettings = std::move(Parms._outParameterDisplaySettings);
}


// Function Runtime.CustomizationSubsystem.BPF_GetPossibleValues
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECustomizationUICategoryType            _eType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSCCustomizationId&        _customizationID                                       (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FShopItem>*               _outItems                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FFloatInterval*                  _fOutInterval                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSubsystem::BPF_GetPossibleValues(ECustomizationUICategoryType _eType, const struct FSCCustomizationId& _customizationID, TArray<struct FShopItem>* _outItems, struct FFloatInterval* _fOutInterval) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetPossibleValues");

	Params::CustomizationSubsystem_BPF_GetPossibleValues Parms{};

	Parms._eType = _eType;
	Parms._customizationID = std::move(_customizationID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outItems != nullptr)
		*_outItems = std::move(Parms._outItems);

	if (_fOutInterval != nullptr)
		*_fOutInterval = std::move(Parms._fOutInterval);
}


// Function Runtime.CustomizationSubsystem.BPF_GetPresetCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomizationSubsystem::BPF_GetPresetCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetPresetCount");

	Params::CustomizationSubsystem_BPF_GetPresetCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_GetShopItemFromItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSoftObjectPtr<class UObject>&    _item                                                  (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShopItem*                       _outShopItem                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// const struct FSCCustomizationId&        _customizationID                                       (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationSubsystem::BPF_GetShopItemFromItem(const TSoftObjectPtr<class UObject>& _item, struct FShopItem* _outShopItem, const struct FSCCustomizationId& _customizationID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_GetShopItemFromItem");

	Params::CustomizationSubsystem_BPF_GetShopItemFromItem Parms{};

	Parms._item = _item;
	Parms._customizationID = std::move(_customizationID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outShopItem != nullptr)
		*_outShopItem = std::move(Parms._outShopItem);

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_IsColorDifferentFromPalette
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLinearColor&              _colorToCheck                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColorPalette&             _excludingPalette                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationSubsystem::BPF_IsColorDifferentFromPalette(const struct FLinearColor& _colorToCheck, const struct FColorPalette& _excludingPalette) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_IsColorDifferentFromPalette");

	Params::CustomizationSubsystem_BPF_IsColorDifferentFromPalette Parms{};

	Parms._colorToCheck = std::move(_colorToCheck);
	Parms._excludingPalette = std::move(_excludingPalette);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_IsColorPairAllowed
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLinearColor&              _color0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              _color1                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationSubsystem::BPF_IsColorPairAllowed(const struct FLinearColor& _color0, const struct FLinearColor& _color1) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_IsColorPairAllowed");

	Params::CustomizationSubsystem_BPF_IsColorPairAllowed Parms{};

	Parms._color0 = std::move(_color0);
	Parms._color1 = std::move(_color1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_IsInCustomizationMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationSubsystem::BPF_IsInCustomizationMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_IsInCustomizationMenu");

	Params::CustomizationSubsystem_BPF_IsInCustomizationMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CustomizationSubsystem.BPF_IsPaletteDifferentFromPalette
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FColorPalette&             _paletteToCheck                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColorPalette&             _excludingPalette                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizationSubsystem::BPF_IsPaletteDifferentFromPalette(const struct FColorPalette& _paletteToCheck, const struct FColorPalette& _excludingPalette) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSubsystem", "BPF_IsPaletteDifferentFromPalette");

	Params::CustomizationSubsystem_BPF_IsPaletteDifferentFromPalette Parms{};

	Parms._paletteToCheck = std::move(_paletteToCheck);
	Parms._excludingPalette = std::move(_excludingPalette);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchDangerComputation.BPE_ComputeValue
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const class ARuntimeGameState*          _gameState                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   _uiDefendingTeam                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   _uiBallOwningTeam                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   _vDefendingTeamGoalLocation                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   _vBallOwningTeamGoalLocation                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   _vBallLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchDangerComputation::BPE_ComputeValue(const class ARuntimeGameState* _gameState, uint8 _uiDefendingTeam, uint8 _uiBallOwningTeam, const struct FVector& _vDefendingTeamGoalLocation, const struct FVector& _vBallOwningTeamGoalLocation, const struct FVector& _vBallLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchDangerComputation", "BPE_ComputeValue");

	Params::MatchDangerComputation_BPE_ComputeValue Parms{};

	Parms._gameState = _gameState;
	Parms._uiDefendingTeam = _uiDefendingTeam;
	Parms._uiBallOwningTeam = _uiBallOwningTeam;
	Parms._vDefendingTeamGoalLocation = std::move(_vDefendingTeamGoalLocation);
	Parms._vBallOwningTeamGoalLocation = std::move(_vBallOwningTeamGoalLocation);
	Parms._vBallLocation = std::move(_vBallLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchDangerComputation.BPE_Deinitialize
// (Native, Event, Public, BlueprintEvent)

void UMatchDangerComputation::BPE_Deinitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchDangerComputation", "BPE_Deinitialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchDangerComputation.BPE_Initialize
// (Native, Event, Public, BlueprintEvent)

void UMatchDangerComputation::BPE_Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchDangerComputation", "BPE_Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.EffectAttributorVolume.BPE_AssignCurrentEffectOwner
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           _actor                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectAttributorVolume::BPE_AssignCurrentEffectOwner(class AActor* _actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPE_AssignCurrentEffectOwner");

	Params::EffectAttributorVolume_BPE_AssignCurrentEffectOwner Parms{};

	Parms._actor = _actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.EffectAttributorVolume.BPE_CantRemoveEffectFromTarget
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           _actor                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectAttributorVolume::BPE_CantRemoveEffectFromTarget(class AActor* _actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPE_CantRemoveEffectFromTarget");

	Params::EffectAttributorVolume_BPE_CantRemoveEffectFromTarget Parms{};

	Parms._actor = _actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.EffectAttributorVolume.BPE_RemoveCurrentEffectOwner
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           _actor                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectAttributorVolume::BPE_RemoveCurrentEffectOwner(class AActor* _actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPE_RemoveCurrentEffectOwner");

	Params::EffectAttributorVolume_BPE_RemoveCurrentEffectOwner Parms{};

	Parms._actor = _actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.EffectAttributorVolume.BPF_AssignEffectToTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           _actor                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectAttributorVolume::BPF_AssignEffectToTarget(class AActor* _actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPF_AssignEffectToTarget");

	Params::EffectAttributorVolume_BPF_AssignEffectToTarget Parms{};

	Parms._actor = _actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.EffectAttributorVolume.BPF_RemoveEffectFromCurrentAndUpdateCurrentOwner
// (Final, Native, Public, BlueprintCallable)

void AEffectAttributorVolume::BPF_RemoveEffectFromCurrentAndUpdateCurrentOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPF_RemoveEffectFromCurrentAndUpdateCurrentOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.EffectAttributorVolume.BPF_RemoveEffectFromCurrentOwner
// (Final, Native, Public, BlueprintCallable)

void AEffectAttributorVolume::BPF_RemoveEffectFromCurrentOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPF_RemoveEffectFromCurrentOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.EffectAttributorVolume.BPF_RemoveEffectFromTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           _actor                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectAttributorVolume::BPF_RemoveEffectFromTarget(class AActor* _actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPF_RemoveEffectFromTarget");

	Params::EffectAttributorVolume_BPF_RemoveEffectFromTarget Parms{};

	Parms._actor = _actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.EffectAttributorVolume.BPF_RemoveEffectFromTargetAndUpdateCurrentOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           _target                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectAttributorVolume::BPF_RemoveEffectFromTargetAndUpdateCurrentOwner(class AActor* _target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPF_RemoveEffectFromTargetAndUpdateCurrentOwner");

	Params::EffectAttributorVolume_BPF_RemoveEffectFromTargetAndUpdateCurrentOwner Parms{};

	Parms._target = _target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.EffectAttributorVolume.BPF_TryReassignEffectToTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           _actor                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEffectAttributorVolume::BPF_TryReassignEffectToTarget(class AActor* _actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPF_TryReassignEffectToTarget");

	Params::EffectAttributorVolume_BPF_TryReassignEffectToTarget Parms{};

	Parms._actor = _actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.EffectAttributorVolume.OnOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              _overlappedComp                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           _otherActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              _otherComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _otherBodyIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bFromSweep                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                _sweepResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AEffectAttributorVolume::OnOverlapBegin(class UPrimitiveComponent* _overlappedComp, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _otherBodyIndex, bool _bFromSweep, const struct FHitResult& _sweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "OnOverlapBegin");

	Params::EffectAttributorVolume_OnOverlapBegin Parms{};

	Parms._overlappedComp = _overlappedComp;
	Parms._otherActor = _otherActor;
	Parms._otherComp = _otherComp;
	Parms._otherBodyIndex = _otherBodyIndex;
	Parms._bFromSweep = _bFromSweep;
	Parms._sweepResult = std::move(_sweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.EffectAttributorVolume.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              _overlappedComp                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           _otherActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              _otherComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _otherBodyIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectAttributorVolume::OnOverlapEnd(class UPrimitiveComponent* _overlappedComp, class AActor* _otherActor, class UPrimitiveComponent* _otherComp, int32 _otherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "OnOverlapEnd");

	Params::EffectAttributorVolume_OnOverlapEnd Parms{};

	Parms._overlappedComp = _overlappedComp;
	Parms._otherActor = _otherActor;
	Parms._otherComp = _otherComp;
	Parms._otherBodyIndex = _otherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.EffectAttributorVolume.BPE_CanAssignEffectToTarget
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEffectAttributorVolume::BPE_CanAssignEffectToTarget(const class AActor* _actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPE_CanAssignEffectToTarget");

	Params::EffectAttributorVolume_BPE_CanAssignEffectToTarget Parms{};

	Parms._actor = _actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.EffectAttributorVolume.BPE_CanRemoveEffectFromTarget
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEffectAttributorVolume::BPE_CanRemoveEffectFromTarget(const class AActor* _actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPE_CanRemoveEffectFromTarget");

	Params::EffectAttributorVolume_BPE_CanRemoveEffectFromTarget Parms{};

	Parms._actor = _actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.EffectAttributorVolume.BPE_CanUseEffectAttributorVolume
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEffectAttributorVolume::BPE_CanUseEffectAttributorVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPE_CanUseEffectAttributorVolume");

	Params::EffectAttributorVolume_BPE_CanUseEffectAttributorVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.EffectAttributorVolume.BPF_CanAssignEffectToTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              _bIgnoreCurrentOwnerCondition                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEffectAttributorVolume::BPF_CanAssignEffectToTarget(const class AActor* _actor, const bool _bIgnoreCurrentOwnerCondition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPF_CanAssignEffectToTarget");

	Params::EffectAttributorVolume_BPF_CanAssignEffectToTarget Parms{};

	Parms._actor = _actor;
	Parms._bIgnoreCurrentOwnerCondition = _bIgnoreCurrentOwnerCondition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.EffectAttributorVolume.BPF_CanRemoveEffectFromTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEffectAttributorVolume::BPF_CanRemoveEffectFromTarget(const class AActor* _actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPF_CanRemoveEffectFromTarget");

	Params::EffectAttributorVolume_BPF_CanRemoveEffectFromTarget Parms{};

	Parms._actor = _actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.EffectAttributorVolume.BPF_CanUseEffectAttributorVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEffectAttributorVolume::BPF_CanUseEffectAttributorVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPF_CanUseEffectAttributorVolume");

	Params::EffectAttributorVolume_BPF_CanUseEffectAttributorVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.EffectAttributorVolume.BPF_IsMatchingCurrentMatchFlowAndStateRequirement
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEffectAttributorVolume::BPF_IsMatchingCurrentMatchFlowAndStateRequirement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPF_IsMatchingCurrentMatchFlowAndStateRequirement");

	Params::EffectAttributorVolume_BPF_IsMatchingCurrentMatchFlowAndStateRequirement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.EffectAttributorVolume.BPF_ShouldLogDetailedInfos
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEffectAttributorVolume::BPF_ShouldLogDetailedInfos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectAttributorVolume", "BPF_ShouldLogDetailedInfos");

	Params::EffectAttributorVolume_BPF_ShouldLogDetailedInfos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.FinisherQuickTimeEventFlowState.OnFinisherInput
// (Final, Native, Public)
// Parameters:
// class APlayerState*                     _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCInputAction*                   _inputAction                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFinisherQuickTimeEventFlowState::OnFinisherInput(class APlayerState* _playerState, class USCInputAction* _inputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinisherQuickTimeEventFlowState", "OnFinisherInput");

	Params::FinisherQuickTimeEventFlowState_OnFinisherInput Parms{};

	Parms._playerState = _playerState;
	Parms._inputAction = _inputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.GoalScoredBinder.OnGoaldScored
// (Final, Native, Protected)
// Parameters:
// const struct FGoalDescription&          _goalDescription                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGoalScoredBinder::OnGoaldScored(const struct FGoalDescription& _goalDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GoalScoredBinder", "OnGoaldScored");

	Params::GoalScoredBinder_OnGoaldScored Parms{};

	Parms._goalDescription = std::move(_goalDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShopItemFilter.BPE_ShouldBeRemoved
// (Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const class UCustomizationSubsystem*    _subsystem                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShopItem&                 _item                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    _bIsActivated                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShopItemFilter::BPE_ShouldBeRemoved(const class UCustomizationSubsystem* _subsystem, const struct FShopItem& _item, bool _bIsActivated) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopItemFilter", "BPE_ShouldBeRemoved");

	Params::ShopItemFilter_BPE_ShouldBeRemoved Parms{};

	Parms._subsystem = _subsystem;
	Parms._item = std::move(_item);
	Parms._bIsActivated = _bIsActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.CharacterHinderingConfig.BPF_GetHinderingConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     _hindering                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     _hindered                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHinderingConfig*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHinderingConfig* UCharacterHinderingConfig::BPF_GetHinderingConfig(const class AActor* _hindering, const class AActor* _hindered) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterHinderingConfig", "BPF_GetHinderingConfig");

	Params::CharacterHinderingConfig_BPF_GetHinderingConfig Parms{};

	Parms._hindering = _hindering;
	Parms._hindered = _hindered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.HinderingGameplayAbility.OnPlayerStateRemoved
// (Final, Native, Public)
// Parameters:
// class APlayerState*                     _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHinderingGameplayAbility::OnPlayerStateRemoved(class APlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HinderingGameplayAbility", "OnPlayerStateRemoved");

	Params::HinderingGameplayAbility_OnPlayerStateRemoved Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.HinderingGameplayAbility.ServerNotifyHindering
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APlayerState*                     _player                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fClientServerTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fTimeSinceLastServerTime                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHinderingGameplayAbility::ServerNotifyHindering(class APlayerState* _player, float _fClientServerTime, float _fTimeSinceLastServerTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HinderingGameplayAbility", "ServerNotifyHindering");

	Params::HinderingGameplayAbility_ServerNotifyHindering Parms{};

	Parms._player = _player;
	Parms._fClientServerTime = _fClientServerTime;
	Parms._fTimeSinceLastServerTime = _fTimeSinceLastServerTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.HinderingGameplayAbility.ServerNotifyHinderingFast
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APlayerState*                     _player                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fClientServerTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHinderingGameplayAbility::ServerNotifyHinderingFast(class APlayerState* _player, float _fClientServerTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HinderingGameplayAbility", "ServerNotifyHinderingFast");

	Params::HinderingGameplayAbility_ServerNotifyHinderingFast Parms{};

	Parms._player = _player;
	Parms._fClientServerTime = _fClientServerTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.HinderingGameplayAbility.ServerNotifyHinderingStop
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APlayerState*                     _player                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHinderingGameplayAbility::ServerNotifyHinderingStop(class APlayerState* _player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HinderingGameplayAbility", "ServerNotifyHinderingStop");

	Params::HinderingGameplayAbility_ServerNotifyHinderingStop Parms{};

	Parms._player = _player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.HUDRegisterableInterface.RegisterToHUD
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UHUD_Widget*                      _HUD                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IHUDRegisterableInterface::RegisterToHUD(class UHUD_Widget* _HUD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("HUDRegisterableInterface", "RegisterToHUD");

	Params::HUDRegisterableInterface_RegisterToHUD Parms{};

	Parms._HUD = _HUD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchCountdownOverBinder.OnMatchCountdownOver
// (Final, Native, Protected)
// Parameters:
// class ARuntimeMatchGameState*           _matchGameState                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchCountdownOverBinder::OnMatchCountdownOver(class ARuntimeMatchGameState* _matchGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchCountdownOverBinder", "OnMatchCountdownOver");

	Params::MatchCountdownOverBinder_OnMatchCountdownOver Parms{};

	Parms._matchGameState = _matchGameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchEffectSubsystem.BPF_RegisterCrowdBEDSEmitter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAkComponent*                     _emitter                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchEffectSubsystem::BPF_RegisterCrowdBEDSEmitter(class UAkComponent* _emitter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchEffectSubsystem", "BPF_RegisterCrowdBEDSEmitter");

	Params::MatchEffectSubsystem_BPF_RegisterCrowdBEDSEmitter Parms{};

	Parms._emitter = _emitter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchEffectSubsystem.BPF_UnregisterCrowdBEDSEmitter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAkComponent*                     _emitter                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchEffectSubsystem::BPF_UnregisterCrowdBEDSEmitter(class UAkComponent* _emitter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchEffectSubsystem", "BPF_UnregisterCrowdBEDSEmitter");

	Params::MatchEffectSubsystem_BPF_UnregisterCrowdBEDSEmitter Parms{};

	Parms._emitter = _emitter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchEffectSubsystem.OnBallEngaged
// (Final, Native, Protected)
// Parameters:
// class ARuntimePlayerState*              _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchEffectSubsystem::OnBallEngaged(class ARuntimePlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchEffectSubsystem", "OnBallEngaged");

	Params::MatchEffectSubsystem_OnBallEngaged Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchEffectSubsystem.OnBallRegistered
// (Final, Native, Protected)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchEffectSubsystem::OnBallRegistered(class ABall* _ball)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchEffectSubsystem", "OnBallRegistered");

	Params::MatchEffectSubsystem_OnBallRegistered Parms{};

	Parms._ball = _ball;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MatchEffectSubsystem.BPF_GetCrowdIntensityValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchEffectSubsystem::BPF_GetCrowdIntensityValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchEffectSubsystem", "BPF_GetCrowdIntensityValue");

	Params::MatchEffectSubsystem_BPF_GetCrowdIntensityValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MatchEffectSubsystem.BPF_GetMatchDangerValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMatchEffectSubsystem::BPF_GetMatchDangerValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchEffectSubsystem", "BPF_GetMatchDangerValue");

	Params::MatchEffectSubsystem_BPF_GetMatchDangerValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MaterialHelperLibrary.BPF_ApplyMaterialParametersOnMesh
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   _meshComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMaterialParametersStruct& _materialParamsStruct                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMaterialHelperLibrary::BPF_ApplyMaterialParametersOnMesh(class UMeshComponent* _meshComponent, const struct FMaterialParametersStruct& _materialParamsStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialHelperLibrary", "BPF_ApplyMaterialParametersOnMesh");

	Params::MaterialHelperLibrary_BPF_ApplyMaterialParametersOnMesh Parms{};

	Parms._meshComponent = _meshComponent;
	Parms._materialParamsStruct = std::move(_materialParamsStruct);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MaterialHelperLibrary.BPF_ApplyMaterialParametersStructOnMaterial
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         _materialInstance                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMaterialParametersStruct& _materialParamsStruct                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMaterialHelperLibrary::BPF_ApplyMaterialParametersStructOnMaterial(class UMaterialInstanceDynamic* _materialInstance, const struct FMaterialParametersStruct& _materialParamsStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialHelperLibrary", "BPF_ApplyMaterialParametersStructOnMaterial");

	Params::MaterialHelperLibrary_BPF_ApplyMaterialParametersStructOnMaterial Parms{};

	Parms._materialInstance = _materialInstance;
	Parms._materialParamsStruct = std::move(_materialParamsStruct);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.MaterialHelperLibrary.BPF_AsFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   _Value                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaterialHelperLibrary::BPF_AsFloat(int32 _Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialHelperLibrary", "BPF_AsFloat");

	Params::MaterialHelperLibrary_BPF_AsFloat Parms{};

	Parms._Value = _Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MaterialHelperLibrary.BPF_AsInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   _Value                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMaterialHelperLibrary::BPF_AsInt(float _Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialHelperLibrary", "BPF_AsInt");

	Params::MaterialHelperLibrary_BPF_AsInt Parms{};

	Parms._Value = _Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MaterialHelperLibrary.BPF_GetTextureFromSkeletalMeshMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMesh*                    _skeletalMesh                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             _textureName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _iMaterialIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UMaterialHelperLibrary::BPF_GetTextureFromSkeletalMeshMaterial(class USkeletalMesh* _skeletalMesh, class FName _textureName, int32 _iMaterialIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialHelperLibrary", "BPF_GetTextureFromSkeletalMeshMaterial");

	Params::MaterialHelperLibrary_BPF_GetTextureFromSkeletalMeshMaterial Parms{};

	Parms._skeletalMesh = _skeletalMesh;
	Parms._textureName = _textureName;
	Parms._iMaterialIndex = _iMaterialIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.VoiceChatGameOption.BPF_GetVoiceChatGameOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ASCBasePlayerController*          _controller                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoiceChatOptions                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVoiceChatOptions UVoiceChatGameOption::BPF_GetVoiceChatGameOption(class ASCBasePlayerController* _controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoiceChatGameOption", "BPF_GetVoiceChatGameOption");

	Params::VoiceChatGameOption_BPF_GetVoiceChatGameOption Parms{};

	Parms._controller = _controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.VoiceChatGameOption.BPF_SetVoiceChatGameOption
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ASCBasePlayerController*          _controller                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoiceChatOptions                       _eInOption                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bSave                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoiceChatGameOption::BPF_SetVoiceChatGameOption(class ASCBasePlayerController* _controller, EVoiceChatOptions _eInOption, bool _bSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoiceChatGameOption", "BPF_SetVoiceChatGameOption");

	Params::VoiceChatGameOption_BPF_SetVoiceChatGameOption Parms{};

	Parms._controller = _controller;
	Parms._eInOption = _eInOption;
	Parms._bSave = _bSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.VoiceChatGameOption.BPF_ToggleDeafenSelf
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ASCBasePlayerController*          _controller                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bSave                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoiceChatGameOption::BPF_ToggleDeafenSelf(class ASCBasePlayerController* _controller, bool _bSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoiceChatGameOption", "BPF_ToggleDeafenSelf");

	Params::VoiceChatGameOption_BPF_ToggleDeafenSelf Parms{};

	Parms._controller = _controller;
	Parms._bSave = _bSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.VoiceChatGameOption.BPF_ToggleMuteSelf
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ASCBasePlayerController*          _controller                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bSave                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoiceChatGameOption::BPF_ToggleMuteSelf(class ASCBasePlayerController* _controller, bool _bSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoiceChatGameOption", "BPF_ToggleMuteSelf");

	Params::VoiceChatGameOption_BPF_ToggleMuteSelf Parms{};

	Parms._controller = _controller;
	Parms._bSave = _bSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PingBinder.OnPingTriggered
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FPingStateDescription&     _pingState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPingBinder::OnPingTriggered(const struct FPingStateDescription& _pingState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PingBinder", "OnPingTriggered");

	Params::PingBinder_OnPingTriggered Parms{};

	Parms._pingState = std::move(_pingState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PlayerJoinBinder.OnPlayerAdded
// (Final, Native, Protected)
// Parameters:
// class APlayerState*                     _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerJoinBinder::OnPlayerAdded(class APlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinBinder", "OnPlayerAdded");

	Params::PlayerJoinBinder_OnPlayerAdded Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PlayerJoinBinder.OnPlayerRemoved
// (Final, Native, Protected)
// Parameters:
// class APlayerState*                     _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerJoinBinder::OnPlayerRemoved(class APlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinBinder", "OnPlayerRemoved");

	Params::PlayerJoinBinder_OnPlayerRemoved Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PlayerLeftBinder.OnPlayerRemoved
// (Final, Native, Protected)
// Parameters:
// class APlayerState*                     _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerLeftBinder::OnPlayerRemoved(class APlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLeftBinder", "OnPlayerRemoved");

	Params::PlayerLeftBinder_OnPlayerRemoved Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootModifier.BPE_ApplyAngle
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _ShootData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float*                                  _fPitch                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EApplyMode*                             _PitchApplyMode                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  _fYaw                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EApplyMode*                             _YawApplyMode                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootModifier::BPE_ApplyAngle(const class AActor* _actor, const struct FShootPrepTargetData& _ShootData, float* _fPitch, EApplyMode* _PitchApplyMode, float* _fYaw, EApplyMode* _YawApplyMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootModifier", "BPE_ApplyAngle");

	Params::ShootModifier_BPE_ApplyAngle Parms{};

	Parms._actor = _actor;
	Parms._ShootData = std::move(_ShootData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_fPitch != nullptr)
		*_fPitch = Parms._fPitch;

	if (_PitchApplyMode != nullptr)
		*_PitchApplyMode = Parms._PitchApplyMode;

	if (_fYaw != nullptr)
		*_fYaw = Parms._fYaw;

	if (_YawApplyMode != nullptr)
		*_YawApplyMode = Parms._YawApplyMode;
}


// Function Runtime.ShootModifier.BPE_ApplyMultiplierForce
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _ShootData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootModifier::BPE_ApplyMultiplierForce(const class AActor* _actor, const struct FShootPrepTargetData& _ShootData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootModifier", "BPE_ApplyMultiplierForce");

	Params::ShootModifier_BPE_ApplyMultiplierForce Parms{};

	Parms._actor = _actor;
	Parms._ShootData = std::move(_ShootData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootModifier.BPE_ApplyMultiplierRotationForce
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _ShootData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EMagnusType*                            _MagnusToApply                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootModifier::BPE_ApplyMultiplierRotationForce(const class AActor* _actor, const struct FShootPrepTargetData& _ShootData, EMagnusType* _MagnusToApply) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootModifier", "BPE_ApplyMultiplierRotationForce");

	Params::ShootModifier_BPE_ApplyMultiplierRotationForce Parms{};

	Parms._actor = _actor;
	Parms._ShootData = std::move(_ShootData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_MagnusToApply != nullptr)
		*_MagnusToApply = Parms._MagnusToApply;

	return Parms.ReturnValue;
}


// Function Runtime.PlayerProfileHelpers.BPF_SetCategoryAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPlayerProfileDescription&       _description                                           (Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerProfileCategoryEnumHandler&_eCategory                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UPlayerProfileBaseAsset>_asset                                                 (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerProfileHelpers::BPF_SetCategoryAsset(struct FPlayerProfileDescription& _description, const struct FPlayerProfileCategoryEnumHandler& _eCategory, TSoftObjectPtr<class UPlayerProfileBaseAsset> _asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerProfileHelpers", "BPF_SetCategoryAsset");

	Params::PlayerProfileHelpers_BPF_SetCategoryAsset Parms{};

	Parms._description = std::move(_description);
	Parms._eCategory = std::move(_eCategory);
	Parms._asset = _asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	_description = std::move(Parms._description);
}


// Function Runtime.ThumbnailFunctionLibrary.BPF_ClearThumbnailSceneCache
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// bool                                    bCollectGarbage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThumbnailFunctionLibrary::BPF_ClearThumbnailSceneCache(bool bCollectGarbage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThumbnailFunctionLibrary", "BPF_ClearThumbnailSceneCache");

	Params::ThumbnailFunctionLibrary_BPF_ClearThumbnailSceneCache Parms{};

	Parms.bCollectGarbage = bCollectGarbage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ThumbnailFunctionLibrary.BPF_CreateLevelSequence
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   InLevelSequence                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMovieSceneSequencePlaybackSettings&Settings                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AThumbnailLevelSequenceActor**    OutActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequencePlayer*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelSequencePlayer* UThumbnailFunctionLibrary::BPF_CreateLevelSequence(class UObject* WorldContextObject, class ULevelSequence* InLevelSequence, const struct FMovieSceneSequencePlaybackSettings& Settings, const struct FTransform& Transform, class AThumbnailLevelSequenceActor** OutActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThumbnailFunctionLibrary", "BPF_CreateLevelSequence");

	Params::ThumbnailFunctionLibrary_BPF_CreateLevelSequence Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InLevelSequence = InLevelSequence;
	Parms.Settings = std::move(Settings);
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;

	return Parms.ReturnValue;
}


// Function Runtime.ThumbnailFunctionLibrary.BPF_GetSpawnables
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AThumbnailLevelSequenceActor*     Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> UThumbnailFunctionLibrary::BPF_GetSpawnables(class AThumbnailLevelSequenceActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThumbnailFunctionLibrary", "BPF_GetSpawnables");

	Params::ThumbnailFunctionLibrary_BPF_GetSpawnables Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ThumbnailFunctionLibrary.BPF_ObjectPathToObjectName
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    _objectPath                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UThumbnailFunctionLibrary::BPF_ObjectPathToObjectName(const class FString& _objectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThumbnailFunctionLibrary", "BPF_ObjectPathToObjectName");

	Params::ThumbnailFunctionLibrary_BPF_ObjectPathToObjectName Parms{};

	Parms._objectPath = std::move(_objectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ThumbnailFunctionLibrary.BPF_ReleaseRenderTargets
// (Final, Native, Static, Private, BlueprintCallable)

void UThumbnailFunctionLibrary::BPF_ReleaseRenderTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThumbnailFunctionLibrary", "BPF_ReleaseRenderTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ThumbnailFunctionLibrary.BPF_SetForceMipStreaming
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceMipStreaming                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThumbnailFunctionLibrary::BPF_SetForceMipStreaming(class UPrimitiveComponent* Component, bool bForceMipStreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThumbnailFunctionLibrary", "BPF_SetForceMipStreaming");

	Params::ThumbnailFunctionLibrary_BPF_SetForceMipStreaming Parms{};

	Parms.Component = Component;
	Parms.bForceMipStreaming = bForceMipStreaming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PlayerProfileSubsystem.BPF_RequestSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    _bLocalOnly                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerProfileSubsystem::BPF_RequestSave(bool _bLocalOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "BPF_RequestSave");

	Params::PlayerProfileSubsystem_BPF_RequestSave Parms{};

	Parms._bLocalOnly = _bLocalOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PlayerProfileSubsystem.BPF_SetAssetByViewModel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UShopItemViewModel*               _viewModel                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerProfileSubsystem::BPF_SetAssetByViewModel(class UShopItemViewModel* _viewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "BPF_SetAssetByViewModel");

	Params::PlayerProfileSubsystem_BPF_SetAssetByViewModel Parms{};

	Parms._viewModel = _viewModel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PlayerProfileSubsystem.BPF_SetDescription
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPlayerProfileDescription& _description                                           (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bIsPreview                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bForce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerProfileSubsystem::BPF_SetDescription(const struct FPlayerProfileDescription& _description, bool _bIsPreview, bool _bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "BPF_SetDescription");

	Params::PlayerProfileSubsystem_BPF_SetDescription Parms{};

	Parms._description = std::move(_description);
	Parms._bIsPreview = _bIsPreview;
	Parms._bForce = _bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PlayerProfileSubsystem.BPF_SetWorkshopData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPlayerProfileWorkshopData&_workshopData                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayerProfileSubsystem::BPF_SetWorkshopData(const struct FPlayerProfileWorkshopData& _workshopData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "BPF_SetWorkshopData");

	Params::PlayerProfileSubsystem_BPF_SetWorkshopData Parms{};

	Parms._workshopData = std::move(_workshopData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PlayerProfileSubsystem.OnChangeUnwrittenAchievements
// (Final, Native, Private)

void UPlayerProfileSubsystem::OnChangeUnwrittenAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "OnChangeUnwrittenAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PlayerProfileSubsystem.OnSOSConnected
// (Final, Native, Private)
// Parameters:
// bool                                    _bSuccessful                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerProfileSubsystem::OnSOSConnected(bool _bSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "OnSOSConnected");

	Params::PlayerProfileSubsystem_OnSOSConnected Parms{};

	Parms._bSuccessful = _bSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PlayerProfileSubsystem.BPF_GetAssetFromSosId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    _sosId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> UPlayerProfileSubsystem::BPF_GetAssetFromSosId(const class FString& _sosId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "BPF_GetAssetFromSosId");

	Params::PlayerProfileSubsystem_BPF_GetAssetFromSosId Parms{};

	Parms._sosId = std::move(_sosId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.PlayerProfileSubsystem.BPF_GetCurrentAssetForCategory
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerProfileCategoryEnumHandler&_eCategory                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> UPlayerProfileSubsystem::BPF_GetCurrentAssetForCategory(const struct FPlayerProfileCategoryEnumHandler& _eCategory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "BPF_GetCurrentAssetForCategory");

	Params::PlayerProfileSubsystem_BPF_GetCurrentAssetForCategory Parms{};

	Parms._eCategory = std::move(_eCategory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.PlayerProfileSubsystem.BPF_GetCurrentSosIdForCategory
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerProfileCategoryEnumHandler&_eCategory                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPlayerProfileSubsystem::BPF_GetCurrentSosIdForCategory(const struct FPlayerProfileCategoryEnumHandler& _eCategory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "BPF_GetCurrentSosIdForCategory");

	Params::PlayerProfileSubsystem_BPF_GetCurrentSosIdForCategory Parms{};

	Parms._eCategory = std::move(_eCategory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.PlayerProfileSubsystem.BPF_GetDisplayNameFromSosId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    _sosId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerProfileCategoryEnumHandler&_eCategory                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPlayerProfileSubsystem::BPF_GetDisplayNameFromSosId(const class FString& _sosId, const struct FPlayerProfileCategoryEnumHandler& _eCategory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "BPF_GetDisplayNameFromSosId");

	Params::PlayerProfileSubsystem_BPF_GetDisplayNameFromSosId Parms{};

	Parms._sosId = std::move(_sosId);
	Parms._eCategory = std::move(_eCategory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.PlayerProfileSubsystem.BPF_GetEditingDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerProfileDescription  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FPlayerProfileDescription UPlayerProfileSubsystem::BPF_GetEditingDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "BPF_GetEditingDescription");

	Params::PlayerProfileSubsystem_BPF_GetEditingDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.PlayerProfileSubsystem.BPF_GetTextureFromSosId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    _sosId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerProfileCategoryEnumHandler&_eCategory                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UPlayerProfileSubsystem::BPF_GetTextureFromSosId(const class FString& _sosId, const struct FPlayerProfileCategoryEnumHandler& _eCategory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "BPF_GetTextureFromSosId");

	Params::PlayerProfileSubsystem_BPF_GetTextureFromSosId Parms{};

	Parms._sosId = std::move(_sosId);
	Parms._eCategory = std::move(_eCategory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.PlayerProfileSubsystem.BPF_GetWorkshopData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerProfileWorkshopData ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FPlayerProfileWorkshopData UPlayerProfileSubsystem::BPF_GetWorkshopData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileSubsystem", "BPF_GetWorkshopData");

	Params::PlayerProfileSubsystem_BPF_GetWorkshopData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.PlayerProfileUIInfosAsset.BPF_GeneratePlayerProfileData
// (Native, Public)

void UPlayerProfileUIInfosAsset::BPF_GeneratePlayerProfileData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileUIInfosAsset", "BPF_GeneratePlayerProfileData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PreMatchFlowState.ClientGoToNextState
// (Final, Native, Public)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreMatchFlowState::ClientGoToNextState(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreMatchFlowState", "ClientGoToNextState");

	Params::PreMatchFlowState_ClientGoToNextState Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.PreMatchFlowState.EnteringState
// (Final, Native, Public, HasOutParams)
// Parameters:
// class USCFlowGraphNode*                 _previousState                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCFlowGraphNode*                 _currentState                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSCFlowGraphTransition*          _transition                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UPreMatchFlowState::EnteringState(class USCFlowGraphNode* _previousState, class USCFlowGraphNode* _currentState, struct FSCFlowGraphTransition* _transition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreMatchFlowState", "EnteringState");

	Params::PreMatchFlowState_EnteringState Parms{};

	Parms._previousState = _previousState;
	Parms._currentState = _currentState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_transition != nullptr)
		*_transition = std::move(Parms._transition);
}


// Function Runtime.UsedColorChannelsAssetUserData.BPF_ComputeUsedColorChannels
// (Final, Native, Protected, BlueprintCallable)

void UUsedColorChannelsAssetUserData::BPF_ComputeUsedColorChannels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UsedColorChannelsAssetUserData", "BPF_ComputeUsedColorChannels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RematchCharacterCustomizationComponent.BPF_SetForceSyncLoad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    _bForceSyncLoad                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URematchCharacterCustomizationComponent::BPF_SetForceSyncLoad(bool _bForceSyncLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RematchCharacterCustomizationComponent", "BPF_SetForceSyncLoad");

	Params::RematchCharacterCustomizationComponent_BPF_SetForceSyncLoad Parms{};

	Parms._bForceSyncLoad = _bForceSyncLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RematchCharacterCustomizationComponent.BPF_SetMainWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          _mainWorldContext                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URematchCharacterCustomizationComponent::BPF_SetMainWorld(class UObject* _mainWorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RematchCharacterCustomizationComponent", "BPF_SetMainWorld");

	Params::RematchCharacterCustomizationComponent_BPF_SetMainWorld Parms{};

	Parms._mainWorldContext = _mainWorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RematchMapDataAsset.BPF_GetMapFromNumberOfPlayersPerTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   _iNumberOfPlayerPerTeam                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UWorld>      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const TSoftObjectPtr<class UWorld> URematchMapDataAsset::BPF_GetMapFromNumberOfPlayersPerTeam(int32 _iNumberOfPlayerPerTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RematchMapDataAsset", "BPF_GetMapFromNumberOfPlayersPerTeam");

	Params::RematchMapDataAsset_BPF_GetMapFromNumberOfPlayersPerTeam Parms{};

	Parms._iNumberOfPlayerPerTeam = _iNumberOfPlayerPerTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RematchMapDataAsset.BPF_ContainsLevelPath
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      _levelPath                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URematchMapDataAsset::BPF_ContainsLevelPath(const class FName& _levelPath) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RematchMapDataAsset", "BPF_ContainsLevelPath");

	Params::RematchMapDataAsset_BPF_ContainsLevelPath Parms{};

	Parms._levelPath = _levelPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.VictoryMoodHandlerFlowState.BPF_GetVictoryMoodBindingTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UVictoryMoodHandlerFlowState::BPF_GetVictoryMoodBindingTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictoryMoodHandlerFlowState", "BPF_GetVictoryMoodBindingTag");

	Params::VictoryMoodHandlerFlowState_BPF_GetVictoryMoodBindingTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RematchServerMapFlowState.BPF_GetMapDataAssetIndexFromLevelPath
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      _levelPath                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URematchServerMapFlowState::BPF_GetMapDataAssetIndexFromLevelPath(const class FName& _levelPath) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RematchServerMapFlowState", "BPF_GetMapDataAssetIndexFromLevelPath");

	Params::RematchServerMapFlowState_BPF_GetMapDataAssetIndexFromLevelPath Parms{};

	Parms._levelPath = _levelPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RematchVersionedDataAsset.IncrementVersion
// (Final, Native, Public)

void URematchVersionedDataAsset::IncrementVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RematchVersionedDataAsset", "IncrementVersion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RematchWelcomeFlowDataAsset.AddNews
// (Final, Native, Public)

void URematchWelcomeFlowDataAsset::AddNews()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RematchWelcomeFlowDataAsset", "AddNews");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RematchWelcomeFlowDataAsset.AddSeasonEnd
// (Final, Native, Public)

void URematchWelcomeFlowDataAsset::AddSeasonEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RematchWelcomeFlowDataAsset", "AddSeasonEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RematchWelcomeFlowDataAsset.AddSeasonEndWarning
// (Final, Native, Public)

void URematchWelcomeFlowDataAsset::AddSeasonEndWarning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RematchWelcomeFlowDataAsset", "AddSeasonEndWarning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RematchWelcomeFlowDataAsset.AddSeasonStart
// (Final, Native, Public)

void URematchWelcomeFlowDataAsset::AddSeasonStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RematchWelcomeFlowDataAsset", "AddSeasonStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RoleVolumeAttributor.BPF_FindTeamRoleAttributorVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ACharacter*                 _character                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ARoleVolumeAttributor>_roleVolumeAttributorClass                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARoleVolumeAttributor*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARoleVolumeAttributor* ARoleVolumeAttributor::BPF_FindTeamRoleAttributorVolume(const class ACharacter* _character, TSubclassOf<class ARoleVolumeAttributor> _roleVolumeAttributorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoleVolumeAttributor", "BPF_FindTeamRoleAttributorVolume");

	Params::RoleVolumeAttributor_BPF_FindTeamRoleAttributorVolume Parms{};

	Parms._character = _character;
	Parms._roleVolumeAttributorClass = _roleVolumeAttributorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RoleVolumeAttributor.BPF_GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARoleVolumeAttributor::BPF_GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoleVolumeAttributor", "BPF_GetTeam");

	Params::RoleVolumeAttributor_BPF_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RoleVolumeAttributor.IsSameTeam
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class APawn*                      _pawn                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARoleVolumeAttributor::IsSameTeam(const class APawn* _pawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoleVolumeAttributor", "IsSameTeam");

	Params::RoleVolumeAttributor_IsSameTeam Parms{};

	Parms._pawn = _pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RootMotionModifier_RedirectToBallTrajectory.BPF_GenerateRequiredPayloadForRedirectToBallTrajectory
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class URuntimeShootGameplayAbility*     _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ARuntimeCharacter*          _runtimeCharacter                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_context                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotifyState>     _notifyState                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMotionModifier_RedirectToBallTrajectory::BPF_GenerateRequiredPayloadForRedirectToBallTrajectory(class URuntimeShootGameplayAbility* _owningAbility, const class ARuntimeCharacter* _runtimeCharacter, class ABall* _ball, const struct FGameplayAbilityTargetDataHandle& _context, TSubclassOf<class UAnimNotifyState> _notifyState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RootMotionModifier_RedirectToBallTrajectory", "BPF_GenerateRequiredPayloadForRedirectToBallTrajectory");

	Params::RootMotionModifier_RedirectToBallTrajectory_BPF_GenerateRequiredPayloadForRedirectToBallTrajectory Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._runtimeCharacter = _runtimeCharacter;
	Parms._ball = _ball;
	Parms._context = std::move(_context);
	Parms._notifyState = _notifyState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Workshop.AddScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   _iScoreToAdd                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWorkshop::AddScore(int32 _iScoreToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "AddScore");

	Params::Workshop_AddScore Parms{};

	Parms._iScoreToAdd = _iScoreToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Workshop.BPE_FinishWorkshop
// (Event, Public, BlueprintEvent)

void AWorkshop::BPE_FinishWorkshop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "BPE_FinishWorkshop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.Workshop.BPE_PauseWorkshop
// (Event, Public, BlueprintEvent)

void AWorkshop::BPE_PauseWorkshop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "BPE_PauseWorkshop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.Workshop.BPE_RestartWorkshop
// (Event, Public, BlueprintEvent)

void AWorkshop::BPE_RestartWorkshop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "BPE_RestartWorkshop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.Workshop.BPE_StartWorkshop
// (Event, Public, BlueprintEvent)

void AWorkshop::BPE_StartWorkshop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "BPE_StartWorkshop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.Workshop.BPE_UnpauseWorkshop
// (Event, Public, BlueprintEvent)

void AWorkshop::BPE_UnpauseWorkshop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "BPE_UnpauseWorkshop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.Workshop.BPF_SnapBallToWorkshopUser
// (Final, Native, Public, BlueprintCallable)

void AWorkshop::BPF_SnapBallToWorkshopUser()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "BPF_SnapBallToWorkshopUser");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Workshop.CheckAchievements
// (Final, Native, Public)

void AWorkshop::CheckAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "CheckAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Workshop.FinishWorkshop
// (Final, Native, Public, BlueprintCallable)

void AWorkshop::FinishWorkshop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "FinishWorkshop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Workshop.OnSkipIntroductionInputPressed
// (Final, Native, Public, BlueprintCallable)

void AWorkshop::OnSkipIntroductionInputPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "OnSkipIntroductionInputPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Workshop.PauseWorkshop
// (Final, Native, Public, BlueprintCallable)

void AWorkshop::PauseWorkshop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "PauseWorkshop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Workshop.RequestStartWorkshop
// (Final, Native, Public, BlueprintCallable)

void AWorkshop::RequestStartWorkshop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "RequestStartWorkshop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Workshop.RestartWorkshop
// (Final, Native, Public, BlueprintCallable)

void AWorkshop::RestartWorkshop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "RestartWorkshop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Workshop.UnpauseWorkshop
// (Final, Native, Public, BlueprintCallable)

void AWorkshop::UnpauseWorkshop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "UnpauseWorkshop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.Workshop.BPF_ComputeMedalWithScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   _iScore                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWorkshopMedal                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWorkshopMedal AWorkshop::BPF_ComputeMedalWithScore(int32 _iScore) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "BPF_ComputeMedalWithScore");

	Params::Workshop_BPF_ComputeMedalWithScore Parms{};

	Parms._iScore = _iScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.Workshop.BPF_ComputeMedalWithTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   _fTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWorkshopMedal                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWorkshopMedal AWorkshop::BPF_ComputeMedalWithTime(float _fTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "BPF_ComputeMedalWithTime");

	Params::Workshop_BPF_ComputeMedalWithTime Parms{};

	Parms._fTime = _fTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.Workshop.BPF_GetWorkshopTimer
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AWorkshop::BPF_GetWorkshopTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "BPF_GetWorkshopTimer");

	Params::Workshop_BPF_GetWorkshopTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.Workshop.CanStartWorkshopFromInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWorkshop::CanStartWorkshopFromInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "CanStartWorkshopFromInput");

	Params::Workshop_CanStartWorkshopFromInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.Workshop.GetWorkshopScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AWorkshop::GetWorkshopScore() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "GetWorkshopScore");

	Params::Workshop_GetWorkshopScore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.Workshop.GetWorkshopState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWorkshopState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWorkshopState AWorkshop::GetWorkshopState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Workshop", "GetWorkshopState");

	Params::Workshop_GetWorkshopState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RTBinderRecorder.BPF_Clear
// (Final, Native, Public, BlueprintCallable)

void URTBinderRecorder::BPF_Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTBinderRecorder", "BPF_Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTBinderRecorder.BPF_Sleeping
// (Final, Native, Public, BlueprintCallable)

void URTBinderRecorder::BPF_Sleeping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTBinderRecorder", "BPF_Sleeping");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTBinderRecorder.BPF_WakeUp
// (Final, Native, Public, BlueprintCallable)

void URTBinderRecorder::BPF_WakeUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTBinderRecorder", "BPF_WakeUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTGauntletCoordinatorController.OnGauntletCoordinatorMessage
// (Final, Native, Protected)
// Parameters:
// const class FString&                    _message                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URTGauntletCoordinatorController::OnGauntletCoordinatorMessage(const class FString& _message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGauntletCoordinatorController", "OnGauntletCoordinatorMessage");

	Params::RTGauntletCoordinatorController_OnGauntletCoordinatorMessage Parms{};

	Parms._message = std::move(_message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTControllerOnlineTest.OnLoginFinished
// (Final, Native, Protected)
// Parameters:
// bool                                    _bSuccess                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URTControllerOnlineTest::OnLoginFinished(bool _bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTControllerOnlineTest", "OnLoginFinished");

	Params::RTControllerOnlineTest_OnLoginFinished Parms{};

	Parms._bSuccess = _bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTControllerOnlineTest.OnLogoutFinished
// (Final, Native, Protected)
// Parameters:
// bool                                    _bSuccess                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URTControllerOnlineTest::OnLogoutFinished(bool _bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTControllerOnlineTest", "OnLogoutFinished");

	Params::RTControllerOnlineTest_OnLogoutFinished Parms{};

	Parms._bSuccess = _bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTGameplayPhaseSubsystem.BPF_BackToDefaultCameraBehavior
// (Final, Native, Private, BlueprintCallable)

void URTGameplayPhaseSubsystem::BPF_BackToDefaultCameraBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGameplayPhaseSubsystem", "BPF_BackToDefaultCameraBehavior");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTGameplayPhaseSubsystem.BPF_LaunchReplay
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRTGameplayPhaseContainer& _gameplayPhaseContainer                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const float                             _fStartTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              _bTurnOffRecorder                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URTGameplayPhaseSubsystem::BPF_LaunchReplay(const struct FRTGameplayPhaseContainer& _gameplayPhaseContainer, const float _fStartTime, const bool _bTurnOffRecorder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGameplayPhaseSubsystem", "BPF_LaunchReplay");

	Params::RTGameplayPhaseSubsystem_BPF_LaunchReplay Parms{};

	Parms._gameplayPhaseContainer = std::move(_gameplayPhaseContainer);
	Parms._fStartTime = _fStartTime;
	Parms._bTurnOffRecorder = _bTurnOffRecorder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTGameplayPhaseSubsystem.BPF_NextAlternativeCamera
// (Final, Native, Private, BlueprintCallable)

void URTGameplayPhaseSubsystem::BPF_NextAlternativeCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGameplayPhaseSubsystem", "BPF_NextAlternativeCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTGameplayPhaseSubsystem.BPF_PreviousAlternativeCamera
// (Final, Native, Private, BlueprintCallable)

void URTGameplayPhaseSubsystem::BPF_PreviousAlternativeCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGameplayPhaseSubsystem", "BPF_PreviousAlternativeCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTGameplayPhaseSubsystem.BPF_StopReplay
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// const bool                              _bTurnOnRecorder                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URTGameplayPhaseSubsystem::BPF_StopReplay(const bool _bTurnOnRecorder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGameplayPhaseSubsystem", "BPF_StopReplay");

	Params::RTGameplayPhaseSubsystem_BPF_StopReplay Parms{};

	Parms._bTurnOnRecorder = _bTurnOnRecorder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTGameplayPhaseSubsystem.BPF_GetBinderRecorder
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class URTBinderRecorder*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class URTBinderRecorder* URTGameplayPhaseSubsystem::BPF_GetBinderRecorder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGameplayPhaseSubsystem", "BPF_GetBinderRecorder");

	Params::RTGameplayPhaseSubsystem_BPF_GetBinderRecorder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RTGameplayPhaseSubsystem.BPF_GetCurrentPhaseTag
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag URTGameplayPhaseSubsystem::BPF_GetCurrentPhaseTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGameplayPhaseSubsystem", "BPF_GetCurrentPhaseTag");

	Params::RTGameplayPhaseSubsystem_BPF_GetCurrentPhaseTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RTGameplayPhaseSubsystem.BPF_GetFollowActorFromCurrentPhase
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URTGameplayPhaseSubsystem::BPF_GetFollowActorFromCurrentPhase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGameplayPhaseSubsystem", "BPF_GetFollowActorFromCurrentPhase");

	Params::RTGameplayPhaseSubsystem_BPF_GetFollowActorFromCurrentPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RTGameplayPhaseSubsystem.BPF_TryToGenerateGameplayPhases
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const uint8                             _uiTeamID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             _fOverrideSnapshotDuration                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRTGameplayPhaseContainer        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRTGameplayPhaseContainer URTGameplayPhaseSubsystem::BPF_TryToGenerateGameplayPhases(const uint8 _uiTeamID, const float _fOverrideSnapshotDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGameplayPhaseSubsystem", "BPF_TryToGenerateGameplayPhases");

	Params::RTGameplayPhaseSubsystem_BPF_TryToGenerateGameplayPhases Parms{};

	Parms._uiTeamID = _uiTeamID;
	Parms._fOverrideSnapshotDuration = _fOverrideSnapshotDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RTGauntletCinematicBaseController.OnCameraCut
// (Final, Native, Private)
// Parameters:
// class UCameraComponent*                 CameraComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URTGauntletCinematicBaseController::OnCameraCut(class UCameraComponent* CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGauntletCinematicBaseController", "OnCameraCut");

	Params::RTGauntletCinematicBaseController_OnCameraCut Parms{};

	Parms.CameraComponent = CameraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTGauntletCinematicBaseController.OnSequencePlay
// (Final, Native, Private)

void URTGauntletCinematicBaseController::OnSequencePlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTGauntletCinematicBaseController", "OnSequencePlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RTStadiumARConfig.GetFieldCurveAtlas
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveLinearColorAtlas*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCurveLinearColorAtlas* URTStadiumARConfig::GetFieldCurveAtlas()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTStadiumARConfig", "GetFieldCurveAtlas");

	Params::RTStadiumARConfig_GetFieldCurveAtlas Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RTStadiumARConfig.GetTransitionSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelSequence* URTStadiumARConfig::GetTransitionSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTStadiumARConfig", "GetTransitionSequence");

	Params::RTStadiumARConfig_GetTransitionSequence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RTStadiumARConfig.GetEnvironmentLight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UObject*                    _worldContextObject                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADirectionalLight*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADirectionalLight* URTStadiumARConfig::GetEnvironmentLight(const class UObject* _worldContextObject) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTStadiumARConfig", "GetEnvironmentLight");

	Params::RTStadiumARConfig_GetEnvironmentLight Parms{};

	Parms._worldContextObject = _worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAbilitySystemComponent.BPF_FindRuntimeEffectContextFromGrantedTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRuntimeGameplayEffectContext*   _outContext                                            (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle*     _outHandle                                             (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     _grantedTags                                           (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeAbilitySystemComponent::BPF_FindRuntimeEffectContextFromGrantedTag(struct FRuntimeGameplayEffectContext* _outContext, struct FActiveGameplayEffectHandle* _outHandle, const struct FGameplayTagContainer& _grantedTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAbilitySystemComponent", "BPF_FindRuntimeEffectContextFromGrantedTag");

	Params::RuntimeAbilitySystemComponent_BPF_FindRuntimeEffectContextFromGrantedTag Parms{};

	Parms._grantedTags = std::move(_grantedTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outContext != nullptr)
		*_outContext = std::move(Parms._outContext);

	if (_outHandle != nullptr)
		*_outHandle = std::move(Parms._outHandle);

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAbilitySystemComponent.BPF_FindRuntimeEffectContextWithQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRuntimeGameplayEffectContext*   _outContext                                            (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle*     _outHandle                                             (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectQuery&      _query                                                 (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeAbilitySystemComponent::BPF_FindRuntimeEffectContextWithQuery(struct FRuntimeGameplayEffectContext* _outContext, struct FActiveGameplayEffectHandle* _outHandle, const struct FGameplayEffectQuery& _query)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAbilitySystemComponent", "BPF_FindRuntimeEffectContextWithQuery");

	Params::RuntimeAbilitySystemComponent_BPF_FindRuntimeEffectContextWithQuery Parms{};

	Parms._query = std::move(_query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outContext != nullptr)
		*_outContext = std::move(Parms._outContext);

	if (_outHandle != nullptr)
		*_outHandle = std::move(Parms._outHandle);

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAbilitySystemComponent.BPF_FindActiveRuntimeGameplayEffectContext
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FActiveGameplayEffectHandle>&_handle                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRuntimeGameplayEffectContext*   _outContext                                            (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeAbilitySystemComponent::BPF_FindActiveRuntimeGameplayEffectContext(const TArray<struct FActiveGameplayEffectHandle>& _handle, struct FRuntimeGameplayEffectContext* _outContext) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAbilitySystemComponent", "BPF_FindActiveRuntimeGameplayEffectContext");

	Params::RuntimeAbilitySystemComponent_BPF_FindActiveRuntimeGameplayEffectContext Parms{};

	Parms._handle = std::move(_handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outContext != nullptr)
		*_outContext = std::move(Parms._outContext);

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAbilitySystemComponent.BPF_GetActiveRuntimeGameplayEffectContext
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FActiveGameplayEffectHandle&_handle                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRuntimeGameplayEffectContext*   _outContext                                            (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeAbilitySystemComponent::BPF_GetActiveRuntimeGameplayEffectContext(const struct FActiveGameplayEffectHandle& _handle, struct FRuntimeGameplayEffectContext* _outContext) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAbilitySystemComponent", "BPF_GetActiveRuntimeGameplayEffectContext");

	Params::RuntimeAbilitySystemComponent_BPF_GetActiveRuntimeGameplayEffectContext Parms{};

	Parms._handle = std::move(_handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outContext != nullptr)
		*_outContext = std::move(Parms._outContext);

	return Parms.ReturnValue;
}


// Function Runtime.ItemThumbnailScene.AddComponent
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UActorComponent>      Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                LocalToWorld                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAttachToRoot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UItemThumbnailScene::AddComponent(TSubclassOf<class UActorComponent> Class_0, const struct FTransform& LocalToWorld, bool bAttachToRoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailScene", "AddComponent");

	Params::ItemThumbnailScene_AddComponent Parms{};

	Parms.Class_0 = Class_0;
	Parms.LocalToWorld = std::move(LocalToWorld);
	Parms.bAttachToRoot = bAttachToRoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ItemThumbnailScene.GetThumbnailWorld
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWorld*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorld* UItemThumbnailScene::GetThumbnailWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailScene", "GetThumbnailWorld");

	Params::ItemThumbnailScene_GetThumbnailWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ItemThumbnailScene.PrepareScene
// (Event, Protected, BlueprintEvent)

void UItemThumbnailScene::PrepareScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailScene", "PrepareScene");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.ItemThumbnailScene.SetBackgroundColor
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemThumbnailScene::SetBackgroundColor(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailScene", "SetBackgroundColor");

	Params::ItemThumbnailScene_SetBackgroundColor Parms{};

	Parms.InColor = std::move(InColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ItemThumbnailScene.SpawnActor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UItemThumbnailScene::SpawnActor(TSubclassOf<class AActor> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailScene", "SpawnActor");

	Params::ItemThumbnailScene_SpawnActor Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ItemThumbnailScene.SpawnActorForKey
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGenericStruct&            Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutViewIndex                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UItemThumbnailScene::SpawnActorForKey(const struct FGenericStruct& Key, TSubclassOf<class AActor> Class_0, int32* OutViewIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailScene", "SpawnActorForKey");

	Params::ItemThumbnailScene_SpawnActorForKey Parms{};

	Parms.Key = std::move(Key);
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutViewIndex != nullptr)
		*OutViewIndex = Parms.OutViewIndex;

	return Parms.ReturnValue;
}


// Function Runtime.ItemThumbnailScene.GetActorForView
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ViewIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UItemThumbnailScene::GetActorForView(int32 ViewIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailScene", "GetActorForView");

	Params::ItemThumbnailScene_GetActorForView Parms{};

	Parms.ViewIndex = ViewIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ItemThumbnailScene.GetViewMatrixParameters
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// int32                                   SceneView                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FViewParameters*                 OutParameters                                          (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemThumbnailScene::GetViewMatrixParameters(int32 SceneView, struct FViewParameters* OutParameters) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailScene", "GetViewMatrixParameters");

	Params::ItemThumbnailScene_GetViewMatrixParameters Parms{};

	Parms.SceneView = SceneView;

	UObject::ProcessEvent(Func, &Parms);

	if (OutParameters != nullptr)
		*OutParameters = std::move(Parms.OutParameters);
}


// Function Runtime.ItemThumbnailScene.OnBuildActor
// (Final, Native, Protected, BlueprintCallable, Const)

void UItemThumbnailScene::OnBuildActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailScene", "OnBuildActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAIController.BPF_SetStateTreeRef
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FStateTreeReference&       _stateTreeRef                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ARuntimeAIController::BPF_SetStateTreeRef(const struct FStateTreeReference& _stateTreeRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAIController", "BPF_SetStateTreeRef");

	Params::RuntimeAIController_BPF_SetStateTreeRef Parms{};

	Parms._stateTreeRef = std::move(_stateTreeRef);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAIController.StartLogic
// (Final, Native, Public, BlueprintCallable)

void ARuntimeAIController::StartLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAIController", "StartLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAIController.StopLogic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    _reason                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeAIController::StopLogic(const class FString& _reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAIController", "StopLogic");

	Params::RuntimeAIController_StopLogic Parms{};

	Parms._reason = std::move(_reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAISubsystem.BPF_SetBall
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeAISubsystem::BPF_SetBall(class ABall* _ball)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_SetBall");

	Params::RuntimeAISubsystem_BPF_SetBall Parms{};

	Parms._ball = _ball;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAISubsystem.BPF_UnregisterAllCharacters
// (Final, Native, Public, BlueprintCallable)

void URuntimeAISubsystem::BPF_UnregisterAllCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_UnregisterAllCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAISubsystem.OnBallFree
// (Final, Native, Public)

void URuntimeAISubsystem::OnBallFree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "OnBallFree");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAISubsystem.OnBallOwned
// (Final, Native, Public)
// Parameters:
// const class ARuntimeCharacter*          _character                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeAISubsystem::OnBallOwned(const class ARuntimeCharacter* _character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "OnBallOwned");

	Params::RuntimeAISubsystem_OnBallOwned Parms{};

	Parms._character = _character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetBall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABall*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABall* URuntimeAISubsystem::BPF_GetBall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetBall");

	Params::RuntimeAISubsystem_BPF_GetBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetBallHasOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeAISubsystem::BPF_GetBallHasOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetBallHasOwner");

	Params::RuntimeAISubsystem_BPF_GetBallHasOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetBallOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ARuntimeCharacter*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ARuntimeCharacter* URuntimeAISubsystem::BPF_GetBallOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetBallOwner");

	Params::RuntimeAISubsystem_BPF_GetBallOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetBallOwnerTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 URuntimeAISubsystem::BPF_GetBallOwnerTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetBallOwnerTeam");

	Params::RuntimeAISubsystem_BPF_GetBallOwnerTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetEnemyTeamGoal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   _uiTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGoal*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGoal* URuntimeAISubsystem::BPF_GetEnemyTeamGoal(uint8 _uiTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetEnemyTeamGoal");

	Params::RuntimeAISubsystem_BPF_GetEnemyTeamGoal Parms{};

	Parms._uiTeam = _uiTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetGoalKeepers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARuntimeCharacter*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARuntimeCharacter*> URuntimeAISubsystem::BPF_GetGoalKeepers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetGoalKeepers");

	Params::RuntimeAISubsystem_BPF_GetGoalKeepers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetNextBallOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ARuntimeCharacter*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ARuntimeCharacter* URuntimeAISubsystem::BPF_GetNextBallOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetNextBallOwner");

	Params::RuntimeAISubsystem_BPF_GetNextBallOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetOpponents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   _currentTeam                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bWithoutGoalKeeper                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARuntimeCharacter*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARuntimeCharacter*> URuntimeAISubsystem::BPF_GetOpponents(uint8 _currentTeam, bool _bWithoutGoalKeeper) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetOpponents");

	Params::RuntimeAISubsystem_BPF_GetOpponents Parms{};

	Parms._currentTeam = _currentTeam;
	Parms._bWithoutGoalKeeper = _bWithoutGoalKeeper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetPlayersClosestToBall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARuntimeCharacter*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARuntimeCharacter*> URuntimeAISubsystem::BPF_GetPlayersClosestToBall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetPlayersClosestToBall");

	Params::RuntimeAISubsystem_BPF_GetPlayersClosestToBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetPreviousBallOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ARuntimeCharacter*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ARuntimeCharacter* URuntimeAISubsystem::BPF_GetPreviousBallOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetPreviousBallOwner");

	Params::RuntimeAISubsystem_BPF_GetPreviousBallOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetTeamGoal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   _uiTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGoal*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGoal* URuntimeAISubsystem::BPF_GetTeamGoal(uint8 _uiTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetTeamGoal");

	Params::RuntimeAISubsystem_BPF_GetTeamGoal Parms{};

	Parms._uiTeam = _uiTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_GetTeammates
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARuntimeCharacter*                _currentChar                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bWithoutGoalKeeper                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ARuntimeCharacter*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARuntimeCharacter*> URuntimeAISubsystem::BPF_GetTeammates(class ARuntimeCharacter* _currentChar, bool _bWithoutGoalKeeper) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_GetTeammates");

	Params::RuntimeAISubsystem_BPF_GetTeammates Parms{};

	Parms._currentChar = _currentChar;
	Parms._bWithoutGoalKeeper = _bWithoutGoalKeeper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAISubsystem.BPF_SpawnAI
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// const struct FAISpawnParameters&        _spawnParameters                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ARuntimeCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARuntimeCharacter* URuntimeAISubsystem::BPF_SpawnAI(const struct FAISpawnParameters& _spawnParameters) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAISubsystem", "BPF_SpawnAI");

	Params::RuntimeAISubsystem_BPF_SpawnAI Parms{};

	Parms._spawnParameters = std::move(_spawnParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.StringsHelper.BPF_HashString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    _str                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStringsHelper::BPF_HashString(const class FString& _str)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StringsHelper", "BPF_HashString");

	Params::StringsHelper_BPF_HashString Parms{};

	Parms._str = std::move(_str);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAnimInstance.BPE_OnMenuFlowCameraChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    _bIsInMenuCamera                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeAnimInstance::BPE_OnMenuFlowCameraChanged(bool _bIsInMenuCamera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPE_OnMenuFlowCameraChanged");

	Params::RuntimeAnimInstance_BPE_OnMenuFlowCameraChanged Parms{};

	Parms._bIsInMenuCamera = _bIsInMenuCamera;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.RuntimeAnimInstance.BPE_OnSeedReplicated
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   _uiSeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeAnimInstance::BPE_OnSeedReplicated(int32 _uiSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPE_OnSeedReplicated");

	Params::RuntimeAnimInstance_BPE_OnSeedReplicated Parms{};

	Parms._uiSeed = _uiSeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.RuntimeAnimInstance.BPF_SetUpTouchBallLeftBlendSpace
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAnimUpdateContext&        _context                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAnimNodeReference&        _node                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URuntimeAnimInstance::BPF_SetUpTouchBallLeftBlendSpace(const struct FAnimUpdateContext& _context, const struct FAnimNodeReference& _node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_SetUpTouchBallLeftBlendSpace");

	Params::RuntimeAnimInstance_BPF_SetUpTouchBallLeftBlendSpace Parms{};

	Parms._context = std::move(_context);
	Parms._node = std::move(_node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAnimInstance.BPF_SetUpTouchBallRightBlendSpace
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAnimUpdateContext&        _context                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAnimNodeReference&        _node                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URuntimeAnimInstance::BPF_SetUpTouchBallRightBlendSpace(const struct FAnimUpdateContext& _context, const struct FAnimNodeReference& _node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_SetUpTouchBallRightBlendSpace");

	Params::RuntimeAnimInstance_BPF_SetUpTouchBallRightBlendSpace Parms{};

	Parms._context = std::move(_context);
	Parms._node = std::move(_node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAnimInstance.BPF_TryToUpdateLocomotionAnimation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   _fDt                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTargetDatasource>    _locomotionAnimTargetDataSource                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fOrientationToVelocityAngle                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESCCharacterSpeedState                  _eCharacterSpeedState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bCanUpdateIdleMirror                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeAnimInstance::BPF_TryToUpdateLocomotionAnimation(float _fDt, TSubclassOf<class UTargetDatasource> _locomotionAnimTargetDataSource, float _fOrientationToVelocityAngle, ESCCharacterSpeedState _eCharacterSpeedState, bool _bCanUpdateIdleMirror)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_TryToUpdateLocomotionAnimation");

	Params::RuntimeAnimInstance_BPF_TryToUpdateLocomotionAnimation Parms{};

	Parms._fDt = _fDt;
	Parms._locomotionAnimTargetDataSource = _locomotionAnimTargetDataSource;
	Parms._fOrientationToVelocityAngle = _fOrientationToVelocityAngle;
	Parms._eCharacterSpeedState = _eCharacterSpeedState;
	Parms._bCanUpdateIdleMirror = _bCanUpdateIdleMirror;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAnimInstance.BPF_UpdateAnimPlayInfos
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimSequencePlayInfos&          _animPlayInfosRef                                      (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UTargetDatasource>    _animTargetDataSource                                  (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fOrientationToVelocityAngle                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESCCharacterSpeedState                  _eCharacterSpeedState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_optionalHandle                                        (Parm, NativeAccessSpecifierPublic)

void URuntimeAnimInstance::BPF_UpdateAnimPlayInfos(struct FAnimSequencePlayInfos& _animPlayInfosRef, TSubclassOf<class UTargetDatasource> _animTargetDataSource, float _fOrientationToVelocityAngle, ESCCharacterSpeedState _eCharacterSpeedState, const struct FGameplayAbilityTargetDataHandle& _optionalHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_UpdateAnimPlayInfos");

	Params::RuntimeAnimInstance_BPF_UpdateAnimPlayInfos Parms{};

	Parms._animPlayInfosRef = std::move(_animPlayInfosRef);
	Parms._animTargetDataSource = _animTargetDataSource;
	Parms._fOrientationToVelocityAngle = _fOrientationToVelocityAngle;
	Parms._eCharacterSpeedState = _eCharacterSpeedState;
	Parms._optionalHandle = std::move(_optionalHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	_animPlayInfosRef = std::move(Parms._animPlayInfosRef);
}


// Function Runtime.RuntimeAnimInstance.BPF_UpdateFreezableProceduralAnimNode
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAnimUpdateContext&        _context                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAnimNodeReference&        _node                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URuntimeAnimInstance::BPF_UpdateFreezableProceduralAnimNode(const struct FAnimUpdateContext& _context, const struct FAnimNodeReference& _node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_UpdateFreezableProceduralAnimNode");

	Params::RuntimeAnimInstance_BPF_UpdateFreezableProceduralAnimNode Parms{};

	Parms._context = std::move(_context);
	Parms._node = std::move(_node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAnimInstance.BPF_UpdateLocomotionAnimation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTargetDatasource>    _locomotionAnimTargetDataSource                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fOrientationToVelocityAngle                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESCCharacterSpeedState                  _eCharacterSpeedState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bCanUpdateIdleMirror                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeAnimInstance::BPF_UpdateLocomotionAnimation(TSubclassOf<class UTargetDatasource> _locomotionAnimTargetDataSource, float _fOrientationToVelocityAngle, ESCCharacterSpeedState _eCharacterSpeedState, bool _bCanUpdateIdleMirror)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_UpdateLocomotionAnimation");

	Params::RuntimeAnimInstance_BPF_UpdateLocomotionAnimation Parms{};

	Parms._locomotionAnimTargetDataSource = _locomotionAnimTargetDataSource;
	Parms._fOrientationToVelocityAngle = _fOrientationToVelocityAngle;
	Parms._eCharacterSpeedState = _eCharacterSpeedState;
	Parms._bCanUpdateIdleMirror = _bCanUpdateIdleMirror;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAnimInstance.BPF_ComputeCurrentCardinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESCCardinalPoints                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESCCardinalPoints URuntimeAnimInstance::BPF_ComputeCurrentCardinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_ComputeCurrentCardinal");

	Params::RuntimeAnimInstance_BPF_ComputeCurrentCardinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAnimInstance.BPF_ComputeWantedCardinal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESCCardinalPoints                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESCCardinalPoints URuntimeAnimInstance::BPF_ComputeWantedCardinal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_ComputeWantedCardinal");

	Params::RuntimeAnimInstance_BPF_ComputeWantedCardinal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAnimInstance.BPF_GetOwnerRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator URuntimeAnimInstance::BPF_GetOwnerRotator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_GetOwnerRotator");

	Params::RuntimeAnimInstance_BPF_GetOwnerRotator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAnimInstance.BPF_GetOwnerSpeedState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESCCharacterSpeedState                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESCCharacterSpeedState URuntimeAnimInstance::BPF_GetOwnerSpeedState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_GetOwnerSpeedState");

	Params::RuntimeAnimInstance_BPF_GetOwnerSpeedState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAnimInstance.BPF_GetOwnerTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform URuntimeAnimInstance::BPF_GetOwnerTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_GetOwnerTransform");

	Params::RuntimeAnimInstance_BPF_GetOwnerTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAnimInstance.BPF_GetOwnerVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URuntimeAnimInstance::BPF_GetOwnerVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAnimInstance", "BPF_GetOwnerVelocity");

	Params::RuntimeAnimInstance_BPF_GetOwnerVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeAttributeSet.OnRep_ExhaustStateExit
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldExhaustStateExit                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_ExhaustStateExit(const struct FGameplayAttributeData& _oldExhaustStateExit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_ExhaustStateExit");

	Params::RuntimeAttributeSet_OnRep_ExhaustStateExit Parms{};

	Parms._oldExhaustStateExit = std::move(_oldExhaustStateExit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_ExhaustStateStaminaRegenPerPeriod
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldExhaustStateStaminaRegenPerPeriod                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_ExhaustStateStaminaRegenPerPeriod(const struct FGameplayAttributeData& _oldExhaustStateStaminaRegenPerPeriod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_ExhaustStateStaminaRegenPerPeriod");

	Params::RuntimeAttributeSet_OnRep_ExhaustStateStaminaRegenPerPeriod Parms{};

	Parms._oldExhaustStateStaminaRegenPerPeriod = std::move(_oldExhaustStateStaminaRegenPerPeriod);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_ExtraEffortGauge
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldExtraEffortGauge                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_ExtraEffortGauge(const struct FGameplayAttributeData& _oldExtraEffortGauge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_ExtraEffortGauge");

	Params::RuntimeAttributeSet_OnRep_ExtraEffortGauge Parms{};

	Parms._oldExtraEffortGauge = std::move(_oldExtraEffortGauge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_ExtraEffortGaugeRegenMultiplier
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldExtraEffortGaugeRegenMultiplier                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_ExtraEffortGaugeRegenMultiplier(const struct FGameplayAttributeData& _oldExtraEffortGaugeRegenMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_ExtraEffortGaugeRegenMultiplier");

	Params::RuntimeAttributeSet_OnRep_ExtraEffortGaugeRegenMultiplier Parms{};

	Parms._oldExtraEffortGaugeRegenMultiplier = std::move(_oldExtraEffortGaugeRegenMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_ExtraEffortGaugeRegenMultiplierThreshold
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldExtraEffortGaugeRegenMultiplierThreshold           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_ExtraEffortGaugeRegenMultiplierThreshold(const struct FGameplayAttributeData& _oldExtraEffortGaugeRegenMultiplierThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_ExtraEffortGaugeRegenMultiplierThreshold");

	Params::RuntimeAttributeSet_OnRep_ExtraEffortGaugeRegenMultiplierThreshold Parms{};

	Parms._oldExtraEffortGaugeRegenMultiplierThreshold = std::move(_oldExtraEffortGaugeRegenMultiplierThreshold);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_ExtraEffortGaugeRegenPerSec
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldExtraEffortGaugeRegenPerSec                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_ExtraEffortGaugeRegenPerSec(const struct FGameplayAttributeData& _oldExtraEffortGaugeRegenPerSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_ExtraEffortGaugeRegenPerSec");

	Params::RuntimeAttributeSet_OnRep_ExtraEffortGaugeRegenPerSec Parms{};

	Parms._oldExtraEffortGaugeRegenPerSec = std::move(_oldExtraEffortGaugeRegenPerSec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_ExtraEffortSpeed
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldExtraEffortSpeed                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_ExtraEffortSpeed(const struct FGameplayAttributeData& _oldExtraEffortSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_ExtraEffortSpeed");

	Params::RuntimeAttributeSet_OnRep_ExtraEffortSpeed Parms{};

	Parms._oldExtraEffortSpeed = std::move(_oldExtraEffortSpeed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_MaxExtraEffortGauge
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldMaxExtraEffortGauge                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_MaxExtraEffortGauge(const struct FGameplayAttributeData& _oldMaxExtraEffortGauge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_MaxExtraEffortGauge");

	Params::RuntimeAttributeSet_OnRep_MaxExtraEffortGauge Parms{};

	Parms._oldMaxExtraEffortGauge = std::move(_oldMaxExtraEffortGauge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_MaxStamina
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldMaxStamina                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_MaxStamina(const struct FGameplayAttributeData& _oldMaxStamina)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_MaxStamina");

	Params::RuntimeAttributeSet_OnRep_MaxStamina Parms{};

	Parms._oldMaxStamina = std::move(_oldMaxStamina);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_MaxStaminaOvercharge
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldMMaxStaminaOvercharge                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_MaxStaminaOvercharge(const struct FGameplayAttributeData& _oldMMaxStaminaOvercharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_MaxStaminaOvercharge");

	Params::RuntimeAttributeSet_OnRep_MaxStaminaOvercharge Parms{};

	Parms._oldMMaxStaminaOvercharge = std::move(_oldMMaxStaminaOvercharge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_PowerShoot
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldPowerShoot                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_PowerShoot(const struct FGameplayAttributeData& _oldPowerShoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_PowerShoot");

	Params::RuntimeAttributeSet_OnRep_PowerShoot Parms{};

	Parms._oldPowerShoot = std::move(_oldPowerShoot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_Stamina
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldStamina                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_Stamina(const struct FGameplayAttributeData& _oldStamina)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_Stamina");

	Params::RuntimeAttributeSet_OnRep_Stamina Parms{};

	Parms._oldStamina = std::move(_oldStamina);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_StaminaOverchargeLossPerSec
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldStaminaOverchargeLossPerSec                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_StaminaOverchargeLossPerSec(const struct FGameplayAttributeData& _oldStaminaOverchargeLossPerSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_StaminaOverchargeLossPerSec");

	Params::RuntimeAttributeSet_OnRep_StaminaOverchargeLossPerSec Parms{};

	Parms._oldStaminaOverchargeLossPerSec = std::move(_oldStaminaOverchargeLossPerSec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_StaminaRegenOnPointPerSec
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldStaminaRegenOnPointPerSec                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_StaminaRegenOnPointPerSec(const struct FGameplayAttributeData& _oldStaminaRegenOnPointPerSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_StaminaRegenOnPointPerSec");

	Params::RuntimeAttributeSet_OnRep_StaminaRegenOnPointPerSec Parms{};

	Parms._oldStaminaRegenOnPointPerSec = std::move(_oldStaminaRegenOnPointPerSec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeAttributeSet.OnRep_StaminaRegenPerSec
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldStaminaRegenPerSec                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeAttributeSet::OnRep_StaminaRegenPerSec(const struct FGameplayAttributeData& _oldStaminaRegenPerSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeAttributeSet", "OnRep_StaminaRegenPerSec");

	Params::RuntimeAttributeSet_OnRep_StaminaRegenPerSec Parms{};

	Parms._oldStaminaRegenPerSec = std::move(_oldStaminaRegenPerSec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCharacter.BPE_GetExtraEffects
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<TSubclassOf<class UGameplayEffect>>&_effects                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void ARuntimeCharacter::BPE_GetExtraEffects(TArray<TSubclassOf<class UGameplayEffect>>& _effects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPE_GetExtraEffects");

	Params::RuntimeCharacter_BPE_GetExtraEffects Parms{};

	Parms._effects = std::move(_effects);

	UObject::ProcessEvent(Func, &Parms);

	_effects = std::move(Parms._effects);
}


// Function Runtime.RuntimeCharacter.BPF_GenerateSeed
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ARuntimeCharacter::BPF_GenerateSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_GenerateSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCharacter.ClientNotifyBallServerOwnerUpdate
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerBallOwnership*             _owner                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRevisionID&               _revisionID                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARuntimeCharacter::ClientNotifyBallServerOwnerUpdate(class ABall* _ball, class UPlayerBallOwnership* _owner, const struct FRevisionID& _revisionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "ClientNotifyBallServerOwnerUpdate");

	Params::RuntimeCharacter_ClientNotifyBallServerOwnerUpdate Parms{};

	Parms._ball = _ball;
	Parms._owner = _owner;
	Parms._revisionID = std::move(_revisionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCharacter.ClientNotifyBallServerTrajectoryUpdate
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerBallOwnership*             _owner                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootStartPoint&          _serverTrajectoryStartingPoint                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FRevisionID&               _revisionID                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARuntimeCharacter::ClientNotifyBallServerTrajectoryUpdate(class ABall* _ball, class UPlayerBallOwnership* _owner, const struct FShootStartPoint& _serverTrajectoryStartingPoint, const struct FRevisionID& _revisionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "ClientNotifyBallServerTrajectoryUpdate");

	Params::RuntimeCharacter_ClientNotifyBallServerTrajectoryUpdate Parms{};

	Parms._ball = _ball;
	Parms._owner = _owner;
	Parms._serverTrajectoryStartingPoint = std::move(_serverTrajectoryStartingPoint);
	Parms._revisionID = std::move(_revisionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCharacter.OnRep_ReplicatedSeed
// (Final, Native, Protected)

void ARuntimeCharacter::OnRep_ReplicatedSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "OnRep_ReplicatedSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCharacter.BPF_GetCameraThird
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponentThird*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponentThird* ARuntimeCharacter::BPF_GetCameraThird() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_GetCameraThird");

	Params::RuntimeCharacter_BPF_GetCameraThird Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCharacter.BPF_GetGameplayAbilitiesByAllMatchingTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer&     GameplayTagContainer                                   (Parm, NativeAccessSpecifierPublic)
// bool                                    bOnlyAbilitiesThatSatisfyTagRequirements               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class URuntimeGameplayAbility*>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class URuntimeGameplayAbility*> ARuntimeCharacter::BPF_GetGameplayAbilitiesByAllMatchingTags(const struct FGameplayTagContainer& GameplayTagContainer, bool bOnlyAbilitiesThatSatisfyTagRequirements) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_GetGameplayAbilitiesByAllMatchingTags");

	Params::RuntimeCharacter_BPF_GetGameplayAbilitiesByAllMatchingTags Parms{};

	Parms.GameplayTagContainer = std::move(GameplayTagContainer);
	Parms.bOnlyAbilitiesThatSatisfyTagRequirements = bOnlyAbilitiesThatSatisfyTagRequirements;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCharacter.BPF_GetGameplayAbilityByMatchingTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyAbilitiesThatSatisfyTagRequirements               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeGameplayAbility*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URuntimeGameplayAbility* ARuntimeCharacter::BPF_GetGameplayAbilityByMatchingTag(const struct FGameplayTag& GameplayTag, bool bOnlyAbilitiesThatSatisfyTagRequirements) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_GetGameplayAbilityByMatchingTag");

	Params::RuntimeCharacter_BPF_GetGameplayAbilityByMatchingTag Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.bOnlyAbilitiesThatSatisfyTagRequirements = bOnlyAbilitiesThatSatisfyTagRequirements;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCharacter.BPF_GetHinderingComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UHinderingComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHinderingComponent* ARuntimeCharacter::BPF_GetHinderingComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_GetHinderingComponent");

	Params::RuntimeCharacter_BPF_GetHinderingComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCharacter.BPF_GetReplicatedSeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARuntimeCharacter::BPF_GetReplicatedSeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_GetReplicatedSeed");

	Params::RuntimeCharacter_BPF_GetReplicatedSeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCharacter.BPF_GetRuntimeAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URuntimeAbilitySystemComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URuntimeAbilitySystemComponent* ARuntimeCharacter::BPF_GetRuntimeAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_GetRuntimeAbilitySystemComponent");

	Params::RuntimeCharacter_BPF_GetRuntimeAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCharacter.BPF_GetRuntimeMovementComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URuntimeMovementComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URuntimeMovementComponent* ARuntimeCharacter::BPF_GetRuntimeMovementComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_GetRuntimeMovementComponent");

	Params::RuntimeCharacter_BPF_GetRuntimeMovementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCharacter.BPF_GetTagCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              _tagToCheck                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARuntimeCharacter::BPF_GetTagCount(const struct FGameplayTag& _tagToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_GetTagCount");

	Params::RuntimeCharacter_BPF_GetTagCount Parms{};

	Parms._tagToCheck = std::move(_tagToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCharacter.BPF_HasBall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeCharacter::BPF_HasBall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_HasBall");

	Params::RuntimeCharacter_BPF_HasBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCharacter.BPF_IsAiming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeCharacter::BPF_IsAiming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_IsAiming");

	Params::RuntimeCharacter_BPF_IsAiming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCharacter.BPF_IsGoalKeeper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeCharacter::BPF_IsGoalKeeper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_IsGoalKeeper");

	Params::RuntimeCharacter_BPF_IsGoalKeeper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCharacter.BPF_IsSweeper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeCharacter::BPF_IsSweeper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCharacter", "BPF_IsSweeper");

	Params::RuntimeCharacter_BPF_IsSweeper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCheatManager.cmdChangeTeam
// (Final, Exec, Native, Public)

void URuntimeCheatManager::cmdChangeTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "cmdChangeTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.cmdEnableAbilityOwnerSelectors
// (Final, Exec, Native, Public)
// Parameters:
// const bool                              _bEnable                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeCheatManager::cmdEnableAbilityOwnerSelectors(const bool _bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "cmdEnableAbilityOwnerSelectors");

	Params::RuntimeCheatManager_cmdEnableAbilityOwnerSelectors Parms{};

	Parms._bEnable = _bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.cmdEndGame
// (Final, Exec, Native, Public)

void URuntimeCheatManager::cmdEndGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "cmdEndGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.cmdEndGameWithScore
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   _uiScoreTeam1                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   _uiScoreTeam2                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeCheatManager::cmdEndGameWithScore(uint8 _uiScoreTeam1, uint8 _uiScoreTeam2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "cmdEndGameWithScore");

	Params::RuntimeCheatManager_cmdEndGameWithScore Parms{};

	Parms._uiScoreTeam1 = _uiScoreTeam1;
	Parms._uiScoreTeam2 = _uiScoreTeam2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.cmdGoToNextHalf
// (Final, Exec, Native, Public)
// Parameters:
// float                                   _fSecondsBeforeHalf                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeCheatManager::cmdGoToNextHalf(float _fSecondsBeforeHalf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "cmdGoToNextHalf");

	Params::RuntimeCheatManager_cmdGoToNextHalf Parms{};

	Parms._fSecondsBeforeHalf = _fSecondsBeforeHalf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.cmdPauseTimer
// (Final, Exec, Native, Public)

void URuntimeCheatManager::cmdPauseTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "cmdPauseTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.cmdResetBalls
// (Final, Exec, Native, Public)

void URuntimeCheatManager::cmdResetBalls()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "cmdResetBalls");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.cmdResetGame
// (Final, Exec, Native, Public)

void URuntimeCheatManager::cmdResetGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "cmdResetGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.cmdResetMe
// (Final, Exec, Native, Public)

void URuntimeCheatManager::cmdResetMe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "cmdResetMe");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.cmdResumeTimer
// (Final, Exec, Native, Public)

void URuntimeCheatManager::cmdResumeTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "cmdResumeTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.cmdSetScore
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   _uiScoreTeam1                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   _uiScoreTeam2                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeCheatManager::cmdSetScore(uint8 _uiScoreTeam1, uint8 _uiScoreTeam2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "cmdSetScore");

	Params::RuntimeCheatManager_cmdSetScore Parms{};

	Parms._uiScoreTeam1 = _uiScoreTeam1;
	Parms._uiScoreTeam2 = _uiScoreTeam2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerChangeTeam
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void URuntimeCheatManager::ServerChangeTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerChangeTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerClearScore
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void URuntimeCheatManager::ServerClearScore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerClearScore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerEnableAbilityOwnerSelectors
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const bool                              _bEnable                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeCheatManager::ServerEnableAbilityOwnerSelectors(const bool _bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerEnableAbilityOwnerSelectors");

	Params::RuntimeCheatManager_ServerEnableAbilityOwnerSelectors Parms{};

	Parms._bEnable = _bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerEndGame
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void URuntimeCheatManager::ServerEndGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerEndGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerGoToNextHalf
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   _fSecondsBeforeHalf                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeCheatManager::ServerGoToNextHalf(float _fSecondsBeforeHalf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerGoToNextHalf");

	Params::RuntimeCheatManager_ServerGoToNextHalf Parms{};

	Parms._fSecondsBeforeHalf = _fSecondsBeforeHalf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerPauseTimer
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void URuntimeCheatManager::ServerPauseTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerPauseTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerResetBalls
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void URuntimeCheatManager::ServerResetBalls()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerResetBalls");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerResetCharacters
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void URuntimeCheatManager::ServerResetCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerResetCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerResetGame
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void URuntimeCheatManager::ServerResetGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerResetGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerResetTimer
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void URuntimeCheatManager::ServerResetTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerResetTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerResumeTimer
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void URuntimeCheatManager::ServerResumeTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerResumeTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCheatManager.ServerSetScore
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const TArray<uint8>&                    _scores                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeCheatManager::ServerSetScore(const TArray<uint8>& _scores)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeCheatManager", "ServerSetScore");

	Params::RuntimeCheatManager_ServerSetScore Parms{};

	Parms._scores = std::move(_scores);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeCustomizationHelpers.BPF_ApplyPaletteToParts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FColorPalette&             _palette                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCustomizationSubsystem*    _customizationSubsystem                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FCharacterPartEnumHandler>&_eParts                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSCCharacterCustomizationDescription*_inOutDescription                                      (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeCustomizationHelpers::BPF_ApplyPaletteToParts(const struct FColorPalette& _palette, const class UCustomizationSubsystem* _customizationSubsystem, const TArray<struct FCharacterPartEnumHandler>& _eParts, struct FSCCharacterCustomizationDescription* _inOutDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeCustomizationHelpers", "BPF_ApplyPaletteToParts");

	Params::RuntimeCustomizationHelpers_BPF_ApplyPaletteToParts Parms{};

	Parms._palette = std::move(_palette);
	Parms._customizationSubsystem = _customizationSubsystem;
	Parms._eParts = std::move(_eParts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_inOutDescription != nullptr)
		*_inOutDescription = std::move(Parms._inOutDescription);
}


// Function Runtime.RuntimeCustomizationHelpers.BPF_IsOwnedShopItemOwned
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FShopItem&                 _item                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeCustomizationHelpers::BPF_IsOwnedShopItemOwned(const struct FShopItem& _item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeCustomizationHelpers", "BPF_IsOwnedShopItemOwned");

	Params::RuntimeCustomizationHelpers_BPF_IsOwnedShopItemOwned Parms{};

	Parms._item = std::move(_item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeCustomizationHelpers.BPF_RemovePaletteFromParts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FColorPalette&             _palette                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCustomizationSubsystem*    _customizationSubsystem                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FCharacterPartEnumHandler>&_eParts                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSCCharacterCustomizationDescription*_inOutDescription                                      (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeCustomizationHelpers::BPF_RemovePaletteFromParts(const struct FColorPalette& _palette, const class UCustomizationSubsystem* _customizationSubsystem, const TArray<struct FCharacterPartEnumHandler>& _eParts, struct FSCCharacterCustomizationDescription* _inOutDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeCustomizationHelpers", "BPF_RemovePaletteFromParts");

	Params::RuntimeCustomizationHelpers_BPF_RemovePaletteFromParts Parms{};

	Parms._palette = std::move(_palette);
	Parms._customizationSubsystem = _customizationSubsystem;
	Parms._eParts = std::move(_eParts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_inOutDescription != nullptr)
		*_inOutDescription = std::move(Parms._inOutDescription);
}


// Function Runtime.TouchBallComponent.BPF_SetParalyzed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    _bParalized                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             _idName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fBlendAttachDuration                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTouchBallComponent::BPF_SetParalyzed(bool _bParalized, class FName _idName, float _fBlendAttachDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TouchBallComponent", "BPF_SetParalyzed");

	Params::TouchBallComponent_BPF_SetParalyzed Parms{};

	Parms._bParalized = _bParalized;
	Parms._idName = _idName;
	Parms._fBlendAttachDuration = _fBlendAttachDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TouchBallComponent.OnBallOwnershipGained
// (Final, Native, Protected)
// Parameters:
// class ABall*                            _nextBall                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTouchBallComponent::OnBallOwnershipGained(class ABall* _nextBall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TouchBallComponent", "OnBallOwnershipGained");

	Params::TouchBallComponent_OnBallOwnershipGained Parms{};

	Parms._nextBall = _nextBall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TouchBallComponent.OnBallOwnershipLost
// (Final, Native, Protected)

void UTouchBallComponent::OnBallOwnershipLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TouchBallComponent", "OnBallOwnershipLost");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TouchBallComponent.OnMontageStarted
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     _animMontage                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTouchBallComponent::OnMontageStarted(class UAnimMontage* _animMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TouchBallComponent", "OnMontageStarted");

	Params::TouchBallComponent_OnMontageStarted Parms{};

	Parms._animMontage = _animMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TouchBallComponent.OnMovementModeChanged
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       _character                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           _ePrevMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   _uiPreviousCustomMode                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTouchBallComponent::OnMovementModeChanged(class ACharacter* _character, EMovementMode _ePrevMovementMode, uint8 _uiPreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TouchBallComponent", "OnMovementModeChanged");

	Params::TouchBallComponent_OnMovementModeChanged Parms{};

	Parms._character = _character;
	Parms._ePrevMovementMode = _ePrevMovementMode;
	Parms._uiPreviousCustomMode = _uiPreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeDebug.BPF_MetricGrid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     _owner                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   _vOriginPosition                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fXSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   _vXAxis                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fYSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   _vYAxis                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _iNbrPolyByHalfAxis                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColor&                    _color                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bPersistentLines                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fLifeTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   _uPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fThickness                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeDebug::BPF_MetricGrid(const class AActor* _owner, const struct FVector& _vOriginPosition, float _fXSize, const struct FVector& _vXAxis, float _fYSize, const struct FVector& _vYAxis, int32 _iNbrPolyByHalfAxis, const struct FColor& _color, bool _bPersistentLines, float _fLifeTime, uint8 _uPriority, float _fThickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeDebug", "BPF_MetricGrid");

	Params::RuntimeDebug_BPF_MetricGrid Parms{};

	Parms._owner = _owner;
	Parms._vOriginPosition = std::move(_vOriginPosition);
	Parms._fXSize = _fXSize;
	Parms._vXAxis = std::move(_vXAxis);
	Parms._fYSize = _fYSize;
	Parms._vYAxis = std::move(_vYAxis);
	Parms._iNbrPolyByHalfAxis = _iNbrPolyByHalfAxis;
	Parms._color = std::move(_color);
	Parms._bPersistentLines = _bPersistentLines;
	Parms._fLifeTime = _fLifeTime;
	Parms._uPriority = _uPriority;
	Parms._fThickness = _fThickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeDebug.BPF_RTVisualLog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     _owner                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    _category                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDisplayLevel                           _eVerbosity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    _inString                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeDebug::BPF_RTVisualLog(const class AActor* _owner, const class FString& _category, EDisplayLevel _eVerbosity, const class FString& _inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeDebug", "BPF_RTVisualLog");

	Params::RuntimeDebug_BPF_RTVisualLog Parms{};

	Parms._owner = _owner;
	Parms._category = std::move(_category);
	Parms._eVerbosity = _eVerbosity;
	Parms._inString = std::move(_inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeGameMode.BPF_ResetAllBallsAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   _vLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bTriggerGameState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bApplyPhysics                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeGameMode::BPF_ResetAllBallsAtLocation(const struct FVector& _vLocation, bool _bTriggerGameState, bool _bApplyPhysics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameMode", "BPF_ResetAllBallsAtLocation");

	Params::RuntimeGameMode_BPF_ResetAllBallsAtLocation Parms{};

	Parms._vLocation = std::move(_vLocation);
	Parms._bTriggerGameState = _bTriggerGameState;
	Parms._bApplyPhysics = _bApplyPhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeGameMode.BPF_ResetSpecifiedBallAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   _vLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bTriggerGameState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bApplyPhysics                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeGameMode::BPF_ResetSpecifiedBallAtLocation(const struct FVector& _vLocation, class ABall* _ball, bool _bTriggerGameState, bool _bApplyPhysics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameMode", "BPF_ResetSpecifiedBallAtLocation");

	Params::RuntimeGameMode_BPF_ResetSpecifiedBallAtLocation Parms{};

	Parms._vLocation = std::move(_vLocation);
	Parms._ball = _ball;
	Parms._bTriggerGameState = _bTriggerGameState;
	Parms._bApplyPhysics = _bApplyPhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeGameMode.BPF_ScorePoint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGoalDescription&          _goalDscription                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    _bChangeMatchState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeGameMode::BPF_ScorePoint(const struct FGoalDescription& _goalDscription, bool _bChangeMatchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameMode", "BPF_ScorePoint");

	Params::RuntimeGameMode_BPF_ScorePoint Parms{};

	Parms._goalDscription = std::move(_goalDscription);
	Parms._bChangeMatchState = _bChangeMatchState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeGameMode.BPF_SpawnBalls
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   _iCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ABall*>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ABall*> ARuntimeGameMode::BPF_SpawnBalls(int32 _iCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameMode", "BPF_SpawnBalls");

	Params::RuntimeGameMode_BPF_SpawnBalls Parms{};

	Parms._iCount = _iCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeGameMode.BPE_GetBallPoints
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   _uiGoalTeamID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _iGoalDefaultScore                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARuntimeGameMode::BPE_GetBallPoints(class ABall* _ball, uint8 _uiGoalTeamID, int32 _iGoalDefaultScore) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameMode", "BPE_GetBallPoints");

	Params::RuntimeGameMode_BPE_GetBallPoints Parms{};

	Parms._ball = _ball;
	Parms._uiGoalTeamID = _uiGoalTeamID;
	Parms._iGoalDefaultScore = _iGoalDefaultScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameMode.BPF_GetMatchStateName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ERuntimeMatchState                      _eState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ARuntimeMatchGameMode::BPF_GetMatchStateName(ERuntimeMatchState _eState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeMatchGameMode", "BPF_GetMatchStateName");

	Params::RuntimeMatchGameMode_BPF_GetMatchStateName Parms{};

	Parms._eState = _eState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameMode.BPE_OnCountdownOver
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameMode::BPE_OnCountdownOver(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameMode", "BPE_OnCountdownOver");

	Params::RuntimeMatchGameMode_BPE_OnCountdownOver Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameMode.BPE_OnCountdownStart
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameMode::BPE_OnCountdownStart(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameMode", "BPE_OnCountdownStart");

	Params::RuntimeMatchGameMode_BPE_OnCountdownStart Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameMode.BPF_ClearScores
// (Final, Native, Public, BlueprintCallable)

void ARuntimeMatchGameMode::BPF_ClearScores()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameMode", "BPF_ClearScores");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameMode.BPF_PushPopGameplayEffect
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      _effect                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bPush                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameMode::BPF_PushPopGameplayEffect(TSubclassOf<class UGameplayEffect> _effect, bool _bPush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameMode", "BPF_PushPopGameplayEffect");

	Params::RuntimeMatchGameMode_BPF_PushPopGameplayEffect Parms{};

	Parms._effect = _effect;
	Parms._bPush = _bPush;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameMode.OnCountdownOver
// (Final, Native, Protected)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameMode::OnCountdownOver(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameMode", "OnCountdownOver");

	Params::RuntimeMatchGameMode_OnCountdownOver Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameMode.OnCountdownStart
// (Final, Native, Protected)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameMode::OnCountdownStart(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameMode", "OnCountdownStart");

	Params::RuntimeMatchGameMode_OnCountdownStart Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameMode.BPF_GetMatchParameters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRuntimeMatchParameters    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRuntimeMatchParameters ARuntimeMatchGameMode::BPF_GetMatchParameters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameMode", "BPF_GetMatchParameters");

	Params::RuntimeMatchGameMode_BPF_GetMatchParameters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameMode.BPF_HasDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeMatchGameMode::BPF_HasDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameMode", "BPF_HasDuration");

	Params::RuntimeMatchGameMode_BPF_HasDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeGameplayAbility.BPF_GetRuntimeAbilitySystemComponentFromActorInfos
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URuntimeAbilitySystemComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URuntimeAbilitySystemComponent* URuntimeGameplayAbility::BPF_GetRuntimeAbilitySystemComponentFromActorInfos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameplayAbility", "BPF_GetRuntimeAbilitySystemComponentFromActorInfos");

	Params::RuntimeGameplayAbility_BPF_GetRuntimeAbilitySystemComponentFromActorInfos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeGameplayAbility.BPF_GetRuntimeCharacter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARuntimeCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARuntimeCharacter* URuntimeGameplayAbility::BPF_GetRuntimeCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameplayAbility", "BPF_GetRuntimeCharacter");

	Params::RuntimeGameplayAbility_BPF_GetRuntimeCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeDiveGameplayAbility.BPF_GetPlayingMontageInstanceTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URuntimeDiveGameplayAbility::BPF_GetPlayingMontageInstanceTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeDiveGameplayAbility", "BPF_GetPlayingMontageInstanceTime");

	Params::RuntimeDiveGameplayAbility_BPF_GetPlayingMontageInstanceTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeDiveGameplayAbility.BPF_ShouldLivePrintDebug
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeDiveGameplayAbility::BPF_ShouldLivePrintDebug() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeDiveGameplayAbility", "BPF_ShouldLivePrintDebug");

	Params::RuntimeDiveGameplayAbility_BPF_ShouldLivePrintDebug Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeDiveGameplayAbility.GetDiveCaseAnimAndDataSourceFromEnum
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EDiveDetectionCase                _eDiveCase                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UIntermediateDatasource>*_outTargetPickerDataSource                             (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimSequencePickerSlotContainer>*_outAnimPickerSlotContainer                            (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeDiveGameplayAbility::GetDiveCaseAnimAndDataSourceFromEnum(const EDiveDetectionCase _eDiveCase, TSubclassOf<class UIntermediateDatasource>* _outTargetPickerDataSource, TSubclassOf<class UAnimSequencePickerSlotContainer>* _outAnimPickerSlotContainer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeDiveGameplayAbility", "GetDiveCaseAnimAndDataSourceFromEnum");

	Params::RuntimeDiveGameplayAbility_GetDiveCaseAnimAndDataSourceFromEnum Parms{};

	Parms._eDiveCase = _eDiveCase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outTargetPickerDataSource != nullptr)
		*_outTargetPickerDataSource = Parms._outTargetPickerDataSource;

	if (_outAnimPickerSlotContainer != nullptr)
		*_outAnimPickerSlotContainer = Parms._outAnimPickerSlotContainer;
}


// Function Runtime.RuntimeDiveGameplayAbility.GetDiveCaseEnumAndAnimFromDataSource
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSubclassOf<class UTargetDatasource>&_targetPickerDataSource                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDiveDetectionCase*                     _outEDiveCase                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimSequencePickerSlotContainer>*_outAnimPickerSlotContainer                            (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeDiveGameplayAbility::GetDiveCaseEnumAndAnimFromDataSource(const TSubclassOf<class UTargetDatasource>& _targetPickerDataSource, EDiveDetectionCase* _outEDiveCase, TSubclassOf<class UAnimSequencePickerSlotContainer>* _outAnimPickerSlotContainer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeDiveGameplayAbility", "GetDiveCaseEnumAndAnimFromDataSource");

	Params::RuntimeDiveGameplayAbility_GetDiveCaseEnumAndAnimFromDataSource Parms{};

	Parms._targetPickerDataSource = _targetPickerDataSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outEDiveCase != nullptr)
		*_outEDiveCase = Parms._outEDiveCase;

	if (_outAnimPickerSlotContainer != nullptr)
		*_outAnimPickerSlotContainer = Parms._outAnimPickerSlotContainer;
}


// Function Runtime.RuntimeFakeCharacter.BPE_SetupNameTagWidget
// (Event, Public, BlueprintEvent)

void ARuntimeFakeCharacter::BPE_SetupNameTagWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeFakeCharacter", "BPE_SetupNameTagWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.RuntimeFakeCharacter.GetImitatedPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerState* ARuntimeFakeCharacter::GetImitatedPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeFakeCharacter", "GetImitatedPlayerState");

	Params::RuntimeFakeCharacter_GetImitatedPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.DistanceTrajectoryStatusDeactivateCondition.BPE_SetDistance
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FShootParams&              _shootParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float*                                  _fDistance                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDistanceTrajectoryStatusDeactivateCondition::BPE_SetDistance(const struct FShootParams& _shootParams, float* _fDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceTrajectoryStatusDeactivateCondition", "BPE_SetDistance");

	Params::DistanceTrajectoryStatusDeactivateCondition_BPE_SetDistance Parms{};

	Parms._shootParams = std::move(_shootParams);

	UObject::ProcessEvent(Func, &Parms);

	if (_fDistance != nullptr)
		*_fDistance = Parms._fDistance;
}


// Function Runtime.RuntimeGameInstance.BPE_UpdateAchievementProgress
// (Event, Public, BlueprintEvent)
// Parameters:
// class ARuntimeMatchGameState*           _runtimeMatchGameState                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bMatchWon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeGameInstance::BPE_UpdateAchievementProgress(class ARuntimeMatchGameState* _runtimeMatchGameState, bool _bMatchWon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameInstance", "BPE_UpdateAchievementProgress");

	Params::RuntimeGameInstance_BPE_UpdateAchievementProgress Parms{};

	Parms._runtimeMatchGameState = _runtimeMatchGameState;
	Parms._bMatchWon = _bMatchWon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.RuntimeGameplayEffectContextHelpers.BPF_GetRuntimeGameplayEffectContext
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayEffectContextHandle&_handle                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRuntimeGameplayEffectContext*   _outContext                                            (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeGameplayEffectContextHelpers::BPF_GetRuntimeGameplayEffectContext(const struct FGameplayEffectContextHandle& _handle, struct FRuntimeGameplayEffectContext* _outContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeGameplayEffectContextHelpers", "BPF_GetRuntimeGameplayEffectContext");

	Params::RuntimeGameplayEffectContextHelpers_BPF_GetRuntimeGameplayEffectContext Parms{};

	Parms._handle = std::move(_handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outContext != nullptr)
		*_outContext = std::move(Parms._outContext);

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeGameplayEffectContextHelpers.BPF_MakeRuntimeGameplayEffectContextHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameplayAbility*                 _owningAbility                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _ShootData                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FShootParams&              _shootParams                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     _tagContainer                                          (ConstParm, Parm, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_targetDataHandle                                      (ConstParm, Parm, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle*    _outHandle                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void URuntimeGameplayEffectContextHelpers::BPF_MakeRuntimeGameplayEffectContextHandle(class UGameplayAbility* _owningAbility, const struct FShootPrepTargetData& _ShootData, const struct FShootParams& _shootParams, const struct FGameplayTagContainer& _tagContainer, const struct FGameplayAbilityTargetDataHandle& _targetDataHandle, struct FGameplayEffectContextHandle* _outHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeGameplayEffectContextHelpers", "BPF_MakeRuntimeGameplayEffectContextHandle");

	Params::RuntimeGameplayEffectContextHelpers_BPF_MakeRuntimeGameplayEffectContextHandle Parms{};

	Parms._owningAbility = _owningAbility;
	Parms._ShootData = std::move(_ShootData);
	Parms._shootParams = std::move(_shootParams);
	Parms._tagContainer = std::move(_tagContainer);
	Parms._targetDataHandle = std::move(_targetDataHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outHandle != nullptr)
		*_outHandle = std::move(Parms._outHandle);
}


// Function Runtime.RuntimeGameSettings.BPF_GetRuntimeMainSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class URuntimeGameSettings*       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class URuntimeGameSettings* URuntimeGameSettings::BPF_GetRuntimeMainSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeGameSettings", "BPF_GetRuntimeMainSettings");

	Params::RuntimeGameSettings_BPF_GetRuntimeMainSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialObjective.IsObjectiveOver
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTutorialObjective::IsObjectiveOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjective", "IsObjectiveOver");

	Params::TutorialObjective_IsObjectiveOver Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialObjective.ObjectiveAchievedOnce
// (Native, Public, BlueprintCallable)

void UTutorialObjective::ObjectiveAchievedOnce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjective", "ObjectiveAchievedOnce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialObjective.ObjectiveCompleted
// (Final, Native, Public, BlueprintCallable)

void UTutorialObjective::ObjectiveCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjective", "ObjectiveCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialObjective.OnEndObjective
// (Event, Public, BlueprintEvent)

void UTutorialObjective::OnEndObjective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjective", "OnEndObjective");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.TutorialObjective.OnInitObjective
// (Event, Public, BlueprintEvent)

void UTutorialObjective::OnInitObjective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjective", "OnInitObjective");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.TutorialObjective.GetManagerOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATutorialManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATutorialManager* UTutorialObjective::GetManagerOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjective", "GetManagerOwner");

	Params::TutorialObjective_GetManagerOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeGameState.MulticastOnBallsReset
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ARuntimeGameState::MulticastOnBallsReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameState", "MulticastOnBallsReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeGameState.BPF_GetBall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABall*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABall* ARuntimeGameState::BPF_GetBall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameState", "BPF_GetBall");

	Params::RuntimeGameState_BPF_GetBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeGameState.BPF_GetBalls
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ABall*>*                   _outBallsArray                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARuntimeGameState::BPF_GetBalls(TArray<class ABall*>* _outBallsArray) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameState", "BPF_GetBalls");

	Params::RuntimeGameState_BPF_GetBalls Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outBallsArray != nullptr)
		*_outBallsArray = std::move(Parms._outBallsArray);
}


// Function Runtime.RuntimeGameState.BPF_GetGoals
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AGoal*>*                   _outGoals                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ARuntimeGameState::BPF_GetGoals(TArray<class AGoal*>* _outGoals) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameState", "BPF_GetGoals");

	Params::RuntimeGameState_BPF_GetGoals Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outGoals != nullptr)
		*_outGoals = std::move(Parms._outGoals);
}


// Function Runtime.RuntimeGameState.BPF_GetGoalsFromTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   _uiTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AGoal*>              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AGoal*> ARuntimeGameState::BPF_GetGoalsFromTeam(uint8 _uiTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameState", "BPF_GetGoalsFromTeam");

	Params::RuntimeGameState_BPF_GetGoalsFromTeam Parms{};

	Parms._uiTeam = _uiTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeGameState.BPF_GetTeamCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ARuntimeGameState::BPF_GetTeamCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeGameState", "BPF_GetTeamCount");

	Params::RuntimeGameState_BPF_GetTeamCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_BallStolen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ARuntimePlayerState*              _playerStateThief                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimePlayerState*              _playerStateStolen                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameState::BPF_BallStolen(class ARuntimePlayerState* _playerStateThief, class ARuntimePlayerState* _playerStateStolen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_BallStolen");

	Params::RuntimeMatchGameState_BPF_BallStolen Parms{};

	Parms._playerStateThief = _playerStateThief;
	Parms._playerStateStolen = _playerStateStolen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.BPF_CheckTimeReached
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             _fTimeToCheck                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              _matchTimerEventTag                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fSecondsTolerance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeMatchGameState::BPF_CheckTimeReached(const float _fTimeToCheck, const struct FGameplayTag& _matchTimerEventTag, float _fSecondsTolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_CheckTimeReached");

	Params::RuntimeMatchGameState_BPF_CheckTimeReached Parms{};

	Parms._fTimeToCheck = _fTimeToCheck;
	Parms._matchTimerEventTag = std::move(_matchTimerEventTag);
	Parms._fSecondsTolerance = _fSecondsTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_NotifyServicesMatchEnded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                _controller                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameState::BPF_NotifyServicesMatchEnded(class APlayerController* _controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_NotifyServicesMatchEnded");

	Params::RuntimeMatchGameState_BPF_NotifyServicesMatchEnded Parms{};

	Parms._controller = _controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.MulticastOnBallStolen
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ARuntimePlayerState*              _playerStateThief                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimePlayerState*              _playerStateStolen                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameState::MulticastOnBallStolen(class ARuntimePlayerState* _playerStateThief, class ARuntimePlayerState* _playerStateStolen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "MulticastOnBallStolen");

	Params::RuntimeMatchGameState_MulticastOnBallStolen Parms{};

	Parms._playerStateThief = _playerStateThief;
	Parms._playerStateStolen = _playerStateStolen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnNativeTeamColorChanged
// (Final, Native, Public)

void ARuntimeMatchGameState::OnNativeTeamColorChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnNativeTeamColorChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnOwnershipChanged
// (Final, Native, Protected)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayerInteraction                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameState::OnOwnershipChanged(class UBallPlayersInteractionComponent* _ballPlayerInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnOwnershipChanged");

	Params::RuntimeMatchGameState_OnOwnershipChanged Parms{};

	Parms._ballPlayerInteraction = _ballPlayerInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnPlayerRemoved
// (Final, Native, Public)
// Parameters:
// const class ARuntimePlayerState*        _playerState                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameState::OnPlayerRemoved(const class ARuntimePlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnPlayerRemoved");

	Params::RuntimeMatchGameState_OnPlayerRemoved Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnPlayerStateReplicatedInController
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameState::OnPlayerStateReplicatedInController(class APlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnPlayerStateReplicatedInController");

	Params::RuntimeMatchGameState_OnPlayerStateReplicatedInController Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnPreviousOwnerChanged
// (Final, Native, Protected)
// Parameters:
// class UBallPlayersInteractionComponent* _ballPlayerInteraction                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBallInteractionType                    _eInteractionType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameState::OnPreviousOwnerChanged(class UBallPlayersInteractionComponent* _ballPlayerInteraction, EBallInteractionType _eInteractionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnPreviousOwnerChanged");

	Params::RuntimeMatchGameState_OnPreviousOwnerChanged Parms{};

	Parms._ballPlayerInteraction = _ballPlayerInteraction;
	Parms._eInteractionType = _eInteractionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnRep_AreCaptainAssigned
// (Final, Native, Protected)

void ARuntimeMatchGameState::OnRep_AreCaptainAssigned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnRep_AreCaptainAssigned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnRep_ArPerTeam
// (Final, Native, Protected)

void ARuntimeMatchGameState::OnRep_ArPerTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnRep_ArPerTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnRep_ClutchTimeState
// (Final, Native, Protected)

void ARuntimeMatchGameState::OnRep_ClutchTimeState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnRep_ClutchTimeState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnRep_Countdown
// (Final, Native, Protected)

void ARuntimeMatchGameState::OnRep_Countdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnRep_Countdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnRep_CurrentMatchPart
// (Final, Native, Protected)

void ARuntimeMatchGameState::OnRep_CurrentMatchPart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnRep_CurrentMatchPart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnRep_GoalHistory
// (Final, Native, Protected)

void ARuntimeMatchGameState::OnRep_GoalHistory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnRep_GoalHistory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnRep_IsInMatchPartTransition
// (Final, Native, Protected)

void ARuntimeMatchGameState::OnRep_IsInMatchPartTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnRep_IsInMatchPartTransition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnRep_IsInOvertime
// (Final, Native, Protected)

void ARuntimeMatchGameState::OnRep_IsInOvertime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnRep_IsInOvertime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnRep_PlayerExpectedNum
// (Native, Protected)

void ARuntimeMatchGameState::OnRep_PlayerExpectedNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnRep_PlayerExpectedNum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnRep_ScoreKeyToValueArray
// (Final, Native, Protected)

void ARuntimeMatchGameState::OnRep_ScoreKeyToValueArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnRep_ScoreKeyToValueArray");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.OnShowPrematchTeamDisplayChanged
// (Final, Native, Public)

void ARuntimeMatchGameState::OnShowPrematchTeamDisplayChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "OnShowPrematchTeamDisplayChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetCaptain
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   _uiTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimePlayerState*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARuntimePlayerState* ARuntimeMatchGameState::BPF_GetCaptain(uint8 _uiTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetCaptain");

	Params::RuntimeMatchGameState_BPF_GetCaptain Parms{};

	Parms._uiTeam = _uiTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetCaptains
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ARuntimePlayerState*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ARuntimePlayerState*> ARuntimeMatchGameState::BPF_GetCaptains() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetCaptains");

	Params::RuntimeMatchGameState_BPF_GetCaptains Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetCaptainTeamColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   _uiTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    _mainColor                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    _secondaryColor                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    _tertiaryColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeMatchGameState::BPF_GetCaptainTeamColor(uint8 _uiTeam, struct FLinearColor* _mainColor, struct FLinearColor* _secondaryColor, struct FLinearColor* _tertiaryColor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetCaptainTeamColor");

	Params::RuntimeMatchGameState_BPF_GetCaptainTeamColor Parms{};

	Parms._uiTeam = _uiTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_mainColor != nullptr)
		*_mainColor = std::move(Parms._mainColor);

	if (_secondaryColor != nullptr)
		*_secondaryColor = std::move(Parms._secondaryColor);

	if (_tertiaryColor != nullptr)
		*_tertiaryColor = std::move(Parms._tertiaryColor);

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetClutchTimeState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EClutchTimeState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EClutchTimeState ARuntimeMatchGameState::BPF_GetClutchTimeState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetClutchTimeState");

	Params::RuntimeMatchGameState_BPF_GetClutchTimeState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetCountdown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARuntimeMatchGameState::BPF_GetCountdown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetCountdown");

	Params::RuntimeMatchGameState_BPF_GetCountdown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetCountdownDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARuntimeMatchGameState::BPF_GetCountdownDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetCountdownDuration");

	Params::RuntimeMatchGameState_BPF_GetCountdownDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetCurrentMatchPartEndTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARuntimeMatchGameState::BPF_GetCurrentMatchPartEndTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetCurrentMatchPartEndTime");

	Params::RuntimeMatchGameState_BPF_GetCurrentMatchPartEndTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetCurrentMatchTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARuntimeMatchGameState::BPF_GetCurrentMatchTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetCurrentMatchTime");

	Params::RuntimeMatchGameState_BPF_GetCurrentMatchTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetMatchDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARuntimeMatchGameState::BPF_GetMatchDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetMatchDuration");

	Params::RuntimeMatchGameState_BPF_GetMatchDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetMatchDurationWithOvertime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARuntimeMatchGameState::BPF_GetMatchDurationWithOvertime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetMatchDurationWithOvertime");

	Params::RuntimeMatchGameState_BPF_GetMatchDurationWithOvertime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetMatchPart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARuntimeMatchGameState::BPF_GetMatchPart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetMatchPart");

	Params::RuntimeMatchGameState_BPF_GetMatchPart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetMatchType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ARuntimeMatchGameState::BPF_GetMatchType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetMatchType");

	Params::RuntimeMatchGameState_BPF_GetMatchType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetNumberOfMatchBreak
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARuntimeMatchGameState::BPF_GetNumberOfMatchBreak() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetNumberOfMatchBreak");

	Params::RuntimeMatchGameState_BPF_GetNumberOfMatchBreak Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetServerRegion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARuntimeMatchGameState::BPF_GetServerRegion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetServerRegion");

	Params::RuntimeMatchGameState_BPF_GetServerRegion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetTeamScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   _uiTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARuntimeMatchGameState::BPF_GetTeamScore(uint8 _uiTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetTeamScore");

	Params::RuntimeMatchGameState_BPF_GetTeamScore Parms{};

	Parms._uiTeam = _uiTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetTeamStageAR
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   _uiTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCustomizationARDataAsset*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomizationARDataAsset* ARuntimeMatchGameState::BPF_GetTeamStageAR(uint8 _uiTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetTeamStageAR");

	Params::RuntimeMatchGameState_BPF_GetTeamStageAR Parms{};

	Parms._uiTeam = _uiTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetTeamStageARTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   _uiTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ARuntimeMatchGameState::BPF_GetTeamStageARTag(uint8 _uiTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetTeamStageARTag");

	Params::RuntimeMatchGameState_BPF_GetTeamStageARTag Parms{};

	Parms._uiTeam = _uiTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARuntimeMatchGameState::BPF_GetTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetTimer");

	Params::RuntimeMatchGameState_BPF_GetTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_GetUniqueWinningTeam
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8*                                  _uiOutTeam                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   _bOutHasUniqueWinner                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameState::BPF_GetUniqueWinningTeam(uint8* _uiOutTeam, bool* _bOutHasUniqueWinner) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_GetUniqueWinningTeam");

	Params::RuntimeMatchGameState_BPF_GetUniqueWinningTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_uiOutTeam != nullptr)
		*_uiOutTeam = Parms._uiOutTeam;

	if (_bOutHasUniqueWinner != nullptr)
		*_bOutHasUniqueWinner = Parms._bOutHasUniqueWinner;
}


// Function Runtime.RuntimeMatchGameState.BPF_HasDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeMatchGameState::BPF_HasDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_HasDuration");

	Params::RuntimeMatchGameState_BPF_HasDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_HasOvertimeDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeMatchGameState::BPF_HasOvertimeDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_HasOvertimeDuration");

	Params::RuntimeMatchGameState_BPF_HasOvertimeDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_IsCountdownRunning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeMatchGameState::BPF_IsCountdownRunning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_IsCountdownRunning");

	Params::RuntimeMatchGameState_BPF_IsCountdownRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_IsInClutchTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeMatchGameState::BPF_IsInClutchTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_IsInClutchTime");

	Params::RuntimeMatchGameState_BPF_IsInClutchTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_IsInMatchPartTransition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeMatchGameState::BPF_IsInMatchPartTransition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_IsInMatchPartTransition");

	Params::RuntimeMatchGameState_BPF_IsInMatchPartTransition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_IsOvertimeInfinite
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimeMatchGameState::BPF_IsOvertimeInfinite() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_IsOvertimeInfinite");

	Params::RuntimeMatchGameState_BPF_IsOvertimeInfinite Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMatchGameState.BPF_TriggerOnScoreEvent
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const int32                             _iPointLeftBeforeLeft                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimeMatchGameState::BPF_TriggerOnScoreEvent(const int32 _iPointLeftBeforeLeft) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchGameState", "BPF_TriggerOnScoreEvent");

	Params::RuntimeMatchGameState_BPF_TriggerOnScoreEvent Parms{};

	Parms._iPointLeftBeforeLeft = _iPointLeftBeforeLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMatchSubsystem.BPF_GetNbPlayersInCurrentMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeMatchSubsystem::BPF_GetNbPlayersInCurrentMatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMatchSubsystem", "BPF_GetNbPlayersInCurrentMatch");

	Params::RuntimeMatchSubsystem_BPF_GetNbPlayersInCurrentMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMenuFlowSubsystem.BPF_PlayMenuCameraSequence
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   _levelSequenceToPlay                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMenuCameraSequenceParams& _menuSequenceParams                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URuntimeMenuFlowSubsystem::BPF_PlayMenuCameraSequence(class ULevelSequence* _levelSequenceToPlay, const struct FMenuCameraSequenceParams& _menuSequenceParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMenuFlowSubsystem", "BPF_PlayMenuCameraSequence");

	Params::RuntimeMenuFlowSubsystem_BPF_PlayMenuCameraSequence Parms{};

	Parms._levelSequenceToPlay = _levelSequenceToPlay;
	Parms._menuSequenceParams = std::move(_menuSequenceParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMenuFlowSubsystem.BPF_SwitchToLocalCharacterCam
// (Final, Native, Public, BlueprintCallable)

void URuntimeMenuFlowSubsystem::BPF_SwitchToLocalCharacterCam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMenuFlowSubsystem", "BPF_SwitchToLocalCharacterCam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMenuFlowSubsystem.BPF_SwitchToRegisteredMenuCam
// (Final, Native, Public, BlueprintCallable)

void URuntimeMenuFlowSubsystem::BPF_SwitchToRegisteredMenuCam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMenuFlowSubsystem", "BPF_SwitchToRegisteredMenuCam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMenuFlowSubsystem.OnTransitionSequenceFinished
// (Final, Native, Private)

void URuntimeMenuFlowSubsystem::OnTransitionSequenceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMenuFlowSubsystem", "OnTransitionSequenceFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMenuFlowSubsystem.BPF_IsInMenuCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeMenuFlowSubsystem::BPF_IsInMenuCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMenuFlowSubsystem", "BPF_IsInMenuCamera");

	Params::RuntimeMenuFlowSubsystem_BPF_IsInMenuCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_FreemoveV1
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldFreemoveV1                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_FreemoveV1(const struct FGameplayAttributeData& _oldFreemoveV1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_FreemoveV1");

	Params::RuntimeMovementAttributeSet_OnRep_FreemoveV1 Parms{};

	Parms._oldFreemoveV1 = std::move(_oldFreemoveV1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_FreemoveV2
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldFreemoveV2                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_FreemoveV2(const struct FGameplayAttributeData& _oldFreemoveV2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_FreemoveV2");

	Params::RuntimeMovementAttributeSet_OnRep_FreemoveV2 Parms{};

	Parms._oldFreemoveV2 = std::move(_oldFreemoveV2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_FreemoveV3
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldFreemoveV3                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_FreemoveV3(const struct FGameplayAttributeData& _oldFreemoveV3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_FreemoveV3");

	Params::RuntimeMovementAttributeSet_OnRep_FreemoveV3 Parms{};

	Parms._oldFreemoveV3 = std::move(_oldFreemoveV3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_FreemoveWithBallV1
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldFreemoveWithBallV1                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_FreemoveWithBallV1(const struct FGameplayAttributeData& _oldFreemoveWithBallV1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_FreemoveWithBallV1");

	Params::RuntimeMovementAttributeSet_OnRep_FreemoveWithBallV1 Parms{};

	Parms._oldFreemoveWithBallV1 = std::move(_oldFreemoveWithBallV1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_FreemoveWithBallV2
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldFreemoveWithBallV2                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_FreemoveWithBallV2(const struct FGameplayAttributeData& _oldFreemoveWithBallV2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_FreemoveWithBallV2");

	Params::RuntimeMovementAttributeSet_OnRep_FreemoveWithBallV2 Parms{};

	Parms._oldFreemoveWithBallV2 = std::move(_oldFreemoveWithBallV2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_FreemoveWithBallV3
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldFreemoveWithBallV3                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_FreemoveWithBallV3(const struct FGameplayAttributeData& _oldFreemoveWithBallV3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_FreemoveWithBallV3");

	Params::RuntimeMovementAttributeSet_OnRep_FreemoveWithBallV3 Parms{};

	Parms._oldFreemoveWithBallV3 = std::move(_oldFreemoveWithBallV3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_GoalKeeperV1
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldGoalKeeperV1                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_GoalKeeperV1(const struct FGameplayAttributeData& _oldGoalKeeperV1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_GoalKeeperV1");

	Params::RuntimeMovementAttributeSet_OnRep_GoalKeeperV1 Parms{};

	Parms._oldGoalKeeperV1 = std::move(_oldGoalKeeperV1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_GoalKeeperV2
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldGoalKeeperV2                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_GoalKeeperV2(const struct FGameplayAttributeData& _oldGoalKeeperV2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_GoalKeeperV2");

	Params::RuntimeMovementAttributeSet_OnRep_GoalKeeperV2 Parms{};

	Parms._oldGoalKeeperV2 = std::move(_oldGoalKeeperV2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_GoalKeeperV3
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldGoalKeeperV3                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_GoalKeeperV3(const struct FGameplayAttributeData& _oldGoalKeeperV3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_GoalKeeperV3");

	Params::RuntimeMovementAttributeSet_OnRep_GoalKeeperV3 Parms{};

	Parms._oldGoalKeeperV3 = std::move(_oldGoalKeeperV3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_GoalKeeperWithBallV1
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldGoalKeeperWithBallV1                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_GoalKeeperWithBallV1(const struct FGameplayAttributeData& _oldGoalKeeperWithBallV1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_GoalKeeperWithBallV1");

	Params::RuntimeMovementAttributeSet_OnRep_GoalKeeperWithBallV1 Parms{};

	Parms._oldGoalKeeperWithBallV1 = std::move(_oldGoalKeeperWithBallV1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_GoalKeeperWithBallV2
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldGoalKeeperWithBallV2                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_GoalKeeperWithBallV2(const struct FGameplayAttributeData& _oldGoalKeeperWithBallV2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_GoalKeeperWithBallV2");

	Params::RuntimeMovementAttributeSet_OnRep_GoalKeeperWithBallV2 Parms{};

	Parms._oldGoalKeeperWithBallV2 = std::move(_oldGoalKeeperWithBallV2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_GoalKeeperWithBallV3
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldGoalKeeperWithBallV3                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_GoalKeeperWithBallV3(const struct FGameplayAttributeData& _oldGoalKeeperWithBallV3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_GoalKeeperWithBallV3");

	Params::RuntimeMovementAttributeSet_OnRep_GoalKeeperWithBallV3 Parms{};

	Parms._oldGoalKeeperWithBallV3 = std::move(_oldGoalKeeperWithBallV3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_LockmoveGoalKeeperV1
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldLockmoveGoalKeeperV1                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_LockmoveGoalKeeperV1(const struct FGameplayAttributeData& _oldLockmoveGoalKeeperV1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_LockmoveGoalKeeperV1");

	Params::RuntimeMovementAttributeSet_OnRep_LockmoveGoalKeeperV1 Parms{};

	Parms._oldLockmoveGoalKeeperV1 = std::move(_oldLockmoveGoalKeeperV1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_LockmoveGoalKeeperV2
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldLockmoveGoalKeeperV2                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_LockmoveGoalKeeperV2(const struct FGameplayAttributeData& _oldLockmoveGoalKeeperV2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_LockmoveGoalKeeperV2");

	Params::RuntimeMovementAttributeSet_OnRep_LockmoveGoalKeeperV2 Parms{};

	Parms._oldLockmoveGoalKeeperV2 = std::move(_oldLockmoveGoalKeeperV2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_LockmoveGoalKeeperV3
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldLockmoveGoalKeeperV3                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_LockmoveGoalKeeperV3(const struct FGameplayAttributeData& _oldLockmoveGoalKeeperV3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_LockmoveGoalKeeperV3");

	Params::RuntimeMovementAttributeSet_OnRep_LockmoveGoalKeeperV3 Parms{};

	Parms._oldLockmoveGoalKeeperV3 = std::move(_oldLockmoveGoalKeeperV3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_LockmoveV1
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldLockmoveV1                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_LockmoveV1(const struct FGameplayAttributeData& _oldLockmoveV1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_LockmoveV1");

	Params::RuntimeMovementAttributeSet_OnRep_LockmoveV1 Parms{};

	Parms._oldLockmoveV1 = std::move(_oldLockmoveV1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_LockmoveV2
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldLockmoveV2                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_LockmoveV2(const struct FGameplayAttributeData& _oldLockmoveV2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_LockmoveV2");

	Params::RuntimeMovementAttributeSet_OnRep_LockmoveV2 Parms{};

	Parms._oldLockmoveV2 = std::move(_oldLockmoveV2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_LockmoveV3
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldLockmoveV3                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_LockmoveV3(const struct FGameplayAttributeData& _oldLockmoveV3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_LockmoveV3");

	Params::RuntimeMovementAttributeSet_OnRep_LockmoveV3 Parms{};

	Parms._oldLockmoveV3 = std::move(_oldLockmoveV3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_LockmoveWithBallV1
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldLockmoveWithBallV1                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_LockmoveWithBallV1(const struct FGameplayAttributeData& _oldLockmoveWithBallV1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_LockmoveWithBallV1");

	Params::RuntimeMovementAttributeSet_OnRep_LockmoveWithBallV1 Parms{};

	Parms._oldLockmoveWithBallV1 = std::move(_oldLockmoveWithBallV1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_LockmoveWithBallV2
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldLockmoveWithBallV2                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_LockmoveWithBallV2(const struct FGameplayAttributeData& _oldLockmoveWithBallV2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_LockmoveWithBallV2");

	Params::RuntimeMovementAttributeSet_OnRep_LockmoveWithBallV2 Parms{};

	Parms._oldLockmoveWithBallV2 = std::move(_oldLockmoveWithBallV2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementAttributeSet.OnRep_LockmoveWithBallV3
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldLockmoveWithBallV3                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeMovementAttributeSet::OnRep_LockmoveWithBallV3(const struct FGameplayAttributeData& _oldLockmoveWithBallV3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementAttributeSet", "OnRep_LockmoveWithBallV3");

	Params::RuntimeMovementAttributeSet_OnRep_LockmoveWithBallV3 Parms{};

	Parms._oldLockmoveWithBallV3 = std::move(_oldLockmoveWithBallV3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementComponent.BPF_FreezeSpeedState
// (Final, Native, Public, BlueprintCallable)

void URuntimeMovementComponent::BPF_FreezeSpeedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementComponent", "BPF_FreezeSpeedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementComponent.BPF_UnfreezeSpeedState
// (Final, Native, Public, BlueprintCallable)

void URuntimeMovementComponent::BPF_UnfreezeSpeedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementComponent", "BPF_UnfreezeSpeedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeMovementComponent.BPF_GetDefaultMaxSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URuntimeMovementComponent::BPF_GetDefaultMaxSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMovementComponent", "BPF_GetDefaultMaxSpeed");

	Params::RuntimeMovementComponent_BPF_GetDefaultMaxSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeMultiPositionAmbientSound.BPF_GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ARuntimeMultiPositionAmbientSound::BPF_GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeMultiPositionAmbientSound", "BPF_GetTeam");

	Params::RuntimeMultiPositionAmbientSound_BPF_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePerformanceTelemetry.OnMatchGameStateEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           _actor                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          _eEndPlayReason                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimePerformanceTelemetry::OnMatchGameStateEndPlay(class AActor* _actor, EEndPlayReason _eEndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePerformanceTelemetry", "OnMatchGameStateEndPlay");

	Params::RuntimePerformanceTelemetry_OnMatchGameStateEndPlay Parms{};

	Parms._actor = _actor;
	Parms._eEndPlayReason = _eEndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialObjectiveOperator.OnSubObjectiveComplete
// (Final, Native, Public)
// Parameters:
// class UTutorialObjective*               _objective                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialObjectiveOperator::OnSubObjectiveComplete(class UTutorialObjective* _objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjectiveOperator", "OnSubObjectiveComplete");

	Params::TutorialObjectiveOperator_OnSubObjectiveComplete Parms{};

	Parms._objective = _objective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.BPF_GetMappingsForAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             _action                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInputActionKeyMapping>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInputActionKeyMapping> ARuntimePlayerController::BPF_GetMappingsForAction(class FName _action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "BPF_GetMappingsForAction");

	Params::RuntimePlayerController_BPF_GetMappingsForAction Parms{};

	Parms._action = _action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerController.BPF_ReportServer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void ARuntimePlayerController::BPF_ReportServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "BPF_ReportServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.BPF_Server_ReassignCaptainInTeam
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void ARuntimePlayerController::BPF_Server_ReassignCaptainInTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "BPF_Server_ReassignCaptainInTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.BPF_SetPlayerName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerController::BPF_SetPlayerName(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "BPF_SetPlayerName");

	Params::RuntimePlayerController_BPF_SetPlayerName Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.BPF_SetShowMouseCursor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    _bShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerController::BPF_SetShowMouseCursor(bool _bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "BPF_SetShowMouseCursor");

	Params::RuntimePlayerController_BPF_SetShowMouseCursor Parms{};

	Parms._bShow = _bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.ClientNotifyBallServerOwnerChanged
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerBallOwnership*             _owner                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRevisionID&               _revisionID                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARuntimePlayerController::ClientNotifyBallServerOwnerChanged(class ABall* _ball, class UPlayerBallOwnership* _owner, const struct FRevisionID& _revisionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "ClientNotifyBallServerOwnerChanged");

	Params::RuntimePlayerController_ClientNotifyBallServerOwnerChanged Parms{};

	Parms._ball = _ball;
	Parms._owner = _owner;
	Parms._revisionID = std::move(_revisionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.ClientNotifyBallServerTrajectory
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerBallOwnership*             _owner                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootStartPoint&          _serverTrajectoryStartingPoint                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FRevisionID&               _revisionID                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ARuntimePlayerController::ClientNotifyBallServerTrajectory(class ABall* _ball, class UPlayerBallOwnership* _owner, const struct FShootStartPoint& _serverTrajectoryStartingPoint, const struct FRevisionID& _revisionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "ClientNotifyBallServerTrajectory");

	Params::RuntimePlayerController_ClientNotifyBallServerTrajectory Parms{};

	Parms._ball = _ball;
	Parms._owner = _owner;
	Parms._serverTrajectoryStartingPoint = std::move(_serverTrajectoryStartingPoint);
	Parms._revisionID = std::move(_revisionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.ExecuteRemoteConsoleCommandRPC
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const class FString&                    _command                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerController::ExecuteRemoteConsoleCommandRPC(const class FString& _command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "ExecuteRemoteConsoleCommandRPC");

	Params::RuntimePlayerController_ExecuteRemoteConsoleCommandRPC Parms{};

	Parms._command = std::move(_command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.OnGameStateValid
// (Final, Native, Private)
// Parameters:
// class AGameStateBase*                   _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerController::OnGameStateValid(class AGameStateBase* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "OnGameStateValid");

	Params::RuntimePlayerController_OnGameStateValid Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.RemoteCmd
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    _command                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerController::RemoteCmd(const class FString& _command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "RemoteCmd");

	Params::RuntimePlayerController_RemoteCmd Parms{};

	Parms._command = std::move(_command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.SendRemoteCommandResult
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const class FString&                    _commandResult                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerController::SendRemoteCommandResult(const class FString& _commandResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "SendRemoteCommandResult");

	Params::RuntimePlayerController_SendRemoteCommandResult Parms{};

	Parms._commandResult = std::move(_commandResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.ServerRequestOverrideSpecialActorsNetParams
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const float                             _fNetUpdateFrequency                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             _fMinNetUpdateFrequency                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             _fNetPriority                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerController::ServerRequestOverrideSpecialActorsNetParams(const float _fNetUpdateFrequency, const float _fMinNetUpdateFrequency, const float _fNetPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "ServerRequestOverrideSpecialActorsNetParams");

	Params::RuntimePlayerController_ServerRequestOverrideSpecialActorsNetParams Parms{};

	Parms._fNetUpdateFrequency = _fNetUpdateFrequency;
	Parms._fMinNetUpdateFrequency = _fMinNetUpdateFrequency;
	Parms._fNetPriority = _fNetPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.StartVisLog
// (Final, Exec, Native, Public)

void ARuntimePlayerController::StartVisLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "StartVisLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.StopVisLog
// (Final, Exec, Native, Public)

void ARuntimePlayerController::StopVisLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "StopVisLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerController.BPF_GetRuntimeCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARuntimeCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARuntimeCharacter* ARuntimePlayerController::BPF_GetRuntimeCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerController", "BPF_GetRuntimeCharacter");

	Params::RuntimePlayerController_BPF_GetRuntimeCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerScoreViewModel.OnMVPSet
// (Final, Native, Public)
// Parameters:
// class ARuntimePlayerState*              _runtimePlayerState                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimePlayerScoreViewModel::OnMVPSet(class ARuntimePlayerState* _runtimePlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerScoreViewModel", "OnMVPSet");

	Params::RuntimePlayerScoreViewModel_OnMVPSet Parms{};

	Parms._runtimePlayerState = _runtimePlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.DurationTrajectoryStatusDeactivateCondition.BPE_SetDuration
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FShootParams&              _shootParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float*                                  _fDuration                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDurationTrajectoryStatusDeactivateCondition::BPE_SetDuration(const struct FShootParams& _shootParams, float* _fDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DurationTrajectoryStatusDeactivateCondition", "BPE_SetDuration");

	Params::DurationTrajectoryStatusDeactivateCondition_BPE_SetDuration Parms{};

	Parms._shootParams = std::move(_shootParams);

	UObject::ProcessEvent(Func, &Parms);

	if (_fDuration != nullptr)
		*_fDuration = Parms._fDuration;
}


// Function Runtime.RuntimePlayersScoreSubsystem.OnLocalPlayerTotalExperienceDataSet
// (Final, Native, Protected)
// Parameters:
// class ARuntimePlayerState*              _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimePlayersScoreSubsystem::OnLocalPlayerTotalExperienceDataSet(class ARuntimePlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayersScoreSubsystem", "OnLocalPlayerTotalExperienceDataSet");

	Params::RuntimePlayersScoreSubsystem_OnLocalPlayerTotalExperienceDataSet Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayersScoreSubsystem.BPF_GetDrawMatchScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimePlayersScoreSubsystem::BPF_GetDrawMatchScore() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayersScoreSubsystem", "BPF_GetDrawMatchScore");

	Params::RuntimePlayersScoreSubsystem_BPF_GetDrawMatchScore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayersScoreSubsystem.BPF_GetMatchLossScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimePlayersScoreSubsystem::BPF_GetMatchLossScore() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayersScoreSubsystem", "BPF_GetMatchLossScore");

	Params::RuntimePlayersScoreSubsystem_BPF_GetMatchLossScore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayersScoreSubsystem.BPF_GetMatchScorePerMin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimePlayersScoreSubsystem::BPF_GetMatchScorePerMin() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayersScoreSubsystem", "BPF_GetMatchScorePerMin");

	Params::RuntimePlayersScoreSubsystem_BPF_GetMatchScorePerMin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayersScoreSubsystem.BPF_GetMatchWonScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimePlayersScoreSubsystem::BPF_GetMatchWonScore() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayersScoreSubsystem", "BPF_GetMatchWonScore");

	Params::RuntimePlayersScoreSubsystem_BPF_GetMatchWonScore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayersScoreSubsystem.BPF_GetOvertimeScorePerMin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimePlayersScoreSubsystem::BPF_GetOvertimeScorePerMin() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayersScoreSubsystem", "BPF_GetOvertimeScorePerMin");

	Params::RuntimePlayersScoreSubsystem_BPF_GetOvertimeScorePerMin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayersScoreSubsystem.BPF_GetScoreMultiplierByMatchType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              _matchType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URuntimePlayersScoreSubsystem::BPF_GetScoreMultiplierByMatchType(const struct FGameplayTag& _matchType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayersScoreSubsystem", "BPF_GetScoreMultiplierByMatchType");

	Params::RuntimePlayersScoreSubsystem_BPF_GetScoreMultiplierByMatchType Parms{};

	Parms._matchType = std::move(_matchType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayersScoreSubsystem.BPF_GetScoreToExpMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URuntimePlayersScoreSubsystem::BPF_GetScoreToExpMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayersScoreSubsystem", "BPF_GetScoreToExpMultiplier");

	Params::RuntimePlayersScoreSubsystem_BPF_GetScoreToExpMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayersScoreSubsystem.GetScoreEventClasses
// (Final, Native, Protected, Const)
// Parameters:
// TArray<class UClass*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UClass*> URuntimePlayersScoreSubsystem::GetScoreEventClasses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayersScoreSubsystem", "GetScoreEventClasses");

	Params::RuntimePlayersScoreSubsystem_GetScoreEventClasses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.WaitForPlayersArrivedFlowState.OnPawnSetInClient
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     _player                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            _newPawn                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            _oldPawn                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaitForPlayersArrivedFlowState::OnPawnSetInClient(class APlayerState* _player, class APawn* _newPawn, class APawn* _oldPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaitForPlayersArrivedFlowState", "OnPawnSetInClient");

	Params::WaitForPlayersArrivedFlowState_OnPawnSetInClient Parms{};

	Parms._player = _player;
	Parms._newPawn = _newPawn;
	Parms._oldPawn = _oldPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.WaitForPlayersArrivedFlowState.OnPlayerStateAddedInClient
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     _PlayerStateAdded                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaitForPlayersArrivedFlowState::OnPlayerStateAddedInClient(class APlayerState* _PlayerStateAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaitForPlayersArrivedFlowState", "OnPlayerStateAddedInClient");

	Params::WaitForPlayersArrivedFlowState_OnPlayerStateAddedInClient Parms{};

	Parms._PlayerStateAdded = _PlayerStateAdded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.WaitForPlayersArrivedFlowState.OnPlayerStateReplicatedInController
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaitForPlayersArrivedFlowState::OnPlayerStateReplicatedInController(class APlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaitForPlayersArrivedFlowState", "OnPlayerStateReplicatedInController");

	Params::WaitForPlayersArrivedFlowState_OnPlayerStateReplicatedInController Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.WaitForPlayersArrivedFlowState.TryToPlayColorChoiceSequences
// (Final, Native, Private)
// Parameters:
// class AController*                      _PlayerController                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaitForPlayersArrivedFlowState::TryToPlayColorChoiceSequences(class AController* _PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaitForPlayersArrivedFlowState", "TryToPlayColorChoiceSequences");

	Params::WaitForPlayersArrivedFlowState_TryToPlayColorChoiceSequences Parms{};

	Parms._PlayerController = _PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.WaitForPlayersArrivedFlowState.TryToPlayPlayerColorChoiceSequence
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     _PlayerStateAdded                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaitForPlayersArrivedFlowState::TryToPlayPlayerColorChoiceSequence(class APlayerState* _PlayerStateAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaitForPlayersArrivedFlowState", "TryToPlayPlayerColorChoiceSequence");

	Params::WaitForPlayersArrivedFlowState_TryToPlayPlayerColorChoiceSequence Parms{};

	Parms._PlayerStateAdded = _PlayerStateAdded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.BPF_EnumerateWorldConfigs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UCustomizationARDataAsset*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCustomizationARDataAsset*> URuntimeStadiumAR::BPF_EnumerateWorldConfigs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeStadiumAR", "BPF_EnumerateWorldConfigs");

	Params::RuntimeStadiumAR_BPF_EnumerateWorldConfigs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.BPE_OnConfigChanged
// (Event, Public, BlueprintEvent)

void URuntimeStadiumAR::BPE_OnConfigChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPE_OnConfigChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.RuntimeStadiumAR.BPE_OnCurrentWorldTagChanged
// (Event, Protected, BlueprintEvent)

void URuntimeStadiumAR::BPE_OnCurrentWorldTagChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPE_OnCurrentWorldTagChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.RuntimeStadiumAR.BPE_OnEditorMapOpened
// (Event, Protected, BlueprintEvent)

void URuntimeStadiumAR::BPE_OnEditorMapOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPE_OnEditorMapOpened");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.RuntimeStadiumAR.BPE_OnGameStateValid
// (Event, Protected, BlueprintEvent)

void URuntimeStadiumAR::BPE_OnGameStateValid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPE_OnGameStateValid");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.RuntimeStadiumAR.BPE_OnPlayTransition
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FRuntimeARTransition&      _params                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::BPE_OnPlayTransition(const struct FRuntimeARTransition& _params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPE_OnPlayTransition");

	Params::RuntimeStadiumAR_BPE_OnPlayTransition Parms{};

	Parms._params = std::move(_params);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.RuntimeStadiumAR.BPE_OnTransitionStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// ESCTransitionState                      _state                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::BPE_OnTransitionStateChanged(ESCTransitionState _state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPE_OnTransitionStateChanged");

	Params::RuntimeStadiumAR_BPE_OnTransitionStateChanged Parms{};

	Parms._state = _state;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.RuntimeStadiumAR.BPE_OnTransitionValueChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   _weight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _direction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::BPE_OnTransitionValueChanged(float _weight, float _direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPE_OnTransitionValueChanged");

	Params::RuntimeStadiumAR_BPE_OnTransitionValueChanged Parms{};

	Parms._weight = _weight;
	Parms._direction = _direction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.RuntimeStadiumAR.BPF_AddProjectionMeshes
// (Final, Native, Protected, BlueprintCallable)

void URuntimeStadiumAR::BPF_AddProjectionMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_AddProjectionMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.BPF_FindActorInCurrentWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class AActor>            _reference                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URuntimeStadiumAR::BPF_FindActorInCurrentWorld(TSoftObjectPtr<class AActor> _reference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_FindActorInCurrentWorld");

	Params::RuntimeStadiumAR_BPF_FindActorInCurrentWorld Parms{};

	Parms._reference = _reference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.BPF_FindActorsInCurrentWorld
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTagQuery&         _query                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> URuntimeStadiumAR::BPF_FindActorsInCurrentWorld(const struct FGameplayTagQuery& _query)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_FindActorsInCurrentWorld");

	Params::RuntimeStadiumAR_BPF_FindActorsInCurrentWorld Parms{};

	Parms._query = std::move(_query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.BPF_GetWorldStreamingState
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              _tag                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESubworldStreamingState                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESubworldStreamingState URuntimeStadiumAR::BPF_GetWorldStreamingState(const struct FGameplayTag& _tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_GetWorldStreamingState");

	Params::RuntimeStadiumAR_BPF_GetWorldStreamingState Parms{};

	Parms._tag = std::move(_tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.BPF_LoadWorld
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              _tag                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::BPF_LoadWorld(const struct FGameplayTag& _tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_LoadWorld");

	Params::RuntimeStadiumAR_BPF_LoadWorld Parms{};

	Parms._tag = std::move(_tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.BPF_PlayTransitionSequence
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRuntimeARTransition&      _params                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::BPF_PlayTransitionSequence(const struct FRuntimeARTransition& _params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_PlayTransitionSequence");

	Params::RuntimeStadiumAR_BPF_PlayTransitionSequence Parms{};

	Parms._params = std::move(_params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.BPF_SetCapturedWorldFromTeamIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   _iTeamIdx                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::BPF_SetCapturedWorldFromTeamIndex(int32 _iTeamIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_SetCapturedWorldFromTeamIndex");

	Params::RuntimeStadiumAR_BPF_SetCapturedWorldFromTeamIndex Parms{};

	Parms._iTeamIdx = _iTeamIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.BPF_SetRenderScale
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   _scale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::BPF_SetRenderScale(float _scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_SetRenderScale");

	Params::RuntimeStadiumAR_BPF_SetRenderScale Parms{};

	Parms._scale = _scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.BPF_SetTransitionState
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UObject*                          _worldContext                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESCTransitionState                      _transitionState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::BPF_SetTransitionState(class UObject* _worldContext, ESCTransitionState _transitionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_SetTransitionState");

	Params::RuntimeStadiumAR_BPF_SetTransitionState Parms{};

	Parms._worldContext = _worldContext;
	Parms._transitionState = _transitionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.BPF_SpawnActorInCurrentWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URuntimeStadiumAR::BPF_SpawnActorInCurrentWorld(TSubclassOf<class AActor> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_SpawnActorInCurrentWorld");

	Params::RuntimeStadiumAR_BPF_SpawnActorInCurrentWorld Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.BPF_StopTransitionSequence
// (Final, Native, Protected, BlueprintCallable)

void URuntimeStadiumAR::BPF_StopTransitionSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_StopTransitionSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.BPF_TriggerTransitionFinishedEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRuntimeARTransition&      _params                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::BPF_TriggerTransitionFinishedEvent(const struct FRuntimeARTransition& _params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_TriggerTransitionFinishedEvent");

	Params::RuntimeStadiumAR_BPF_TriggerTransitionFinishedEvent Parms{};

	Parms._params = std::move(_params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.BPF_TriggerTransitionStartedEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FRuntimeARTransition&      _params                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::BPF_TriggerTransitionStartedEvent(const struct FRuntimeARTransition& _params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_TriggerTransitionStartedEvent");

	Params::RuntimeStadiumAR_BPF_TriggerTransitionStartedEvent Parms{};

	Parms._params = std::move(_params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.GetFieldARConfig
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class URTFieldARConfig*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URTFieldARConfig* URuntimeStadiumAR::GetFieldARConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "GetFieldARConfig");

	Params::RuntimeStadiumAR_GetFieldARConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.GetStadiumARConfig
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class URTStadiumARConfig*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URTStadiumARConfig* URuntimeStadiumAR::GetStadiumARConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "GetStadiumARConfig");

	Params::RuntimeStadiumAR_GetStadiumARConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.OnFinishedTransitionSequence
// (Final, Native, Protected)

void URuntimeStadiumAR::OnFinishedTransitionSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "OnFinishedTransitionSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.SetCapturedWorldByDataAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomizationARDataAsset*        _pDataAsset                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::SetCapturedWorldByDataAsset(class UCustomizationARDataAsset* _pDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "SetCapturedWorldByDataAsset");

	Params::RuntimeStadiumAR_SetCapturedWorldByDataAsset Parms{};

	Parms._pDataAsset = _pDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.SetCapturedWorldByTag_Deprecated
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              _worldContentTag                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::SetCapturedWorldByTag_Deprecated(const struct FGameplayTag& _worldContentTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "SetCapturedWorldByTag_Deprecated");

	Params::RuntimeStadiumAR_SetCapturedWorldByTag_Deprecated Parms{};

	Parms._worldContentTag = std::move(_worldContentTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.SetRenderScale
// (Final, Native, Public)
// Parameters:
// float                                   _scale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::SetRenderScale(float _scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "SetRenderScale");

	Params::RuntimeStadiumAR_SetRenderScale Parms{};

	Parms._scale = _scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.SetTransitionState
// (Final, Native, Public)
// Parameters:
// ESCTransitionState                      _transitionState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::SetTransitionState(ESCTransitionState _transitionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "SetTransitionState");

	Params::RuntimeStadiumAR_SetTransitionState Parms{};

	Parms._transitionState = _transitionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumAR.BPF_GetCurrentWorldConfig
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRTStadiumARWorldConfig          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRTStadiumARWorldConfig URuntimeStadiumAR::BPF_GetCurrentWorldConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_GetCurrentWorldConfig");

	Params::RuntimeStadiumAR_BPF_GetCurrentWorldConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.BPF_GetTeamWorld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   _iTeamIdx                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCustomizationARDataAsset*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomizationARDataAsset* URuntimeStadiumAR::BPF_GetTeamWorld(int32 _iTeamIdx) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_GetTeamWorld");

	Params::RuntimeStadiumAR_BPF_GetTeamWorld Parms{};

	Parms._iTeamIdx = _iTeamIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.BPF_GetTeamWorldTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   _iTeamIdx                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag URuntimeStadiumAR::BPF_GetTeamWorldTag(int32 _iTeamIdx) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_GetTeamWorldTag");

	Params::RuntimeStadiumAR_BPF_GetTeamWorldTag Parms{};

	Parms._iTeamIdx = _iTeamIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.BPF_GetTransitionEffectAR
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              _tag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRuntimeARTransitionEffect       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRuntimeARTransitionEffect URuntimeStadiumAR::BPF_GetTransitionEffectAR(const struct FGameplayTag& _tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_GetTransitionEffectAR");

	Params::RuntimeStadiumAR_BPF_GetTransitionEffectAR Parms{};

	Parms._tag = std::move(_tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.BPF_GetTransitionEffectStadium
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              _tag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    GoalA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRuntimeARTransitionEffect       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRuntimeARTransitionEffect URuntimeStadiumAR::BPF_GetTransitionEffectStadium(const struct FGameplayTag& _tag, bool GoalA) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_GetTransitionEffectStadium");

	Params::RuntimeStadiumAR_BPF_GetTransitionEffectStadium Parms{};

	Parms._tag = std::move(_tag);
	Parms.GoalA = GoalA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStadiumAR.BPF_WorldTagUseOpaqueRendering
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FGameplayTag&              _worldTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   _bResult                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStadiumAR::BPF_WorldTagUseOpaqueRendering(const struct FGameplayTag& _worldTag, bool* _bResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumAR", "BPF_WorldTagUseOpaqueRendering");

	Params::RuntimeStadiumAR_BPF_WorldTagUseOpaqueRendering Parms{};

	Parms._worldTag = std::move(_worldTag);

	UObject::ProcessEvent(Func, &Parms);

	if (_bResult != nullptr)
		*_bResult = Parms._bResult;
}


// Function Runtime.RuntimeReplaySubsystem.OnGoaldScored
// (Final, Native, Private)
// Parameters:
// const struct FGoalDescription&          _goalDescription                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void URuntimeReplaySubsystem::OnGoaldScored(const struct FGoalDescription& _goalDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeReplaySubsystem", "OnGoaldScored");

	Params::RuntimeReplaySubsystem_OnGoaldScored Parms{};

	Parms._goalDescription = std::move(_goalDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeReplaySubsystem.OnReplayPhaseChanged
// (Final, Native, Public)
// Parameters:
// const class AActor*                     _actorToLookAt                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     _actorToFollow                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeReplaySubsystem::OnReplayPhaseChanged(const class AActor* _actorToLookAt, const class AActor* _actorToFollow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeReplaySubsystem", "OnReplayPhaseChanged");

	Params::RuntimeReplaySubsystem_OnReplayPhaseChanged Parms{};

	Parms._actorToLookAt = _actorToLookAt;
	Parms._actorToFollow = _actorToFollow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeReplaySubsystem.BPF_GetFollowActorFromCurrentPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URuntimeReplaySubsystem::BPF_GetFollowActorFromCurrentPhase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeReplaySubsystem", "BPF_GetFollowActorFromCurrentPhase");

	Params::RuntimeReplaySubsystem_BPF_GetFollowActorFromCurrentPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeReplaySubsystem.BPF_GetReplayActor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   _uiTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _iNumberInTeam                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimeCharacter**               _outCharacter                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimePlayerState**             _outPlayerState                                        (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeReplaySubsystem::BPF_GetReplayActor(uint8 _uiTeam, int32 _iNumberInTeam, class ARuntimeCharacter** _outCharacter, class ARuntimePlayerState** _outPlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeReplaySubsystem", "BPF_GetReplayActor");

	Params::RuntimeReplaySubsystem_BPF_GetReplayActor Parms{};

	Parms._uiTeam = _uiTeam;
	Parms._iNumberInTeam = _iNumberInTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outCharacter != nullptr)
		*_outCharacter = Parms._outCharacter;

	if (_outPlayerState != nullptr)
		*_outPlayerState = Parms._outPlayerState;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeReplaySubsystem.BPF_GetReplayScorerActor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARuntimeCharacter**               _outCharacter                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARuntimePlayerState**             _outPlayerState                                        (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeReplaySubsystem::BPF_GetReplayScorerActor(class ARuntimeCharacter** _outCharacter, class ARuntimePlayerState** _outPlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeReplaySubsystem", "BPF_GetReplayScorerActor");

	Params::RuntimeReplaySubsystem_BPF_GetReplayScorerActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outCharacter != nullptr)
		*_outCharacter = Parms._outCharacter;

	if (_outPlayerState != nullptr)
		*_outPlayerState = Parms._outPlayerState;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeReplaySubsystem.BPF_GetScorer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARuntimePlayerState*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARuntimePlayerState* URuntimeReplaySubsystem::BPF_GetScorer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeReplaySubsystem", "BPF_GetScorer");

	Params::RuntimeReplaySubsystem_BPF_GetScorer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeReplaySubsystem.BPF_GetScorerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URuntimeReplaySubsystem::BPF_GetScorerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeReplaySubsystem", "BPF_GetScorerName");

	Params::RuntimeReplaySubsystem_BPF_GetScorerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeReplaySubsystem.BPF_IsPlayingReplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeReplaySubsystem::BPF_IsPlayingReplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeReplaySubsystem", "BPF_IsPlayingReplay");

	Params::RuntimeReplaySubsystem_BPF_IsPlayingReplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeReplaySubsystem.BPF_ScorerIsAnAlly
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeReplaySubsystem::BPF_ScorerIsAnAlly() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeReplaySubsystem", "BPF_ScorerIsAnAlly");

	Params::RuntimeReplaySubsystem_BPF_ScorerIsAnAlly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeSaveSubsystem.OnAuthenticated
// (Final, Native, Protected, HasOutParams)
// Parameters:
// bool                                    _bSuccess                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSOSErrorInfos&            _errorInfos                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URuntimeSaveSubsystem::OnAuthenticated(bool _bSuccess, const struct FSOSErrorInfos& _errorInfos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSaveSubsystem", "OnAuthenticated");

	Params::RuntimeSaveSubsystem_OnAuthenticated Parms{};

	Parms._bSuccess = _bSuccess;
	Parms._errorInfos = std::move(_errorInfos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeShootCameraShake.BPE_GetShootCameraShakeParams
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AActor*                           _actor                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FRuntimeShootCameraShakeParams   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRuntimeShootCameraShakeParams URuntimeShootCameraShake::BPE_GetShootCameraShakeParams(class AActor* _actor, const struct FShootPrepTargetData& _data) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeShootCameraShake", "BPE_GetShootCameraShakeParams");

	Params::RuntimeShootCameraShake_BPE_GetShootCameraShakeParams Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootCameraShakeHelpers.BPF_GetShootCameraShakeParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           _actor                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FRuntimeShootCameraShakeParams   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRuntimeShootCameraShakeParams UShootCameraShakeHelpers::BPF_GetShootCameraShakeParams(class AActor* _actor, const struct FShootPrepTargetData& _data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootCameraShakeHelpers", "BPF_GetShootCameraShakeParams");

	Params::ShootCameraShakeHelpers_BPF_GetShootCameraShakeParams Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPE_ClientInitialize
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AController*                      _controller                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::BPE_ClientInitialize(class AController* _controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPE_ClientInitialize");

	Params::RuntimePlayerState_BPE_ClientInitialize Parms{};

	Parms._controller = _controller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.RuntimePlayerState.BPF_ResetShowPrematchTeamDisplay
// (Final, Native, Public, BlueprintCallable)

void ARuntimePlayerState::BPF_ResetShowPrematchTeamDisplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_ResetShowPrematchTeamDisplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.BPF_SetCaptain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    _bIsCaptain                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::BPF_SetCaptain(bool _bIsCaptain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_SetCaptain");

	Params::RuntimePlayerState_BPF_SetCaptain Parms{};

	Parms._bIsCaptain = _bIsCaptain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.BPF_SetFinisherInputActionPressed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USCInputAction*                   _inputAction                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::BPF_SetFinisherInputActionPressed(class USCInputAction* _inputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_SetFinisherInputActionPressed");

	Params::RuntimePlayerState_BPF_SetFinisherInputActionPressed Parms{};

	Parms._inputAction = _inputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.BPF_SetPlayerName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    _name                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::BPF_SetPlayerName(const class FString& _name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_SetPlayerName");

	Params::RuntimePlayerState_BPF_SetPlayerName Parms{};

	Parms._name = std::move(_name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.BPF_SetTeam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::BPF_SetTeam(uint8 Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_SetTeam");

	Params::RuntimePlayerState_BPF_SetTeam Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.BPF_ToggleShowPrematchTeamDisplay
// (Final, Native, Public, BlueprintCallable)

void ARuntimePlayerState::BPF_ToggleShowPrematchTeamDisplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_ToggleShowPrematchTeamDisplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.OnCaptainSet
// (Final, Native, Private)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::OnCaptainSet(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "OnCaptainSet");

	Params::RuntimePlayerState_OnCaptainSet Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.OnInitialReplication
// (Final, Native, Private)
// Parameters:
// class ASCPlayerState*                   _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::OnInitialReplication(class ASCPlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "OnInitialReplication");

	Params::RuntimePlayerState_OnInitialReplication Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.OnRep_ColorChoiceSequenceActor
// (Final, Native, Protected)
// Parameters:
// class ARuntimeLevelSequenceActor*       _oldAnimSequence                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::OnRep_ColorChoiceSequenceActor(class ARuntimeLevelSequenceActor* _oldAnimSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "OnRep_ColorChoiceSequenceActor");

	Params::RuntimePlayerState_OnRep_ColorChoiceSequenceActor Parms{};

	Parms._oldAnimSequence = _oldAnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.OnRep_CurrentCusto
// (Final, Native, Private)

void ARuntimePlayerState::OnRep_CurrentCusto()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "OnRep_CurrentCusto");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.OnRep_CurrentPlayerProfileCusto
// (Final, Native, Private)

void ARuntimePlayerState::OnRep_CurrentPlayerProfileCusto()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "OnRep_CurrentPlayerProfileCusto");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.OnRep_IsCaptain
// (Final, Native, Private)

void ARuntimePlayerState::OnRep_IsCaptain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "OnRep_IsCaptain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.OnRep_IsMvp
// (Final, Native, Protected)

void ARuntimePlayerState::OnRep_IsMvp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "OnRep_IsMvp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.OnRep_NumberInTeam
// (Final, Native, Private)

void ARuntimePlayerState::OnRep_NumberInTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "OnRep_NumberInTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.OnRep_Team
// (Final, Native, Private)

void ARuntimePlayerState::OnRep_Team()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "OnRep_Team");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.OnRep_TotalExperienceData
// (Final, Native, Protected)

void ARuntimePlayerState::OnRep_TotalExperienceData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "OnRep_TotalExperienceData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.OnSetIsMVP
// (Final, Native, Private)
// Parameters:
// class ARuntimePlayerState*              _playerState                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::OnSetIsMVP(class ARuntimePlayerState* _playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "OnSetIsMVP");

	Params::RuntimePlayerState_OnSetIsMVP Parms{};

	Parms._playerState = _playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.SetTeamColorKitUsed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETeamColorKitType                       _usedColorKit                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::SetTeamColorKitUsed(ETeamColorKitType _usedColorKit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "SetTeamColorKitUsed");

	Params::RuntimePlayerState_SetTeamColorKitUsed Parms{};

	Parms._usedColorKit = _usedColorKit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimePlayerState.BPF_GetIsCaptain
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimePlayerState::BPF_GetIsCaptain() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetIsCaptain");

	Params::RuntimePlayerState_BPF_GetIsCaptain Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_GetNumberInTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARuntimePlayerState::BPF_GetNumberInTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetNumberInTeam");

	Params::RuntimePlayerState_BPF_GetNumberInTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_GetOpponentTeamColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor*                    _mainColor                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    _secondaryColor                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    _tertiaryColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::BPF_GetOpponentTeamColor(struct FLinearColor* _mainColor, struct FLinearColor* _secondaryColor, struct FLinearColor* _tertiaryColor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetOpponentTeamColor");

	Params::RuntimePlayerState_BPF_GetOpponentTeamColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_mainColor != nullptr)
		*_mainColor = std::move(Parms._mainColor);

	if (_secondaryColor != nullptr)
		*_secondaryColor = std::move(Parms._secondaryColor);

	if (_tertiaryColor != nullptr)
		*_tertiaryColor = std::move(Parms._tertiaryColor);
}


// Function Runtime.RuntimePlayerState.BPF_GetOtherTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ARuntimePlayerState::BPF_GetOtherTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetOtherTeam");

	Params::RuntimePlayerState_BPF_GetOtherTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_GetOwningController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* ARuntimePlayerState::BPF_GetOwningController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetOwningController");

	Params::RuntimePlayerState_BPF_GetOwningController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_GetPlayerProfileAvatarItemId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARuntimePlayerState::BPF_GetPlayerProfileAvatarItemId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetPlayerProfileAvatarItemId");

	Params::RuntimePlayerState_BPF_GetPlayerProfileAvatarItemId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_GetPlayerProfileBannerItemId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARuntimePlayerState::BPF_GetPlayerProfileBannerItemId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetPlayerProfileBannerItemId");

	Params::RuntimePlayerState_BPF_GetPlayerProfileBannerItemId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_GetPlayerProfileTitleItemId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARuntimePlayerState::BPF_GetPlayerProfileTitleItemId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetPlayerProfileTitleItemId");

	Params::RuntimePlayerState_BPF_GetPlayerProfileTitleItemId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_GetSanitizedName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ARuntimePlayerState::BPF_GetSanitizedName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetSanitizedName");

	Params::RuntimePlayerState_BPF_GetSanitizedName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_GetStageAR
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCustomizationARDataAsset*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomizationARDataAsset* ARuntimePlayerState::BPF_GetStageAR() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetStageAR");

	Params::RuntimePlayerState_BPF_GetStageAR Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_GetStageARTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ARuntimePlayerState::BPF_GetStageARTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetStageARTag");

	Params::RuntimePlayerState_BPF_GetStageARTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ARuntimePlayerState::BPF_GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetTeam");

	Params::RuntimePlayerState_BPF_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_GetTeamColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor*                    _mainColor                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    _secondaryColor                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    _tertiaryColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuntimePlayerState::BPF_GetTeamColor(struct FLinearColor* _mainColor, struct FLinearColor* _secondaryColor, struct FLinearColor* _tertiaryColor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetTeamColor");

	Params::RuntimePlayerState_BPF_GetTeamColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_mainColor != nullptr)
		*_mainColor = std::move(Parms._mainColor);

	if (_secondaryColor != nullptr)
		*_secondaryColor = std::move(Parms._secondaryColor);

	if (_tertiaryColor != nullptr)
		*_tertiaryColor = std::move(Parms._tertiaryColor);
}


// Function Runtime.RuntimePlayerState.BPF_GetValueOfStat
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class USCStatControllerBase>_statClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARuntimePlayerState::BPF_GetValueOfStat(TSubclassOf<class USCStatControllerBase> _statClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_GetValueOfStat");

	Params::RuntimePlayerState_BPF_GetValueOfStat Parms{};

	Parms._statClass = _statClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimePlayerState.BPF_IsMvp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARuntimePlayerState::BPF_IsMvp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimePlayerState", "BPF_IsMvp");

	Params::RuntimePlayerState_BPF_IsMvp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.MeshMergeFunctionLibrary.BPF_MergeMeshComponents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class USkeletalMeshComponent*>&_meshComponents                                        (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FSkeletalMeshMergeParams&  _params                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMeshMergeFunctionLibrary::BPF_MergeMeshComponents(const TArray<class USkeletalMeshComponent*>& _meshComponents, const struct FSkeletalMeshMergeParams& _params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MeshMergeFunctionLibrary", "BPF_MergeMeshComponents");

	Params::MeshMergeFunctionLibrary_BPF_MergeMeshComponents Parms{};

	Parms._meshComponents = std::move(_meshComponents);
	Parms._params = std::move(_params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeSOSBindingsSubsystem.BPF_ResetCustomMatchParams
// (Final, Native, Public, BlueprintCallable)

void URuntimeSOSBindingsSubsystem::BPF_ResetCustomMatchParams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSOSBindingsSubsystem", "BPF_ResetCustomMatchParams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeSOSBindingsSubsystem.BPF_SaveCustomMatchParams
// (Final, Native, Public, BlueprintCallable)

void URuntimeSOSBindingsSubsystem::BPF_SaveCustomMatchParams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSOSBindingsSubsystem", "BPF_SaveCustomMatchParams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeSOSBindingsSubsystem.BPF_IsAllowedToJoinSquads
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              _matchType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeSOSBindingsSubsystem::BPF_IsAllowedToJoinSquads(const struct FGameplayTag& _matchType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSOSBindingsSubsystem", "BPF_IsAllowedToJoinSquads");

	Params::RuntimeSOSBindingsSubsystem_BPF_IsAllowedToJoinSquads Parms{};

	Parms._matchType = std::move(_matchType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeSOSBindingsSubsystem.BPF_IsCustomMatchParamVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERuntimeMatchParameterTypes             _eParam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeSOSBindingsSubsystem::BPF_IsCustomMatchParamVisible(ERuntimeMatchParameterTypes _eParam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSOSBindingsSubsystem", "BPF_IsCustomMatchParamVisible");

	Params::RuntimeSOSBindingsSubsystem_BPF_IsCustomMatchParamVisible Parms{};

	Parms._eParam = _eParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeSOSBindingsSubsystem.BPF_IsCustomMatchUserParamVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   _eParam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeSOSBindingsSubsystem::BPF_IsCustomMatchUserParamVisible(uint8 _eParam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSOSBindingsSubsystem", "BPF_IsCustomMatchUserParamVisible");

	Params::RuntimeSOSBindingsSubsystem_BPF_IsCustomMatchUserParamVisible Parms{};

	Parms._eParam = _eParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeSOSComponent.OnAbilityActivated
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayAbilitySpecHandle&_abilityHanddle                                        (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 _abilityActivated                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeSOSComponent::OnAbilityActivated(const struct FGameplayAbilitySpecHandle& _abilityHanddle, class UGameplayAbility* _abilityActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSOSComponent", "OnAbilityActivated");

	Params::RuntimeSOSComponent_OnAbilityActivated Parms{};

	Parms._abilityHanddle = std::move(_abilityHanddle);
	Parms._abilityActivated = _abilityActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeSOSComponent.OnCountdownOver
// (Final, Native, Protected)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeSOSComponent::OnCountdownOver(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSOSComponent", "OnCountdownOver");

	Params::RuntimeSOSComponent_OnCountdownOver Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeSOSComponent.OnCountdownStart
// (Final, Native, Protected)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeSOSComponent::OnCountdownStart(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSOSComponent", "OnCountdownStart");

	Params::RuntimeSOSComponent_OnCountdownStart Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeSOSComponent.OnPossessedPawnChanged
// (Final, Native, Protected)
// Parameters:
// class APawn*                            _oldPawn                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            _newPawn                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeSOSComponent::OnPossessedPawnChanged(class APawn* _oldPawn, class APawn* _newPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSOSComponent", "OnPossessedPawnChanged");

	Params::RuntimeSOSComponent_OnPossessedPawnChanged Parms{};

	Parms._oldPawn = _oldPawn;
	Parms._newPawn = _newPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeSoundSubsystem.BPE_OnLoadingScreenVisibilityChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    _bVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeSoundSubsystem::BPE_OnLoadingScreenVisibilityChanged(bool _bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSoundSubsystem", "BPE_OnLoadingScreenVisibilityChanged");

	Params::RuntimeSoundSubsystem_BPE_OnLoadingScreenVisibilityChanged Parms{};

	Parms._bVisible = _bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Runtime.RuntimeSprintGameplayAbility.CheckIfMoving
// (Final, Native, Private)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeSprintGameplayAbility::CheckIfMoving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSprintGameplayAbility", "CheckIfMoving");

	Params::RuntimeSprintGameplayAbility_CheckIfMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeSprintGameplayAbility.CheckIfStationnary
// (Final, Native, Private)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeSprintGameplayAbility::CheckIfStationnary()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSprintGameplayAbility", "CheckIfStationnary");

	Params::RuntimeSprintGameplayAbility_CheckIfStationnary Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeSprintGameplayAbility.OnCannotSpendAbilityCost
// (Final, Native, Private)

void URuntimeSprintGameplayAbility::OnCannotSpendAbilityCost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSprintGameplayAbility", "OnCannotSpendAbilityCost");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeSprintGameplayAbility.OnSprintInputRelease
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FInputActionState&         _state                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    _bActivated                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeSprintGameplayAbility::OnSprintInputRelease(const struct FInputActionState& _state, bool _bActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSprintGameplayAbility", "OnSprintInputRelease");

	Params::RuntimeSprintGameplayAbility_OnSprintInputRelease Parms{};

	Parms._state = std::move(_state);
	Parms._bActivated = _bActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeSprintGameplayAbility.OnStopMoving
// (Final, Native, Private)

void URuntimeSprintGameplayAbility::OnStopMoving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeSprintGameplayAbility", "OnStopMoving");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStadiumEditorSystem.LaunchStadiumMapsOptimization
// (Final, Native, Public, BlueprintCallable)

void URuntimeStadiumEditorSystem::LaunchStadiumMapsOptimization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStadiumEditorSystem", "LaunchStadiumMapsOptimization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStatBehaviourTimer.OnOvertimeStart
// (Final, Native, Public)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStatBehaviourTimer::OnOvertimeStart(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStatBehaviourTimer", "OnOvertimeStart");

	Params::RuntimeStatBehaviourTimer_OnOvertimeStart Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStatDataIsInRange.BPF_GetRangeTargetActor
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class APawn*                      _instigatorPawn                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* URuntimeStatDataIsInRange::BPF_GetRangeTargetActor(const class APawn* _instigatorPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStatDataIsInRange", "BPF_GetRangeTargetActor");

	Params::RuntimeStatDataIsInRange_BPF_GetRangeTargetActor Parms{};

	Parms._instigatorPawn = _instigatorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeStatsSubsystem.OnGoalScored
// (Final, Native, Protected)
// Parameters:
// const struct FGoalDescription&          _goalDescription                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void URuntimeStatsSubsystem::OnGoalScored(const struct FGoalDescription& _goalDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStatsSubsystem", "OnGoalScored");

	Params::RuntimeStatsSubsystem_OnGoalScored Parms{};

	Parms._goalDescription = std::move(_goalDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStatsSubsystem.OnMatchCountdownFinished
// (Final, Native, Public)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStatsSubsystem::OnMatchCountdownFinished(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStatsSubsystem", "OnMatchCountdownFinished");

	Params::RuntimeStatsSubsystem_OnMatchCountdownFinished Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStatsSubsystem.OnMatchFirstCountdownFinished
// (Final, Native, Public)
// Parameters:
// class ARuntimeMatchGameState*           _gameState                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeStatsSubsystem::OnMatchFirstCountdownFinished(class ARuntimeMatchGameState* _gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStatsSubsystem", "OnMatchFirstCountdownFinished");

	Params::RuntimeStatsSubsystem_OnMatchFirstCountdownFinished Parms{};

	Parms._gameState = _gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeStatsSubsystem.OnRematch
// (Final, Native, Protected)

void URuntimeStatsSubsystem::OnRematch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeStatsSubsystem", "OnRematch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeTools.BPF_ComputeSpeedState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APawn*                      _pawn                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESCCharacterSpeedState                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESCCharacterSpeedState URuntimeTools::BPF_ComputeSpeedState(const class APawn* _pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeTools", "BPF_ComputeSpeedState");

	Params::RuntimeTools_BPF_ComputeSpeedState Parms{};

	Parms._pawn = _pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeTools.BPF_GetAllPawns
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _inRefActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bShouldBeOnScreen                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bFilterByTeam                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bOnlyAllies                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APawn*>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APawn*> URuntimeTools::BPF_GetAllPawns(const class AActor* _inRefActor, bool _bShouldBeOnScreen, bool _bFilterByTeam, bool _bOnlyAllies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeTools", "BPF_GetAllPawns");

	Params::RuntimeTools_BPF_GetAllPawns Parms{};

	Parms._inRefActor = _inRefActor;
	Parms._bShouldBeOnScreen = _bShouldBeOnScreen;
	Parms._bFilterByTeam = _bFilterByTeam;
	Parms._bOnlyAllies = _bOnlyAllies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeTools.BPF_GetCurrentMenuGameFlowSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    _worldContext                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCGameFlowSubsystem*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USCGameFlowSubsystem* URuntimeTools::BPF_GetCurrentMenuGameFlowSubsystem(const class UObject* _worldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeTools", "BPF_GetCurrentMenuGameFlowSubsystem");

	Params::RuntimeTools_BPF_GetCurrentMenuGameFlowSubsystem Parms{};

	Parms._worldContext = _worldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeTools.BPF_GetLastPlayerScorer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UWorld*                     _world                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerState* URuntimeTools::BPF_GetLastPlayerScorer(const class UWorld* _world)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeTools", "BPF_GetLastPlayerScorer");

	Params::RuntimeTools_BPF_GetLastPlayerScorer Parms{};

	Parms._world = _world;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeTools.BPF_GetNearestBall
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _inRefActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bShouldBeOnScreen                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABall*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABall* URuntimeTools::BPF_GetNearestBall(const class AActor* _inRefActor, bool _bShouldBeOnScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeTools", "BPF_GetNearestBall");

	Params::RuntimeTools_BPF_GetNearestBall Parms{};

	Parms._inRefActor = _inRefActor;
	Parms._bShouldBeOnScreen = _bShouldBeOnScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeTools.BPF_GetNearestGoal
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _inRefActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bShouldBeOnScreen                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bFilterByTeam                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bOnlyOurGoal                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGoal*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGoal* URuntimeTools::BPF_GetNearestGoal(const class AActor* _inRefActor, bool _bShouldBeOnScreen, bool _bFilterByTeam, bool _bOnlyOurGoal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeTools", "BPF_GetNearestGoal");

	Params::RuntimeTools_BPF_GetNearestGoal Parms{};

	Parms._inRefActor = _inRefActor;
	Parms._bShouldBeOnScreen = _bShouldBeOnScreen;
	Parms._bFilterByTeam = _bFilterByTeam;
	Parms._bOnlyOurGoal = _bOnlyOurGoal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeTools.BPF_GetNearestPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _inRefActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bShouldBeOnScreen                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bFilterByTeam                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bOnlyAllies                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* URuntimeTools::BPF_GetNearestPawn(const class AActor* _inRefActor, bool _bShouldBeOnScreen, bool _bFilterByTeam, bool _bOnlyAllies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeTools", "BPF_GetNearestPawn");

	Params::RuntimeTools_BPF_GetNearestPawn Parms{};

	Parms._inRefActor = _inRefActor;
	Parms._bShouldBeOnScreen = _bShouldBeOnScreen;
	Parms._bFilterByTeam = _bFilterByTeam;
	Parms._bOnlyAllies = _bOnlyAllies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeTools.BPF_GetPlayerCountInTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UWorld*                     _world                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint8                             _uiTeam                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeTools::BPF_GetPlayerCountInTeam(const class UWorld* _world, const uint8 _uiTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeTools", "BPF_GetPlayerCountInTeam");

	Params::RuntimeTools_BPF_GetPlayerCountInTeam Parms{};

	Parms._world = _world;
	Parms._uiTeam = _uiTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeTools.BPF_GetRequestedTargets
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            _requester                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRuntimeTargetRequest&     _request                                               (Parm, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle URuntimeTools::BPF_GetRequestedTargets(class APawn* _requester, const struct FRuntimeTargetRequest& _request)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeTools", "BPF_GetRequestedTargets");

	Params::RuntimeTools_BPF_GetRequestedTargets Parms{};

	Parms._requester = _requester;
	Parms._request = std::move(_request);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeTools.BPF_ShouldJumpForReception
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EBallReceptionArea                      _eReceptionArea                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeTools::BPF_ShouldJumpForReception(EBallReceptionArea _eReceptionArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeTools", "BPF_ShouldJumpForReception");

	Params::RuntimeTools_BPF_ShouldJumpForReception Parms{};

	Parms._eReceptionArea = _eReceptionArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeVideoSubsystem.BPF_SetupVideo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBinkMediaPlayer*                 Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   fVideoTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeVideoSubsystem::BPF_SetupVideo(class UBinkMediaPlayer* Player, bool bShouldPlay, float fVideoTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeVideoSubsystem", "BPF_SetupVideo");

	Params::RuntimeVideoSubsystem_BPF_SetupVideo Parms{};

	Parms.Player = Player;
	Parms.bShouldPlay = bShouldPlay;
	Parms.fVideoTime = fVideoTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeVideoSubsystem.BPF_StopVideo
// (Final, Native, Public, BlueprintCallable)

void URuntimeVideoSubsystem::BPF_StopVideo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeVideoSubsystem", "BPF_StopVideo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeWelcomeFlowSubsystem.BPF_GetContentTypeForWelcomeFlowStep
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EWelcomeFlowStep                        _step                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERematchWelcomeFlowContentType          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERematchWelcomeFlowContentType URuntimeWelcomeFlowSubsystem::BPF_GetContentTypeForWelcomeFlowStep(EWelcomeFlowStep _step)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeWelcomeFlowSubsystem", "BPF_GetContentTypeForWelcomeFlowStep");

	Params::RuntimeWelcomeFlowSubsystem_BPF_GetContentTypeForWelcomeFlowStep Parms{};

	Parms._step = _step;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeWelcomeFlowSubsystem.BPE_EndWelcomeFlow
// (Native, Event, Protected, BlueprintEvent)

void URuntimeWelcomeFlowSubsystem::BPE_EndWelcomeFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeWelcomeFlowSubsystem", "BPE_EndWelcomeFlow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeWelcomeFlowSubsystem.BPE_EndWelcomeFlowStep
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// EWelcomeFlowStep                        _step                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeWelcomeFlowSubsystem::BPE_EndWelcomeFlowStep(EWelcomeFlowStep _step)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeWelcomeFlowSubsystem", "BPE_EndWelcomeFlowStep");

	Params::RuntimeWelcomeFlowSubsystem_BPE_EndWelcomeFlowStep Parms{};

	Parms._step = _step;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeWelcomeFlowSubsystem.BPE_StartWelcomeFlowStep
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// EWelcomeFlowStep                        _step                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URuntimeWelcomeFlowSubsystem::BPE_StartWelcomeFlowStep(EWelcomeFlowStep _step)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeWelcomeFlowSubsystem", "BPE_StartWelcomeFlowStep");

	Params::RuntimeWelcomeFlowSubsystem_BPE_StartWelcomeFlowStep Parms{};

	Parms._step = _step;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeWelcomeFlowSubsystem.BPF_EndCurrentWelcomeFlowStep
// (Final, Native, Public, BlueprintCallable)

void URuntimeWelcomeFlowSubsystem::BPF_EndCurrentWelcomeFlowStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeWelcomeFlowSubsystem", "BPF_EndCurrentWelcomeFlowStep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeWelcomeFlowSubsystem.BPF_StartWelcomeFlow
// (Final, Native, Public, BlueprintCallable)

void URuntimeWelcomeFlowSubsystem::BPF_StartWelcomeFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeWelcomeFlowSubsystem", "BPF_StartWelcomeFlow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.RuntimeWelcomeFlowSubsystem.BPF_GetUnreadContentViewModelsForCurrentWelcomeFlowStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UWelcomeFlowContentViewModel*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UWelcomeFlowContentViewModel*> URuntimeWelcomeFlowSubsystem::BPF_GetUnreadContentViewModelsForCurrentWelcomeFlowStep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeWelcomeFlowSubsystem", "BPF_GetUnreadContentViewModelsForCurrentWelcomeFlowStep");

	Params::RuntimeWelcomeFlowSubsystem_BPF_GetUnreadContentViewModelsForCurrentWelcomeFlowStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeWelcomeFlowSubsystem.BPF_HasWelcomeFlowStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URuntimeWelcomeFlowSubsystem::BPF_HasWelcomeFlowStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuntimeWelcomeFlowSubsystem", "BPF_HasWelcomeFlowStarted");

	Params::RuntimeWelcomeFlowSubsystem_BPF_HasWelcomeFlowStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootBinder.BPE_OnBallRegistered
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootBinder::BPE_OnBallRegistered(class ABall* _ball)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootBinder", "BPE_OnBallRegistered");

	Params::ShootBinder_BPE_OnBallRegistered Parms{};

	Parms._ball = _ball;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootBinder.BPE_OnBallUnregistered
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootBinder::BPE_OnBallUnregistered(class ABall* _ball)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootBinder", "BPE_OnBallUnregistered");

	Params::ShootBinder_BPE_OnBallUnregistered Parms{};

	Parms._ball = _ball;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootBinder.BPE_OnGoalRegistered
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AGoal*                            _goal                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootBinder::BPE_OnGoalRegistered(class AGoal* _goal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootBinder", "BPE_OnGoalRegistered");

	Params::ShootBinder_BPE_OnGoalRegistered Parms{};

	Parms._goal = _goal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootBinder.BPE_OnGoalUnregistered
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AGoal*                            _goal                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootBinder::BPE_OnGoalUnregistered(class AGoal* _goal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootBinder", "BPE_OnGoalUnregistered");

	Params::ShootBinder_BPE_OnGoalUnregistered Parms{};

	Parms._goal = _goal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootBinder.BPE_OnShoot
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const class ABall*                      _ball                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootParams&              _shootParams                                           (Parm, NativeAccessSpecifierPublic)

void UShootBinder::BPE_OnShoot(const class ABall* _ball, const struct FShootParams& _shootParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootBinder", "BPE_OnShoot");

	Params::ShootBinder_BPE_OnShoot Parms{};

	Parms._ball = _ball;
	Parms._shootParams = std::move(_shootParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootBinder.BPE_OnShootBinderTriggered
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const class ABall*                      _ball                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootParams&              _shootParams                                           (Parm, NativeAccessSpecifierPublic)
// class AGoal*                            _goalAimed                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootBinder::BPE_OnShootBinderTriggered(const class ABall* _ball, const struct FShootParams& _shootParams, class AGoal* _goalAimed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootBinder", "BPE_OnShootBinderTriggered");

	Params::ShootBinder_BPE_OnShootBinderTriggered Parms{};

	Parms._ball = _ball;
	Parms._shootParams = std::move(_shootParams);
	Parms._goalAimed = _goalAimed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootBinder.OnBallRegistered
// (Native, Protected)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootBinder::OnBallRegistered(class ABall* _ball)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootBinder", "OnBallRegistered");

	Params::ShootBinder_OnBallRegistered Parms{};

	Parms._ball = _ball;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootBinder.OnBallUnregistered
// (Native, Protected)
// Parameters:
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootBinder::OnBallUnregistered(class ABall* _ball)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootBinder", "OnBallUnregistered");

	Params::ShootBinder_OnBallUnregistered Parms{};

	Parms._ball = _ball;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootBinder.OnGoalRegistered
// (Native, Protected)
// Parameters:
// class AGoal*                            _goal                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootBinder::OnGoalRegistered(class AGoal* _goal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootBinder", "OnGoalRegistered");

	Params::ShootBinder_OnGoalRegistered Parms{};

	Parms._goal = _goal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootBinder.OnGoalUnregistered
// (Native, Protected)
// Parameters:
// class AGoal*                            _goal                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootBinder::OnGoalUnregistered(class AGoal* _goal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootBinder", "OnGoalUnregistered");

	Params::ShootBinder_OnGoalUnregistered Parms{};

	Parms._goal = _goal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootBinder.OnShoot
// (Native, Protected)
// Parameters:
// const class ABall*                      _ball                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootParams&              _shootParams                                           (Parm, NativeAccessSpecifierPublic)

void UShootBinder::OnShoot(const class ABall* _ball, const struct FShootParams& _shootParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShootBinder", "OnShoot");

	Params::ShootBinder_OnShoot Parms{};

	Parms._ball = _ball;
	Parms._shootParams = std::move(_shootParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ShootAbilityData.BPF_MakePrepTargetDataFromClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TSubclassOf<class UShootAbilityData>&_shootDataClass                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UGameplayAbility*           _ability                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   _iPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_context                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EShootOrigin                            _eShootOrigin                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSubclassOf<class URuntimeShootCameraShake>_cameraShake                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShootPrepTargetData             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FShootPrepTargetData UShootAbilityData::BPF_MakePrepTargetDataFromClass(const TSubclassOf<class UShootAbilityData>& _shootDataClass, const class UGameplayAbility* _ability, class ABall* _ball, int32 _iPriority, const struct FGameplayAbilityTargetDataHandle& _context, EShootOrigin _eShootOrigin, const TSubclassOf<class URuntimeShootCameraShake> _cameraShake)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootAbilityData", "BPF_MakePrepTargetDataFromClass");

	Params::ShootAbilityData_BPF_MakePrepTargetDataFromClass Parms{};

	Parms._shootDataClass = _shootDataClass;
	Parms._ability = _ability;
	Parms._ball = _ball;
	Parms._iPriority = _iPriority;
	Parms._context = std::move(_context);
	Parms._eShootOrigin = _eShootOrigin;
	Parms._cameraShake = _cameraShake;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.SimulationStepHelper.BPF_IsCustomOrFreezingSimulationStep
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESimulationStep                         _eSimulationStep                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimulationStepHelper::BPF_IsCustomOrFreezingSimulationStep(ESimulationStep _eSimulationStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SimulationStepHelper", "BPF_IsCustomOrFreezingSimulationStep");

	Params::SimulationStepHelper_BPF_IsCustomOrFreezingSimulationStep Parms{};

	Parms._eSimulationStep = _eSimulationStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.SimulationStepHelper.BPF_IsFlyingOrRollingSimulationStep
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESimulationStep                         _eSimulationStep                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimulationStepHelper::BPF_IsFlyingOrRollingSimulationStep(ESimulationStep _eSimulationStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SimulationStepHelper", "BPF_IsFlyingOrRollingSimulationStep");

	Params::SimulationStepHelper_BPF_IsFlyingOrRollingSimulationStep Parms{};

	Parms._eSimulationStep = _eSimulationStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.SimulationStepHelper.BPF_IsSimulationStepValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESimulationStep                         _eSimulationStep                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimulationStepHelper::BPF_IsSimulationStepValid(ESimulationStep _eSimulationStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SimulationStepHelper", "BPF_IsSimulationStepValid");

	Params::SimulationStepHelper_BPF_IsSimulationStepValid Parms{};

	Parms._eSimulationStep = _eSimulationStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RTBlendableReflectionComponent.SetOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   _opacity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URTBlendableReflectionComponent::SetOpacity(float _opacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTBlendableReflectionComponent", "SetOpacity");

	Params::RTBlendableReflectionComponent_SetOpacity Parms{};

	Parms._opacity = _opacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.JoystickOrientationHelper.BPF_ConvertJoystickOrientationInDegreeAngle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EJoystickOrientation&             _eJoystickOrient                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UJoystickOrientationHelper::BPF_ConvertJoystickOrientationInDegreeAngle(const EJoystickOrientation& _eJoystickOrient)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JoystickOrientationHelper", "BPF_ConvertJoystickOrientationInDegreeAngle");

	Params::JoystickOrientationHelper_BPF_ConvertJoystickOrientationInDegreeAngle Parms{};

	Parms._eJoystickOrient = _eJoystickOrient;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.JoystickOrientationHelper.BPF_GetJoystickOrientationFromAngle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector2D&                 _v2DJoystickValues                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  _fAngle                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             _fDeadZone                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             _fEastWestTolerance                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             _fHalfPiInDegree                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJoystickOrientation                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EJoystickOrientation UJoystickOrientationHelper::BPF_GetJoystickOrientationFromAngle(const struct FVector2D& _v2DJoystickValues, float* _fAngle, const float _fDeadZone, const float _fEastWestTolerance, const float _fHalfPiInDegree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JoystickOrientationHelper", "BPF_GetJoystickOrientationFromAngle");

	Params::JoystickOrientationHelper_BPF_GetJoystickOrientationFromAngle Parms{};

	Parms._v2DJoystickValues = std::move(_v2DJoystickValues);
	Parms._fDeadZone = _fDeadZone;
	Parms._fEastWestTolerance = _fEastWestTolerance;
	Parms._fHalfPiInDegree = _fHalfPiInDegree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_fAngle != nullptr)
		*_fAngle = Parms._fAngle;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_ComputeShootParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_context                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class USCGameplayAbility*         _ability                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _targetData                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   _fCatchupTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fCatchupAnimTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShootParams                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FShootParams UShootHelpers::BPF_ComputeShootParams(const struct FGameplayAbilityTargetDataHandle& _context, const class USCGameplayAbility* _ability, const struct FShootPrepTargetData& _targetData, float _fCatchupTime, float _fCatchupAnimTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_ComputeShootParams");

	Params::ShootHelpers_BPF_ComputeShootParams Parms{};

	Parms._context = std::move(_context);
	Parms._ability = _ability;
	Parms._targetData = std::move(_targetData);
	Parms._fCatchupTime = _fCatchupTime;
	Parms._fCatchupAnimTime = _fCatchupAnimTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_ComputeShootParamsFromAbility
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class USCGameplayAbility*         _ability                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _targetData                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FShootParams*                    _outResult                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    _bUseNetSync                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootHelpers::BPF_ComputeShootParamsFromAbility(const class USCGameplayAbility* _ability, const struct FShootPrepTargetData& _targetData, struct FShootParams* _outResult, bool _bUseNetSync)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_ComputeShootParamsFromAbility");

	Params::ShootHelpers_BPF_ComputeShootParamsFromAbility Parms{};

	Parms._ability = _ability;
	Parms._targetData = std::move(_targetData);
	Parms._bUseNetSync = _bUseNetSync;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outResult != nullptr)
		*_outResult = std::move(Parms._outResult);
}


// Function Runtime.ShootHelpers.BPF_ComputeShootParamsFromAbilityAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class USCGameplayAbility*         _ability                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _targetData                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FShootParams*                    _outResult                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// const struct FVector&                   _vLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fWantedCatchupTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootHelpers::BPF_ComputeShootParamsFromAbilityAtLocation(const class USCGameplayAbility* _ability, const struct FShootPrepTargetData& _targetData, struct FShootParams* _outResult, const struct FVector& _vLocation, float _fWantedCatchupTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_ComputeShootParamsFromAbilityAtLocation");

	Params::ShootHelpers_BPF_ComputeShootParamsFromAbilityAtLocation Parms{};

	Parms._ability = _ability;
	Parms._targetData = std::move(_targetData);
	Parms._vLocation = std::move(_vLocation);
	Parms._fWantedCatchupTime = _fWantedCatchupTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outResult != nullptr)
		*_outResult = std::move(Parms._outResult);
}


// Function Runtime.ShootHelpers.BPF_ComputeShootParamsFromActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _targetData                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FShootParams*                    _outResult                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UShootHelpers::BPF_ComputeShootParamsFromActor(const class AActor* _actor, const struct FShootPrepTargetData& _targetData, struct FShootParams* _outResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_ComputeShootParamsFromActor");

	Params::ShootHelpers_BPF_ComputeShootParamsFromActor Parms{};

	Parms._actor = _actor;
	Parms._targetData = std::move(_targetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outResult != nullptr)
		*_outResult = std::move(Parms._outResult);
}


// Function Runtime.ShootHelpers.BPF_FindShootParamsTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_data                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FShootParamsTargetData*          _outData                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShootHelpers::BPF_FindShootParamsTargetData(const struct FGameplayAbilityTargetDataHandle& _data, struct FShootParamsTargetData* _outData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_FindShootParamsTargetData");

	Params::ShootHelpers_BPF_FindShootParamsTargetData Parms{};

	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outData != nullptr)
		*_outData = std::move(Parms._outData);

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_FindShootPrepTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&_data                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FShootPrepTargetData*            _outData                                               (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShootHelpers::BPF_FindShootPrepTargetData(const struct FGameplayAbilityTargetDataHandle& _data, struct FShootPrepTargetData* _outData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_FindShootPrepTargetData");

	Params::ShootHelpers_BPF_FindShootPrepTargetData Parms{};

	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outData != nullptr)
		*_outData = std::move(Parms._outData);

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetAngleFromMagnusInput
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    _bAbsoluteAngle                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootHelpers::BPF_GetAngleFromMagnusInput(const class AActor* _actor, const struct FShootPrepTargetData& _data, bool _bAbsoluteAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetAngleFromMagnusInput");

	Params::ShootHelpers_BPF_GetAngleFromMagnusInput Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);
	Parms._bAbsoluteAngle = _bAbsoluteAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    _bUseModifiers                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UShootHelpers::BPF_GetShootDirection(const class AActor* _actor, const struct FShootPrepTargetData& _data, bool _bUseModifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootDirection");

	Params::ShootHelpers_BPF_GetShootDirection Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);
	Parms._bUseModifiers = _bUseModifiers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootForce
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    _bUseModifiers                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootHelpers::BPF_GetShootForce(const class AActor* _actor, const struct FShootPrepTargetData& _data, bool _bUseModifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootForce");

	Params::ShootHelpers_BPF_GetShootForce Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);
	Parms._bUseModifiers = _bUseModifiers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootForceMinMax
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    _bUseModifiers                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFloatRange                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFloatRange UShootHelpers::BPF_GetShootForceMinMax(const class AActor* _actor, const struct FShootPrepTargetData& _data, bool _bUseModifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootForceMinMax");

	Params::ShootHelpers_BPF_GetShootForceMinMax Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);
	Parms._bUseModifiers = _bUseModifiers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootForceNormalized
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _runtimeCharacter                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    _bUseModifiers                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootHelpers::BPF_GetShootForceNormalized(const class AActor* _runtimeCharacter, const struct FShootPrepTargetData& _data, bool _bUseModifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootForceNormalized");

	Params::ShootHelpers_BPF_GetShootForceNormalized Parms{};

	Parms._runtimeCharacter = _runtimeCharacter;
	Parms._data = std::move(_data);
	Parms._bUseModifiers = _bUseModifiers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootForceRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _runtimeCharacter                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    _bUseModifiers                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFloatRange                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFloatRange UShootHelpers::BPF_GetShootForceRange(const class AActor* _runtimeCharacter, const struct FShootPrepTargetData& _data, bool _bUseModifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootForceRange");

	Params::ShootHelpers_BPF_GetShootForceRange Parms{};

	Parms._runtimeCharacter = _runtimeCharacter;
	Parms._data = std::move(_data);
	Parms._bUseModifiers = _bUseModifiers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootInputTimeFromShootPrep
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    _bUseModifiers                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootHelpers::BPF_GetShootInputTimeFromShootPrep(const class AActor* _actor, const struct FShootPrepTargetData& _data, bool _bUseModifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootInputTimeFromShootPrep");

	Params::ShootHelpers_BPF_GetShootInputTimeFromShootPrep Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);
	Parms._bUseModifiers = _bUseModifiers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootRotationForce
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    _bUseModifiers                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UShootHelpers::BPF_GetShootRotationForce(const class AActor* _actor, const struct FShootPrepTargetData& _data, bool _bUseModifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootRotationForce");

	Params::ShootHelpers_BPF_GetShootRotationForce Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);
	Parms._bUseModifiers = _bUseModifiers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootRotationForceInput
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UShootHelpers::BPF_GetShootRotationForceInput(const class AActor* _actor, const struct FShootPrepTargetData& _data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootRotationForceInput");

	Params::ShootHelpers_BPF_GetShootRotationForceInput Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootRotationForceRatio
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UShootHelpers::BPF_GetShootRotationForceRatio(const class AActor* _actor, const struct FShootPrepTargetData& _data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootRotationForceRatio");

	Params::ShootHelpers_BPF_GetShootRotationForceRatio Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootStartLocationPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _runtimeCharacter                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _targetData                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_context                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const float                             _fCatchupTime                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&_montageContextFallback                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FShootLocationPointResult        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FShootLocationPointResult UShootHelpers::BPF_GetShootStartLocationPoint(const class AActor* _runtimeCharacter, const struct FShootPrepTargetData& _targetData, const struct FGameplayAbilityTargetDataHandle& _context, const float _fCatchupTime, const struct FGameplayAbilityTargetDataHandle& _montageContextFallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootStartLocationPoint");

	Params::ShootHelpers_BPF_GetShootStartLocationPoint Parms{};

	Parms._runtimeCharacter = _runtimeCharacter;
	Parms._targetData = std::move(_targetData);
	Parms._context = std::move(_context);
	Parms._fCatchupTime = _fCatchupTime;
	Parms._montageContextFallback = std::move(_montageContextFallback);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootTimeRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FFloatRange                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFloatRange UShootHelpers::BPF_GetShootTimeRange(const class AActor* _actor, const struct FShootPrepTargetData& _data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootTimeRange");

	Params::ShootHelpers_BPF_GetShootTimeRange Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootTimeRatioToBuildUpDuration
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootHelpers::BPF_GetShootTimeRatioToBuildUpDuration(const class AActor* _actor, const struct FShootPrepTargetData& _data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootTimeRatioToBuildUpDuration");

	Params::ShootHelpers_BPF_GetShootTimeRatioToBuildUpDuration Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetShootType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const TMap<struct FGameplayTag, struct FFloatRange>&_gameplayTagMap                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UShootHelpers::BPF_GetShootType(const class AActor* _actor, const struct FShootPrepTargetData& _data, const TMap<struct FGameplayTag, struct FFloatRange>& _gameplayTagMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetShootType");

	Params::ShootHelpers_BPF_GetShootType Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);
	Parms._gameplayTagMap = std::move(_gameplayTagMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetSimulatedShootDataFromShootPrep
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FSimulatedShootData*             _outSimulatedShootData                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShootHelpers::BPF_GetSimulatedShootDataFromShootPrep(const struct FShootPrepTargetData& _data, struct FSimulatedShootData* _outSimulatedShootData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetSimulatedShootDataFromShootPrep");

	Params::ShootHelpers_BPF_GetSimulatedShootDataFromShootPrep Parms{};

	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outSimulatedShootData != nullptr)
		*_outSimulatedShootData = std::move(Parms._outSimulatedShootData);

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_GetTrajectoryClosestPointByLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _runtimeCharacter                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBallTrajectoryResult&     _trajectory                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector*                         _vResult                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   _bFoundResult                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  _fDistance                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShootHelpers::BPF_GetTrajectoryClosestPointByLocation(const class AActor* _runtimeCharacter, const struct FBallTrajectoryResult& _trajectory, struct FVector* _vResult, bool* _bFoundResult, float* _fDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetTrajectoryClosestPointByLocation");

	Params::ShootHelpers_BPF_GetTrajectoryClosestPointByLocation Parms{};

	Parms._runtimeCharacter = _runtimeCharacter;
	Parms._trajectory = std::move(_trajectory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_vResult != nullptr)
		*_vResult = std::move(Parms._vResult);

	if (_bFoundResult != nullptr)
		*_bFoundResult = Parms._bFoundResult;

	if (_fDistance != nullptr)
		*_fDistance = Parms._fDistance;
}


// Function Runtime.ShootHelpers.BPF_GetTrajectoryFromSimulatedShootData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FSimulatedShootData&       _simulatedShootData                                    (Parm, NativeAccessSpecifierPublic)
// struct FShootParams*                    _outShootParams                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// class UShootAbilityData*                _shootAbilityData                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABall*                            _ball                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _fPredictionDuration                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bUseTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bApplyModifiers                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBallTrajectoryResult            ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FBallTrajectoryResult UShootHelpers::BPF_GetTrajectoryFromSimulatedShootData(const struct FSimulatedShootData& _simulatedShootData, struct FShootParams* _outShootParams, class UShootAbilityData* _shootAbilityData, const class AActor* _actor, class ABall* _ball, float _fPredictionDuration, bool _bUseTime, bool _bApplyModifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_GetTrajectoryFromSimulatedShootData");

	Params::ShootHelpers_BPF_GetTrajectoryFromSimulatedShootData Parms{};

	Parms._simulatedShootData = std::move(_simulatedShootData);
	Parms._shootAbilityData = _shootAbilityData;
	Parms._actor = _actor;
	Parms._ball = _ball;
	Parms._fPredictionDuration = _fPredictionDuration;
	Parms._bUseTime = _bUseTime;
	Parms._bApplyModifiers = _bApplyModifiers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_outShootParams != nullptr)
		*_outShootParams = std::move(Parms._outShootParams);

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_HasReleaseShootInput
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShootHelpers::BPF_HasReleaseShootInput(const class AActor* _actor, const struct FShootPrepTargetData& _data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_HasReleaseShootInput");

	Params::ShootHelpers_BPF_HasReleaseShootInput Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_MakeShootPrepTargetDataHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle UShootHelpers::BPF_MakeShootPrepTargetDataHandle(const struct FShootPrepTargetData& _data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_MakeShootPrepTargetDataHandle");

	Params::ShootHelpers_BPF_MakeShootPrepTargetDataHandle Parms{};

	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_ShootPrep_IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FShootPrepTargetData&      _targetData                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShootHelpers::BPF_ShootPrep_IsValid(const struct FShootPrepTargetData& _targetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_ShootPrep_IsValid");

	Params::ShootHelpers_BPF_ShootPrep_IsValid Parms{};

	Parms._targetData = std::move(_targetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_TimeRemainingBeforeShoot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootHelpers::BPF_TimeRemainingBeforeShoot(const class AActor* _actor, const struct FShootPrepTargetData& _data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_TimeRemainingBeforeShoot");

	Params::ShootHelpers_BPF_TimeRemainingBeforeShoot Parms{};

	Parms._actor = _actor;
	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_TryToGetImpactNormal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool*                                   _bSuccess                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UShootHelpers::BPF_TryToGetImpactNormal(const struct FShootPrepTargetData& _data, bool* _bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_TryToGetImpactNormal");

	Params::ShootHelpers_BPF_TryToGetImpactNormal Parms{};

	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_bSuccess != nullptr)
		*_bSuccess = Parms._bSuccess;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_TryToGetImpactPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool*                                   _bSuccess                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UShootHelpers::BPF_TryToGetImpactPoint(const struct FShootPrepTargetData& _data, bool* _bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_TryToGetImpactPoint");

	Params::ShootHelpers_BPF_TryToGetImpactPoint Parms{};

	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_bSuccess != nullptr)
		*_bSuccess = Parms._bSuccess;

	return Parms.ReturnValue;
}


// Function Runtime.ShootHelpers.BPF_TryToGetImpactPointOnCameraDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FShootPrepTargetData&      _data                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool*                                   _bSuccess                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UShootHelpers::BPF_TryToGetImpactPointOnCameraDirection(const struct FShootPrepTargetData& _data, bool* _bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootHelpers", "BPF_TryToGetImpactPointOnCameraDirection");

	Params::ShootHelpers_BPF_TryToGetImpactPointOnCameraDirection Parms{};

	Parms._data = std::move(_data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_bSuccess != nullptr)
		*_bSuccess = Parms._bSuccess;

	return Parms.ReturnValue;
}


// Function Runtime.ShootModifierHelpers.BPF_GetMultiplierBySpeedState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _ShootData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const float                             _fBlendTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiplierSpeedStateData& m_Multipliers                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootModifierHelpers::BPF_GetMultiplierBySpeedState(const class AActor* _actor, const struct FShootPrepTargetData& _ShootData, const float _fBlendTime, const struct FMultiplierSpeedStateData& m_Multipliers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootModifierHelpers", "BPF_GetMultiplierBySpeedState");

	Params::ShootModifierHelpers_BPF_GetMultiplierBySpeedState Parms{};

	Parms._actor = _actor;
	Parms._ShootData = std::move(_ShootData);
	Parms._fBlendTime = _fBlendTime;
	Parms.m_Multipliers = std::move(m_Multipliers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootModifierHelpers.BPF_GetMultiplierFromShootModifierDataTable
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _ShootData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class UDataTable*                 _table                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   _vOutDirection                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootModifierHelpers::BPF_GetMultiplierFromShootModifierDataTable(const class AActor* _actor, const struct FShootPrepTargetData& _ShootData, const class UDataTable* _table, const struct FVector& _vOutDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootModifierHelpers", "BPF_GetMultiplierFromShootModifierDataTable");

	Params::ShootModifierHelpers_BPF_GetMultiplierFromShootModifierDataTable Parms{};

	Parms._actor = _actor;
	Parms._ShootData = std::move(_ShootData);
	Parms._table = _table;
	Parms._vOutDirection = std::move(_vOutDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootModifierHelpers.BPF_GetSourceRatioValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _ShootData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ESourceModifierType                     _eSourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFloatInterval&            _intervalToComputeRatio                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootModifierHelpers::BPF_GetSourceRatioValue(const class AActor* _actor, const struct FShootPrepTargetData& _ShootData, ESourceModifierType _eSourceType, const struct FFloatInterval& _intervalToComputeRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootModifierHelpers", "BPF_GetSourceRatioValue");

	Params::ShootModifierHelpers_BPF_GetSourceRatioValue Parms{};

	Parms._actor = _actor;
	Parms._ShootData = std::move(_ShootData);
	Parms._eSourceType = _eSourceType;
	Parms._intervalToComputeRatio = std::move(_intervalToComputeRatio);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.ShootModifierHelpers.BPF_GetSourceValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     _actor                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShootPrepTargetData&      _ShootData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ESourceModifierType                     _eSourceType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShootModifierHelpers::BPF_GetSourceValue(const class AActor* _actor, const struct FShootPrepTargetData& _ShootData, ESourceModifierType _eSourceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ShootModifierHelpers", "BPF_GetSourceValue");

	Params::ShootModifierHelpers_BPF_GetSourceValue Parms{};

	Parms._actor = _actor;
	Parms._ShootData = std::move(_ShootData);
	Parms._eSourceType = _eSourceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.StadiumWorldSettings.BPF_GetRuntimeWorldSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    _context                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    _bForceMainWorld                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStadiumWorldSettings*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AStadiumWorldSettings* AStadiumWorldSettings::BPF_GetRuntimeWorldSettings(const class UObject* _context, bool _bForceMainWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StadiumWorldSettings", "BPF_GetRuntimeWorldSettings");

	Params::StadiumWorldSettings_BPF_GetRuntimeWorldSettings Parms{};

	Parms._context = _context;
	Parms._bForceMainWorld = _bForceMainWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.StadiumWorldSettings.BPF_GetFieldBox
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox AStadiumWorldSettings::BPF_GetFieldBox() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StadiumWorldSettings", "BPF_GetFieldBox");

	Params::StadiumWorldSettings_BPF_GetFieldBox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.SweeperAttributeSet.OnRep_V1
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldV1                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USweeperAttributeSet::OnRep_V1(const struct FGameplayAttributeData& _oldV1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweeperAttributeSet", "OnRep_V1");

	Params::SweeperAttributeSet_OnRep_V1 Parms{};

	Parms._oldV1 = std::move(_oldV1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.SweeperAttributeSet.OnRep_V2
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldV2                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USweeperAttributeSet::OnRep_V2(const struct FGameplayAttributeData& _oldV2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweeperAttributeSet", "OnRep_V2");

	Params::SweeperAttributeSet_OnRep_V2 Parms{};

	Parms._oldV2 = std::move(_oldV2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.SweeperAttributeSet.OnRep_V3
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    _oldV3                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USweeperAttributeSet::OnRep_V3(const struct FGameplayAttributeData& _oldV3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SweeperAttributeSet", "OnRep_V3");

	Params::SweeperAttributeSet_OnRep_V3 Parms{};

	Parms._oldV3 = std::move(_oldV3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ThumbnailCustomizationIds.BPF_GetThumbnailCustomizationId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSCCustomizationId&        _customizationID                                       (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class ULevelSequence>*   _viewSequence                                          (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimSequence>*    _animSequence                                          (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  _fAnimTime                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>*       _defaultTexture                                        (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThumbnailCustomizationIds::BPF_GetThumbnailCustomizationId(const struct FSCCustomizationId& _customizationID, TSoftObjectPtr<class ULevelSequence>* _viewSequence, TSoftObjectPtr<class UAnimSequence>* _animSequence, float* _fAnimTime, TSoftObjectPtr<class UTexture2D>* _defaultTexture) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThumbnailCustomizationIds", "BPF_GetThumbnailCustomizationId");

	Params::ThumbnailCustomizationIds_BPF_GetThumbnailCustomizationId Parms{};

	Parms._customizationID = std::move(_customizationID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_viewSequence != nullptr)
		*_viewSequence = Parms._viewSequence;

	if (_animSequence != nullptr)
		*_animSequence = Parms._animSequence;

	if (_fAnimTime != nullptr)
		*_fAnimTime = Parms._fAnimTime;

	if (_defaultTexture != nullptr)
		*_defaultTexture = Parms._defaultTexture;
}


// Function Runtime.TrajectoryPartHelpers.BPF_GetPartPointAtRatioDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FBallTrajectoryPart&       _trajPart                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   _fRatio                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPredictProjectilePathPointData  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPredictProjectilePathPointData UTrajectoryPartHelpers::BPF_GetPartPointAtRatioDistance(const struct FBallTrajectoryPart& _trajPart, float _fRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TrajectoryPartHelpers", "BPF_GetPartPointAtRatioDistance");

	Params::TrajectoryPartHelpers_BPF_GetPartPointAtRatioDistance Parms{};

	Parms._trajPart = std::move(_trajPart);
	Parms._fRatio = _fRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TrajectoryPartHelpers.BPF_GetPartTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FBallTrajectoryPart&       _trajPart                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTrajectoryPartHelpers::BPF_GetPartTime(const struct FBallTrajectoryPart& _trajPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TrajectoryPartHelpers", "BPF_GetPartTime");

	Params::TrajectoryPartHelpers_BPF_GetPartTime Parms{};

	Parms._trajPart = std::move(_trajPart);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialLogicStep.OnEndLogicStep
// (Event, Public, BlueprintEvent)

void UTutorialLogicStep::OnEndLogicStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLogicStep", "OnEndLogicStep");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.TutorialLogicStep.OnStartLogicStep
// (Event, Public, BlueprintEvent)

void UTutorialLogicStep::OnStartLogicStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLogicStep", "OnStartLogicStep");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.TutorialLogicStep.GetManagerOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATutorialManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATutorialManager* UTutorialLogicStep::GetManagerOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLogicStep", "GetManagerOwner");

	Params::TutorialLogicStep_GetManagerOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialObjectiveListenInput.OnInputActivation
// (Final, Native, Public, HasOutParams)
// Parameters:
// const class USCInputAction*             _uscInputAction                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionState&         _inputActionState                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTutorialObjectiveListenInput::OnInputActivation(const class USCInputAction* _uscInputAction, const struct FInputActionState& _inputActionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjectiveListenInput", "OnInputActivation");

	Params::TutorialObjectiveListenInput_OnInputActivation Parms{};

	Parms._uscInputAction = _uscInputAction;
	Parms._inputActionState = std::move(_inputActionState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialStep.EndStep
// (Final, Native, Public, BlueprintCallable)

void UTutorialStep::EndStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialStep", "EndStep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialStep.GetObjectives
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UTutorialObjective*>       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UTutorialObjective*> UTutorialStep::GetObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialStep", "GetObjectives");

	Params::TutorialStep_GetObjectives Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialStep.OnEndStep
// (Event, Public, BlueprintEvent)

void UTutorialStep::OnEndStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialStep", "OnEndStep");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.TutorialStep.OnObjectiveComplete
// (Final, Native, Public)
// Parameters:
// class UTutorialObjective*               _objective                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialStep::OnObjectiveComplete(class UTutorialObjective* _objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialStep", "OnObjectiveComplete");

	Params::TutorialStep_OnObjectiveComplete Parms{};

	Parms._objective = _objective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.TutorialStep.OnStartStep
// (Event, Public, BlueprintEvent)

void UTutorialStep::OnStartStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialStep", "OnStartStep");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.TutorialStep.BPF_GetObjectiveCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTutorialStep::BPF_GetObjectiveCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialStep", "BPF_GetObjectiveCount");

	Params::TutorialStep_BPF_GetObjectiveCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialStep.BPF_GetObjectiveCountWithIteration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTutorialStep::BPF_GetObjectiveCountWithIteration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialStep", "BPF_GetObjectiveCountWithIteration");

	Params::TutorialStep_BPF_GetObjectiveCountWithIteration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.TutorialStep.GetOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATutorialManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATutorialManager* UTutorialStep::GetOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialStep", "GetOwner");

	Params::TutorialStep_GetOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.UtilityAIComponent.OnTaskFinished
// (Final, Native, Protected)
// Parameters:
// class UUtilityAITask*                   _taskFinished                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUtilityAIComponent::OnTaskFinished(class UUtilityAITask* _taskFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UtilityAIComponent", "OnTaskFinished");

	Params::UtilityAIComponent_OnTaskFinished Parms{};

	Parms._taskFinished = _taskFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.UtilityAIComponent.SetUtilityAiPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUtilityAIPreset*                 _newPreset                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUtilityAIComponent::SetUtilityAiPreset(class UUtilityAIPreset* _newPreset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UtilityAIComponent", "SetUtilityAiPreset");

	Params::UtilityAIComponent_SetUtilityAiPreset Parms{};

	Parms._newPreset = _newPreset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.UtilityAIComponent.StartBehavior
// (Final, Native, Public, BlueprintCallable)

void UUtilityAIComponent::StartBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UtilityAIComponent", "StartBehavior");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.UtilityAIComponent.StopBehavior
// (Final, Native, Public, BlueprintCallable)

void UUtilityAIComponent::StopBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UtilityAIComponent", "StopBehavior");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.UtilityAITask.BPE_OnTaskStart
// (Event, Public, BlueprintEvent)

void UUtilityAITask::BPE_OnTaskStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UtilityAITask", "BPE_OnTaskStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Runtime.UtilityAITask.FinishTask
// (Final, Native, Public, BlueprintCallable)

void UUtilityAITask::FinishTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UtilityAITask", "FinishTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.UtilityAITask.BPE_ComputeAllConsiderationValue
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AAIController*                    _inAIController                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           _inTargetActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class UCurveFloat*, float>*        _outResult                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UUtilityAITask::BPE_ComputeAllConsiderationValue(class AAIController* _inAIController, class AActor* _inTargetActor, TMap<class UCurveFloat*, float>* _outResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UtilityAITask", "BPE_ComputeAllConsiderationValue");

	Params::UtilityAITask_BPE_ComputeAllConsiderationValue Parms{};

	Parms._inAIController = _inAIController;
	Parms._inTargetActor = _inTargetActor;

	UObject::ProcessEvent(Func, &Parms);

	if (_outResult != nullptr)
		*_outResult = std::move(Parms._outResult);
}


// Function Runtime.VoiceChatBlueprintHelperLibrary.GetActiveInputDevice
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          _worldContextObject                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSOSVoiceChatDeviceInfo          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSOSVoiceChatDeviceInfo UVoiceChatBlueprintHelperLibrary::GetActiveInputDevice(class UObject* _worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoiceChatBlueprintHelperLibrary", "GetActiveInputDevice");

	Params::VoiceChatBlueprintHelperLibrary_GetActiveInputDevice Parms{};

	Parms._worldContextObject = _worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.VoiceChatBlueprintHelperLibrary.GetInputDevices
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          _worldContextObject                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSOSVoiceChatDeviceInfo>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSOSVoiceChatDeviceInfo> UVoiceChatBlueprintHelperLibrary::GetInputDevices(class UObject* _worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoiceChatBlueprintHelperLibrary", "GetInputDevices");

	Params::VoiceChatBlueprintHelperLibrary_GetInputDevices Parms{};

	Parms._worldContextObject = _worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.VoiceChatBlueprintHelperLibrary.SetInputDevice
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          _worldContextObject                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    _inputDeviceId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoiceChatBlueprintHelperLibrary::SetInputDevice(class UObject* _worldContextObject, const class FString& _inputDeviceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoiceChatBlueprintHelperLibrary", "SetInputDevice");

	Params::VoiceChatBlueprintHelperLibrary_SetInputDevice Parms{};

	Parms._worldContextObject = _worldContextObject;
	Parms._inputDeviceId = std::move(_inputDeviceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.WelcomeFlowViewModel.BPF_GetUnreadContentViewModelsByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERematchWelcomeFlowContentType          _type                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UWelcomeFlowContentViewModel*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UWelcomeFlowContentViewModel*> UWelcomeFlowViewModel::BPF_GetUnreadContentViewModelsByType(ERematchWelcomeFlowContentType _type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WelcomeFlowViewModel", "BPF_GetUnreadContentViewModelsByType");

	Params::WelcomeFlowViewModel_BPF_GetUnreadContentViewModelsByType Parms{};

	Parms._type = _type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.WelcomeFlowViewModel.BPF_HasUnreadContentOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERematchWelcomeFlowContentType          _type                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWelcomeFlowViewModel::BPF_HasUnreadContentOfType(ERematchWelcomeFlowContentType _type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WelcomeFlowViewModel", "BPF_HasUnreadContentOfType");

	Params::WelcomeFlowViewModel_BPF_HasUnreadContentOfType Parms{};

	Parms._type = _type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.WelcomeFlowViewModel.HasActiveNews
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWelcomeFlowViewModel::HasActiveNews() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WelcomeFlowViewModel", "HasActiveNews");

	Params::WelcomeFlowViewModel_HasActiveNews Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.WelcomeFlowViewModel.HasUnreadContent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWelcomeFlowViewModel::HasUnreadContent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WelcomeFlowViewModel", "HasUnreadContent");

	Params::WelcomeFlowViewModel_HasUnreadContent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.WorkshopViewModel.HasNotWorkshopStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorkshopViewModel::HasNotWorkshopStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopViewModel", "HasNotWorkshopStarted");

	Params::WorkshopViewModel_HasNotWorkshopStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.WorkshopViewModel.IsWorkshopBasedOnScore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorkshopViewModel::IsWorkshopBasedOnScore() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopViewModel", "IsWorkshopBasedOnScore");

	Params::WorkshopViewModel_IsWorkshopBasedOnScore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.WorkshopViewModel.IsWorkshopBasedOnTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorkshopViewModel::IsWorkshopBasedOnTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopViewModel", "IsWorkshopBasedOnTime");

	Params::WorkshopViewModel_IsWorkshopBasedOnTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.WorkshopViewModel.IsWorkshopFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorkshopViewModel::IsWorkshopFinished() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopViewModel", "IsWorkshopFinished");

	Params::WorkshopViewModel_IsWorkshopFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.WorkshopViewModel.IsWorkshopInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorkshopViewModel::IsWorkshopInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopViewModel", "IsWorkshopInProgress");

	Params::WorkshopViewModel_IsWorkshopInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeSequencerBindingLibrary.GetCharacterBodyPart
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FMovieSceneDynamicBindingResolveParams&Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FCharacterPartEnumHandler& BodyPart                                               (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovieSceneDynamicBindingResolveResultReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMovieSceneDynamicBindingResolveResult URuntimeSequencerBindingLibrary::GetCharacterBodyPart(const struct FMovieSceneDynamicBindingResolveParams& Params_0, const struct FCharacterPartEnumHandler& BodyPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeSequencerBindingLibrary", "GetCharacterBodyPart");

	Params::RuntimeSequencerBindingLibrary_GetCharacterBodyPart Parms{};

	Parms.Params_0 = std::move(Params_0);
	Parms.BodyPart = std::move(BodyPart);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RuntimeSequencerBindingLibrary.GoalScorer
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovieSceneDynamicBindingResolveResultReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMovieSceneDynamicBindingResolveResult URuntimeSequencerBindingLibrary::GoalScorer(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RuntimeSequencerBindingLibrary", "GoalScorer");

	Params::RuntimeSequencerBindingLibrary_GoalScorer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Runtime.RTStadiumARLevelStreaming.HandleLevelShown
// (Final, Native, Public)

void URTStadiumARLevelStreaming::HandleLevelShown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RTStadiumARLevelStreaming", "HandleLevelShown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ItemThumbnailComponent.InvalidateCamera
// (Native, Public, BlueprintCallable)

void UItemThumbnailComponent::InvalidateCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailComponent", "InvalidateCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ItemThumbnailComponent.OnBeginLoading
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSoftObjectPtr<class UObject>&    AssetName                                              (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsInitialLoad                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemThumbnailComponent::OnBeginLoading(const TSoftObjectPtr<class UObject>& AssetName, bool bIsInitialLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailComponent", "OnBeginLoading");

	Params::ItemThumbnailComponent_OnBeginLoading Parms{};

	Parms.AssetName = AssetName;
	Parms.bIsInitialLoad = bIsInitialLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ItemThumbnailComponent.OnFinishLoading
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSoftObjectPtr<class UObject>&    AssetName                                              (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemThumbnailComponent::OnFinishLoading(const TSoftObjectPtr<class UObject>& AssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailComponent", "OnFinishLoading");

	Params::ItemThumbnailComponent_OnFinishLoading Parms{};

	Parms.AssetName = AssetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ItemThumbnailComponent.SetMaterial
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FThumbnailMaterial&        InMaterial                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UItemThumbnailComponent::SetMaterial(const struct FThumbnailMaterial& InMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailComponent", "SetMaterial");

	Params::ItemThumbnailComponent_SetMaterial Parms{};

	Parms.InMaterial = std::move(InMaterial);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Runtime.ItemThumbnailComponent.SetSceneClass
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItemThumbnailScene>  InSceneClass                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemThumbnailComponent::SetSceneClass(TSubclassOf<class UItemThumbnailScene> InSceneClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemThumbnailComponent", "SetSceneClass");

	Params::ItemThumbnailComponent_SetSceneClass Parms{};

	Parms.InSceneClass = InSceneClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

