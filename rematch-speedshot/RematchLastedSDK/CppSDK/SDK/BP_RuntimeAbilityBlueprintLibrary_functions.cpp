#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_RuntimeAbilityBlueprintLibrary

#include "Basic.hpp"

#include "BP_RuntimeAbilityBlueprintLibrary_classes.hpp"
#include "BP_RuntimeAbilityBlueprintLibrary_parameters.hpp"


namespace SDK
{

// Function BP_RuntimeAbilityBlueprintLibrary.BP_RuntimeAbilityBlueprintLibrary_C.Check for and Apply Invulnerability
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABall*                            Ball                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APlayerState*                     PlayerState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ARuntimeCharacter*                VictimRuntimeCharacter                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UGameplayAbility*                 GameplayAbility                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    DebugIsOn                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeAbilityBlueprintLibrary_C::Check_for_and_Apply_Invulnerability(class ABall* Ball, class APlayerState* PlayerState, class ARuntimeCharacter* VictimRuntimeCharacter, class UGameplayAbility* GameplayAbility, bool DebugIsOn, const struct FVector& HitLocation, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeAbilityBlueprintLibrary_C", "Check for and Apply Invulnerability");

	Params::BP_RuntimeAbilityBlueprintLibrary_C_Check_for_and_Apply_Invulnerability Parms{};

	Parms.Ball = Ball;
	Parms.PlayerState = PlayerState;
	Parms.VictimRuntimeCharacter = VictimRuntimeCharacter;
	Parms.GameplayAbility = GameplayAbility;
	Parms.DebugIsOn = DebugIsOn;
	Parms.HitLocation = std::move(HitLocation);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BP_RuntimeAbilityBlueprintLibrary.BP_RuntimeAbilityBlueprintLibrary_C.MontageGetPosition
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ACharacter*                       Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FAnimSequencePlayInfos&    PlayInfos                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// float*                                  Position                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeAbilityBlueprintLibrary_C::MontageGetPosition(class ACharacter* Actor, const struct FAnimSequencePlayInfos& PlayInfos, class UObject* __WorldContext, float* Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeAbilityBlueprintLibrary_C", "MontageGetPosition");

	Params::BP_RuntimeAbilityBlueprintLibrary_C_MontageGetPosition Parms{};

	Parms.Actor = Actor;
	Parms.PlayInfos = std::move(PlayInfos);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Position != nullptr)
		*Position = Parms.Position;
}


// Function BP_RuntimeAbilityBlueprintLibrary.BP_RuntimeAbilityBlueprintLibrary_C.MontageIsPlaying
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ACharacter*                       Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FAnimSequencePlayInfos&    PlayInfos                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeAbilityBlueprintLibrary_C::MontageIsPlaying(class ACharacter* Actor, const struct FAnimSequencePlayInfos& PlayInfos, class UObject* __WorldContext, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeAbilityBlueprintLibrary_C", "MontageIsPlaying");

	Params::BP_RuntimeAbilityBlueprintLibrary_C_MontageIsPlaying Parms{};

	Parms.Actor = Actor;
	Parms.PlayInfos = std::move(PlayInfos);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BP_RuntimeAbilityBlueprintLibrary.BP_RuntimeAbilityBlueprintLibrary_C.ShootTowardsLocation
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   _Computation_Impact_Point                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class UObject*                    WorldContextObject                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FShootForceComputationInstance&Force_Computation                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeAbilityBlueprintLibrary_C::ShootTowardsLocation(const struct FVector& _Computation_Impact_Point, const class UObject* WorldContextObject, const struct FShootForceComputationInstance& Force_Computation, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeAbilityBlueprintLibrary_C", "ShootTowardsLocation");

	Params::BP_RuntimeAbilityBlueprintLibrary_C_ShootTowardsLocation Parms{};

	Parms._Computation_Impact_Point = std::move(_Computation_Impact_Point);
	Parms.WorldContextObject = WorldContextObject;
	Parms.Force_Computation = std::move(Force_Computation);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BP_RuntimeAbilityBlueprintLibrary.BP_RuntimeAbilityBlueprintLibrary_C.Snap Nearest Ball To Actor Feet
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InActor                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    InTakeBall                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_RuntimeAbilityBlueprintLibrary_C::Snap_Nearest_Ball_To_Actor_Feet(class AActor* InActor, bool InTakeBall, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_RuntimeAbilityBlueprintLibrary_C", "Snap Nearest Ball To Actor Feet");

	Params::BP_RuntimeAbilityBlueprintLibrary_C_Snap_Nearest_Ball_To_Actor_Feet Parms{};

	Parms.InActor = InActor;
	Parms.InTakeBall = InTakeBall;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}

}

